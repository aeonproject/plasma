#include "ContextBaseClass.h"
#include "ContextDispatch.h"
#include "ScopedLock.h"
#include "ContextLock.h"
#include "ContextService.h"
#include <map>
using namespace mace;

template <class T>
  class ObjectPool{
  public:
    ObjectPool(){

    }
    ~ObjectPool(){
      clear();
    }
    void clear(){
      while( !objqueue.empty() ){
        objqueue.pop();
      }
    }
    void put( T* object ){
      ScopedLock sl( lock );
      //ASSERT( objqueue.push( object ) );
      objqueue.push( object );
    }
    T* get(){
      ScopedLock sl( lock );
      if( objqueue.empty() ){
        sl.unlock();
        T* newobj = new T;
        return newobj;
      }else{
        T* obj = objqueue.front();
        objqueue.pop();
        return obj;
      }
    }
  private:
    static pthread_mutex_t lock;
    std::queue< T*, std::list<T*> > objqueue;
  };
  ObjectPool< mace::Event > eventObjectPool;

void ContextEvent::fire() {
  ADD_SELECTORS("ContextEvent::fire");
  switch( type ){
    case TYPE_NULL:
      break;
    case TYPE_ASYNC_EVENT: {
      sv->executeAsyncEvent( static_cast< AsyncEvent_Message* >(param) );
      break;
    }
    case TYPE_BROADCAST_EVENT:
      sv->executeBroadcastEvent( static_cast< AsyncEvent_Message* >(param) ); 
      break;
    case TYPE_START_EVENT:
      sv->executeStartEvent( static_cast< AsyncEvent_Message* >(param) );
      break;
    case TYPE_GRAP_EVENT:
      sv->executeRoutineGrap( static_cast< Routine_Message* >(param), source );
      break;
    case TYPE_ROUTINE_EVENT: {
      ContextService* _service = static_cast< ContextService* >(sv);
      Routine_Message* routineMsg = static_cast< Routine_Message* >(param);
      mace::Event& event = routineMsg->getEvent();

      const mace::string& fromContextName = event.eventOpInfo.fromContextName;

      const mace::ContextMapping& snapshot = _service->getLatestContextMapping();
      mace::MaceAddr src;
      if( mace::ContextMapping::hasContext2(snapshot, fromContextName) == 0 ) {
        macedbg(1) << "Fail to find event("<< event.eventId <<")'s fromContextName " << fromContextName << Log::endl;
        uint32_t i = 0; 
        while(true) {
          _service->getUpdatedContextMapping(0);
          const mace::ContextMapping& newSnapshot = _service->getLatestContextMapping();
          if( mace::ContextMapping::hasContext2(newSnapshot, fromContextName) <= 0 ){
            maceerr << "Fail to find context("<< fromContextName <<") in context mapping!" << Log::endl;
          } else {
            src = mace::ContextMapping::getNodeByContext(newSnapshot, fromContextName);
            break;
          }
          if( i++ > 10 ){
            ASSERT( mace::ContextMapping::hasContext2(newSnapshot, fromContextName) > 0 );
          }
        }
      } else {
        src = mace::ContextMapping::getNodeByContext(snapshot, fromContextName);
      }

      sv->executeRoutine( static_cast< Routine_Message* >(param), src );
      break;
    }
    case TYPE_COMMIT_CONTEXT:{
      sv->executeCommitContext( static_cast< commit_single_context_Message* >(param) );
      delete param;
      break;
    }
    case TYPE_BROADCAST_COMMIT_CONTEXT: {
      sv->executeBroadcastCommitContext( static_cast<commit_single_context_Message*>(param) );
      delete param;
      break;
    }
  }
}


void ContextCommitEvent::serialize(std::string& str) const{
  mace::serialize( str, &eventId );
  mace::serialize( str, &isAsyncEvent );
}

int ContextCommitEvent::deserialize(std::istream & is) throw (mace::SerializationException){
  int serializedByteSize = 0;
  serializedByteSize += mace::deserialize( is, &eventId );
  serializedByteSize += mace::deserialize( is, &isAsyncEvent );
  return serializedByteSize;
}

void ContextCommitEvent::print(std::ostream& out) const {
  out<< "ContextCommitEvent(";
  out<< "EventID="; mace::printItem(out, &eventId ); out<< ", ";
  out<< "isAsyncEvent="; mace::printItem(out, &isAsyncEvent );
  out<< ")";
}

void ContextCommitEvent::printNode(PrintNode& pr, const std::string& name) const {
  mace::PrintNode printer(name, "ContextCommitEvent" );
  mace::printItem( printer, "Event", &eventId );
  mace::printItem( printer, "isAsyncEvent", &isAsyncEvent );
  pr.addChild( printer );
}

void ContextEvent::serialize(std::string& str) const{
  mace::serialize( str, &sid );
  mace::serialize( str, &eventId );
  mace::serialize( str, &executeTicket);
  mace::serialize( str, &type);
  mace::serialize( str, param);
  mace::serialize( str, &source);
}

int ContextEvent::deserialize(std::istream & is) throw (mace::SerializationException){
  int serializedByteSize = 0;
  serializedByteSize += mace::deserialize( is, &sid );
  serializedByteSize += mace::deserialize( is, &eventId );
  serializedByteSize += mace::deserialize( is, &executeTicket);
  serializedByteSize += mace::deserialize( is, &type);

  switch(type) {
    case TYPE_ASYNC_EVENT: {
      serializedByteSize += deserializeEvent(is);
      break;
    }
    case TYPE_ROUTINE_EVENT: {
      serializedByteSize += deserializeEvent(is);
      break;
    }
    case TYPE_BROADCAST_EVENT: {
      serializedByteSize += deserializeEvent(is);
      break;
    }
    case TYPE_GRAP_EVENT: {
      serializedByteSize += deserializeEvent(is);
      break;
    }
    case TYPE_START_EVENT: {
      serializedByteSize += deserializeEvent(is);
      break;
    }
    case TYPE_COMMIT_CONTEXT: {
      param = InternalMessageHelperPtr( new commit_single_context_Message() );
      serializedByteSize += param->deserialize(is);
      break;
    }
    case TYPE_BROADCAST_COMMIT: {
      param = InternalMessageHelperPtr( new BroadcastControl_Message() );
      serializedByteSize += param->deserialize(is);
      break;
    }
    case TYPE_BROADCAST_COMMIT_CONTEXT: {
      param = InternalMessageHelperPtr( new commit_single_context_Message() );
      serializedByteSize += param->deserialize(is);
      break;
    }
    default:{
      ASSERTMSG(false, "Unkown ContextEvent Type!");
    }
  }

  serializedByteSize += mace::deserialize( is, &source);
  return serializedByteSize;
}

int ContextEvent::deserializeEvent( std::istream& in ){
  BaseMaceService* serviceInstance = BaseMaceService::getInstance( sid );
  mace::Message* ptr;
  int count = serviceInstance->deserializeMethod( in, ptr );
  param = InternalMessageHelperPtr( static_cast< InternalMessageHelperPtr >( ptr ) );
  return count;
}

void ContextEvent::print(std::ostream& out) const {
  out<< "ContextEvent(";
  out<< "EventID="; mace::printItem(out, &eventId ); out <<",";
  out<< "EexecuteTicket="; mace::printItem(out, &executeTicket ); out <<",";
  out<< "Type="; mace::printItem(out, &type ); out <<",";
  out<< "Message="; mace::printItem(out, param ); out <<",";
  out<< "Source="; mace::printItem(out, &source ); 
  out<< ")";
}

void ContextEvent::printNode(PrintNode& pr, const std::string& name) const {
  mace::PrintNode printer(name, "ContextEvent" );
  mace::printItem( printer, "EventID", &eventId );
  mace::printItem( printer, "ExecuteTicket", &executeTicket );
  mace::printItem( printer, "Type", &type );
  mace::printItem( printer, "Message", param );
  mace::printItem( printer, "Source", &source );
  pr.addChild( printer );
}

ContextBaseClass::ContextBaseClass(const mace::string& contextName, const uint64_t createTicketNumber, 
      const uint64_t executeTicketNumber, const uint64_t create_now_committing_ticket, const mace::OrderID& execute_now_committing_eventId, 
      const uint64_t execute_now_committing_ticket, const mace::OrderID& now_serving_eventId, 
      const uint64_t now_serving_execute_ticket, const bool execute_serving_flag, const uint64_t lastWrite, 
      const uint8_t serviceId, const uint32_t contextId, const uint8_t contextType): 
    contextName(contextName),
    contextType( contextType ),
    serviceId( serviceId ),
    contextId( contextId ),
    create_now_committing_ticket( create_now_committing_ticket ),
    execute_now_committing_eventId( execute_now_committing_eventId ),
    execute_now_committing_ticket( execute_now_committing_ticket ),
    now_serving_eventId( now_serving_eventId ),
    now_serving_execute_ticket( now_serving_execute_ticket ),
    execute_serving_flag( execute_serving_flag ),
    lastWrite( lastWrite ),
    createTicketNumber( createTicketNumber ),
    executeTicketNumber( executeTicketNumber ),
    //nextWaitingSubEventsTicket (1),
    //waitingSubEvents( ),
    //waitingDeferredMessages( ),
    //waitingSubEventsFlags( ),
    executedEventsCommitFlag( ),
    now_serving_create_ticket( 1 ),
    createWaitingFlag(false),
    createWaitingThread( ),
    handlingMessageNumber( 0 ),
    isWaitingForHandlingMessages( false ),
    handlingCreateEventNumber( 0 ),
    isWaitingForHandlingCreateEvents( false ),
    now_max_execute_ticket(0),
    eventExecutionInfos( ),
    migrationEventWaiting( false ),
    eventCreateStartTime( ),
    committedEventCount( 0 ),
    totalEventTime( 0 ),
    eventExecuteStartTime( ),
    finishedEventCount( 0 ),
    totalEventExecuteTime( 0 ),
    pkey(),
#ifdef __APPLE__
#else
    keyOnce( PTHREAD_ONCE_INIT ),
#endif
    numReaders(0),
    numWriters(0),
    conditionVariables( ),
    commitConditionVariables( ),
    uncommittedEvents(0,-1)    
{
    contextTypeName = contextName;
    if( now_serving_eventId.ticket > 1 ){
        ADD_SELECTORS("ContextBaseClass::(constructor)");
        macedbg(1)<<"context '"<< contextName << "' id: "<< contextId << " is created at event "<< now_serving_eventId << Log::endl;
    }
#ifdef __APPLE__
	pthread_once_t x = PTHREAD_ONCE_INIT;
	keyOnce = x;
#endif

  pthread_mutex_init( &_context_ticketbooth, NULL );

	pthread_mutex_init( &createEventTicketMutex,  NULL );
  pthread_mutex_init( &executeEventTicketMutex, NULL );
  pthread_mutex_init( &executeEventMutex,  NULL );
  pthread_mutex_init( &createEventMutex,  NULL );
  pthread_mutex_init( &commitEventMutex,  NULL );
	
  pthread_mutex_init( &contextMigratingMutex, NULL);
  pthread_cond_init( &contextMigratingCond, NULL);
  //pthread_cond_init( &waitingEventOpsCond, NULL );

  pthread_mutex_init( &timeMutex, NULL );
  pthread_mutex_init( &executeTimeMutex, NULL );

  pthread_mutex_init( &eventExecutingSyncMutex, NULL );
  pthread_mutex_init( &contextEventOrderMutex, NULL );
}
// FIXME: it will not delete context thread structure in other threads.
ContextBaseClass::~ContextBaseClass(){
  /* delete context specific thread pool */
  /*
  if( contextEventDispatcher != NULL ) {
    delete contextEventDispatcher;
  }
  */
    // delete thread specific memories
  pthread_once( & mace::ContextBaseClass::global_keyOnce, mace::ContextBaseClass::createKeyOncePerThread );
  ThreadSpecificMapType* t = (ThreadSpecificMapType *)pthread_getspecific(global_pkey);
  // FIXME: need to free all memories associated with pkey
  // this only releases the memory specific to this thread
  if( t == 0 ){
    //chuangw: this can happen if init() is never called on this context.
    // that is, this thread has never accessed this context.
  }else{
    ContextThreadSpecific* ctxts = (*t)[this];
    t->erase(this);
    delete ctxts;
  }

  pthread_mutex_destroy( &_context_ticketbooth );
  pthread_mutex_destroy( &createEventTicketMutex );
  pthread_mutex_destroy( &executeEventTicketMutex );
  pthread_mutex_destroy( &executeEventMutex );
  pthread_mutex_destroy( &createEventMutex );
  pthread_mutex_destroy( &commitEventMutex );
  
  pthread_mutex_destroy( &contextMigratingMutex );
  pthread_cond_destroy( &contextMigratingCond );
  
  pthread_mutex_destroy( &timeMutex);
  pthread_mutex_destroy( &executeTimeMutex);
  pthread_mutex_destroy( &eventExecutingSyncMutex );

  pthread_mutex_destroy( &contextEventOrderMutex );

  CommitEventQueueType::iterator iter = executeCommitEventQueue.begin();
  for(; iter != executeCommitEventQueue.end(); iter++) {
    //putBackEventObject(iter->second->event);
  } 
  executeCommitEventQueue.clear();
}

ContextThreadSpecific* ContextBaseClass::init(){
  pthread_once( & mace::ContextBaseClass::global_keyOnce, mace::ContextBaseClass::createKeyOncePerThread );
  ThreadSpecificMapType *t = (ThreadSpecificMapType *)pthread_getspecific(mace::ContextBaseClass::global_pkey);
  if (t == 0) {
    t = new mace::hash_map<ContextBaseClass*, ContextThreadSpecific*, SoftState>();
    assert( t != NULL );
    assert(pthread_setspecific(global_pkey, t) == 0);
  }
  ThreadSpecificMapType::iterator ctIterator = t->find(this);
  if( ctIterator == t->end() ){
      ContextThreadSpecific* ctxts = new ContextThreadSpecific();
      assert( ctxts != NULL );
      t->insert( std::pair< ContextBaseClass*, ContextThreadSpecific* >( this, ctxts ) );
      return ctxts;
  }
  return ctIterator->second;
}
void mace::ContextBaseClass::createKeyOncePerThread(){
    assert(pthread_key_create(&global_pkey, NULL) == 0);
}
void mace::ContextBaseClass::print(std::ostream& out) const {
  out<< "ContextBaseClass(";
  out<< "contextName="; mace::printItem(out, &(contextName) ); out<<", ";
  out<< "contextID="; mace::printItem(out, &(contextId) ); out<<", ";
  out<< "Create Ticket="; mace::printItem(out, &(createTicketNumber) ); out<<", ";
  out<< "Execute Ticket="; mace::printItem(out, &(executeTicketNumber) ); out<<", ";
  out<< "now_serving="; mace::printItem(out, &(now_serving_eventId) ); out<<", ";
  out<< "now_create_committing="; mace::printItem(out, &(create_now_committing_ticket) ); out<<", ";
  out<< "Execute Commit EventID="; mace::printItem(out, &(execute_now_committing_eventId) ); out<<", ";
  out<< "now_execute_committing="; mace::printItem(out, &(execute_now_committing_ticket) ); out<<", ";
  //out<< "lastWrite="; mace::printItem(out, &(lastWrite) ); out<<", ";
  out<< "numReaders="; mace::printItem(out, &(numReaders) ); out<<", ";
  out<< "numWriters="; mace::printItem(out, &(numWriters) ); out<<", ";
  out<< "uncommittedEvents="; mace::printItem(out, &(uncommittedEvents) );
  out<< ")";

} // print

void mace::ContextBaseClass::printNode(PrintNode& pr, const std::string& name) const {
  mace::PrintNode printer(name, "ContextBaseClass" );
  
  mace::printItem( printer, "contextName", &contextName );
  mace::printItem( printer, "contextID", &contextId );
  mace::printItem( printer, "Create Ticket", &createTicketNumber );
  mace::printItem( printer, "Execute Ticket", &executeTicketNumber );
  mace::printItem( printer, "now_serving", &now_serving_eventId );
  mace::printItem( printer, "now_create_committing", &create_now_committing_ticket );
  mace::printItem( printer, "Execute Commit EventID", &execute_now_committing_eventId );
  mace::printItem( printer, "now_execute_committing", &execute_now_committing_ticket );
  //mace::printItem( printer, "lastWrite", &lastWrite );
  mace::printItem( printer, "numReaders", &numReaders );
  mace::printItem( printer, "numWriters", &numWriters );
  mace::printItem( printer, "uncommittedEvents", &uncommittedEvents );
  pr.addChild( printer );
}

pthread_once_t mace::ContextBaseClass::global_keyOnce= PTHREAD_ONCE_INIT ;
pthread_key_t mace::ContextBaseClass::global_pkey;
pthread_mutex_t mace::ContextBaseClass::eventCommitMutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mace::ContextBaseClass::eventSnapshotMutex = PTHREAD_MUTEX_INITIALIZER;
std::map< mace::OrderID, pthread_cond_t* > mace::ContextBaseClass::eventCommitConds;
std::map< mace::OrderID, pthread_cond_t* > mace::ContextBaseClass::eventSnapshotConds;
mace::snapshotStorageType mace::ContextBaseClass::eventSnapshotStorage;


void mace::ContextBaseClass::enqueueEvent(BaseMaceService* sv, AsyncEvent_Message* const msg) {
    ADD_SELECTORS("ContextBaseClass::enqueueEvent#1");
    mace::Event& event = msg->getEvent();
    int8_t eventType = event.eventType;
    macedbg(1) << "Enqueue an async event("<< event.eventId <<") to " << this->contextName << Log::endl;

    uint8_t ctxEventType = ContextEvent::TYPE_NULL;
    if(eventType == mace::Event::ASYNCEVENT) {
      ctxEventType = ContextEvent::TYPE_ASYNC_EVENT;
    } else if (eventType == mace::Event::BROADCASTEVENT) {
      ctxEventType = ContextEvent::TYPE_BROADCAST_EVENT;
    } 

    if (ctxEventType == ContextEvent::TYPE_NULL) {
      ASSERTMSG(false, "Invalid async event type!");
    }
	
    OrderID const& eventId = event.eventId;
    __EventStorageStruct__ eventStorage(msg, ctxEventType, mace::InternalMessage::ASYNC_EVENT, serviceId, event.eventOpInfo);

    ScopedLock sl(this->executeEventMutex);

    waitingEvents[eventId].push_back(eventStorage);
    eventStorage.msg = NULL;
    sl.unlock();

    ScopedLock order_sl(this->contextEventOrderMutex);
    mace::set<mace::string> p_ctx_names;
    if( this->checkEventExecutePermission(sv, this->contextName, event.eventOpInfo, true, p_ctx_names) ){
      macedbg(1) << "Event("<< eventId <<") could execute directly in " << this->contextName << Log::endl;
      sl.lock();
      this->enqueueContextEvent(sv, eventId);
    }
}


// For local transition. At this moment, it should obtain its execute ticket and wait for execution
bool mace::ContextBaseClass::enqueueEvent(const BaseMaceService* sv, mace::Event& event) {
    ADD_SELECTORS("ContextBaseClass::enqueueEvent#2");
    macedbg(1) << "Enter!" << Log::endl;
    int8_t eventType = event.eventType;
    uint8_t ctxEventType = ContextEvent::TYPE_NULL;
    if(eventType == mace::Event::STARTEVENT) {
      ctxEventType = ContextEvent::TYPE_FIRST_EVENT;
    } else if(eventType == mace::Event::ENDEVENT) {
      ctxEventType = ContextEvent::TYPE_LAST_EVENT;
    }

    ASSERT( ctxEventType != ContextEvent::TYPE_NULL );
  
    BaseMaceService* nc_sv = const_cast<BaseMaceService*>(sv);
    mace::set<mace::string> p_ctx_names;
    ASSERTMSG( checkEventExecutePermission(nc_sv, this->contextName, event.eventOpInfo, false, p_ctx_names), "The first event shouldn't wait for any previous event!");
    ScopedLock sl(this->executeEventMutex);
    this->enqueueContextEvent(sv, event);
    //macedbg(1) << "Done!" << Log::endl;
    return true;
}

void mace::ContextBaseClass::enqueueRoutine(BaseMaceService* sv, Routine_Message* const msg, mace::MaceAddr const& source ) {
    ADD_SELECTORS("ContextBaseClass::enqueueRoutine");
    mace::Event & event = msg->getEvent();
    
    macedbg(1) << "Enqueue an Routine Event("<< event.eventId <<") to " << this->contextName << Log::endl;
    ASSERT( this->contextName == event.eventOpInfo.toContextName );

    uint8_t ctxEventType = ContextEvent::TYPE_ROUTINE_EVENT;
      
    OrderID const& eventId = event.eventId;
    __EventStorageStruct__ eventStorage( msg, ctxEventType, mace::InternalMessage::ROUTINE, serviceId, event.eventOpInfo );

    ScopedLock sl(this->executeEventMutex);
    waitingEvents[eventId].push_back(eventStorage);
    eventStorage.msg = NULL;
    sl.unlock();

    ScopedLock order_sl(this->contextEventOrderMutex);
    mace::set<mace::string> p_ctx_names;
    if( checkEventExecutePermission(sv, this->contextName, event.eventOpInfo, true, p_ctx_names) ){
      macedbg(1) << "Routine Event("<< event.eventId <<") could directly execute in " << this->contextName << Log::endl;
      sl.lock();
      this->enqueueContextEvent(sv, eventId);
    }
}

void mace::ContextBaseClass::commitContext(BaseMaceService* sv, OrderID const& eventId) {
    ADD_SELECTORS("ContextBaseClass::commitContext#2");
    ScopedLock sl(executeEventMutex);
    

    ContextService* _service = static_cast<ContextService*>(sv);
    //ContextStructure const& cs = _service->contextStructure;
    uint64_t executeTicket = contextEventOrder.getExecuteEventTicket(eventId);

    ASSERT( executeTicket > 0);
    macedbg(1) << "Event(" << eventId << ") is holding context " << contextName <<" executeTicket="<< executeTicket <<" now_serving_execute_ticket=" << now_serving_execute_ticket << Log::endl;
      
    //this->executedEvent(sv, eventId);
    ASSERT( executeTicket == this->now_serving_execute_ticket );
    
    _service->__beginCommitContext(this->contextId);
    _service->__finishCommitContext(this);
}

void mace::ContextBaseClass::initialize(const mace::string& contextName, const OrderID& now_serving_eventId, const uint8_t serviceId, 
      const uint32_t contextId, const ContextEventOrder& contextEventOrder, const uint64_t create_now_committing_ticket, const OrderID& execute_now_committing_eventId,
      const uint64_t execute_now_committing_ticket ){
  ADD_SELECTORS("ContextBaseClass::initialize");
  //macedbg(1) << "Change contextName to " << contextName << Log::endl;

  this->contextName = contextName;
  this->now_serving_eventId = now_serving_eventId;
  this->contextEventOrder = contextEventOrder;
  this->create_now_committing_ticket = create_now_committing_ticket;
  this->execute_now_committing_eventId = execute_now_committing_eventId;
  this->execute_now_committing_ticket = execute_now_committing_ticket;
  this->serviceId = serviceId;
  this->contextId = contextId;
  
  this->contextEventOrder.setContextName(contextName);
}

void mace::ContextBaseClass::initialize2(const mace::string& contextName, const uint8_t serviceId, const uint32_t contextId, 
      const uint64_t create_now_committing_ticket, const uint64_t execute_now_committing_ticket, 
      mace::vector<mace::string> const& dominateContexts ){
  ADD_SELECTORS("ContextBaseClass::initialize2");
  //macedbg(1) << "Change contextName to " << contextName << Log::endl;

  this->contextName = contextName;
  this->create_now_committing_ticket = create_now_committing_ticket;
  this->execute_now_committing_ticket = execute_now_committing_ticket;
  this->serviceId = serviceId;
  this->contextId = contextId;
  
  this->contextEventOrder.setContextName(contextName);
  this->dominator.initialize(contextName, dominateContexts);
}

void mace::ContextBaseClass::lock(  ){
  mace::ContextLock cl( *this, ThreadStructure::myEventID(), false, mace::ContextLock::WRITE_MODE );
}
void mace::ContextBaseClass::downgrade( int8_t requestedMode ){
  mace::ContextLock cl( *this, ThreadStructure::myEventID(), false, requestedMode );
}

void mace::ContextBaseClass::unlock(  ){
  mace::ContextLock cl( *this, ThreadStructure::myEventID(), false, mace::ContextLock::NONE_MODE );
}
void mace::ContextBaseClass::nullTicket(){
  mace::ContextLock cl( *this, ThreadStructure::myEventID(), false, mace::ContextLock::NONE_MODE );
}

void mace::ContextBaseClass::enqueueCommitEventQueue(BaseMaceService* sv, const mace::OrderID& eventId, bool isAsyncEvent) {
  ADD_SELECTORS("ContextBaseClass::enqueueCommitEventQueue");
  //this->notifyWaitingContexts(eventId);
  ScopedLock sl(commitEventMutex);
  ContextCommitEvent* commitEvent = new ContextCommitEvent(sv, eventId, this, isAsyncEvent);
  uint64_t executeTicket = contextEventOrder.getExecuteEventTicket(eventId);
  ASSERTMSG( executeTicket > 0, "enqueueCommitEventQueue" );
  executeCommitEventQueue[executeTicket] = commitEvent;
  if( executeTicket > execute_now_committing_ticket ){
    macedbg(1) << "Put event(" << eventId << ") into Context("<< contextName <<") execute commit queue. executeTicket=" << executeTicket <<" execute_now_committing_ticket="<< execute_now_committing_ticket <<"("<< contextEventOrder.getExecuteEventOrderID(execute_now_committing_ticket) <<")" << Log::endl;
  }
  sl.unlock();
  enqueueReadyCommitEventQueue();
}

void mace::ContextBaseClass::enqueueCreateEvent(AsyncEventReceiver* sv, HeadEventDispatch::eventfunc func, mace::Message* p, bool useTicket) {
  ADD_SELECTORS("ContextBaseClass::enqueueCreateEvent");
    
  OrderID myEventId;
    
  if( useTicket ){
    myEventId = newCreateTicket();
  }else{
    myEventId = ThreadStructure::myEventID();
  }
  HeadEventDispatch::HeadEvent thisev (sv, func, p, myEventId, this->contextName);
  ScopedLock sl(createEventMutex);
  createEventQueue.push(thisev);
  enqueueReadyCreateEventQueue();

  thisev.param = NULL;
}  

OrderID mace::ContextBaseClass::newCreateTicket() {
  ADD_SELECTORS("ContextBaseClass::newCreateTicket");

  ScopedLock sl(this->createEventTicketMutex);
  OrderID eventId(this->contextId, this->createTicketNumber);
  macedbg(1) << "Context "<< this->contextId <<" sold create ticket "<< this->createTicketNumber << Log::endl;
  this->createTicketNumber ++;
  return eventId;
}

void mace::ContextBaseClass::tryCreateWakeup() {
  ADD_SELECTORS("ContextBaseClass::tryCreateWakeup");
  //contextEventDispatcher->signalCreateThread();
}

/*
mace::map<mace::string, PreEventInfo> mace::ContextBaseClass::getPreCreateEventInfos(const mace::vector<mace::string>& access_contexts) {
  return contextEventOrder.getPreCreateEventInfos(access_contexts); 
}
*/

void mace::ContextBaseClass::enqueueContextEvent(BaseMaceService* sv, const OrderID& eventId ) {
  ADD_SELECTORS("ContextBaseClass::enqueueContextEvent");
  
  EventStorageType::iterator a_iter = waitingEvents.find(eventId);
  if( a_iter == waitingEvents.end() ) {
    macedbg(1) << "Something wrong! Fail to find event(" << eventId << ")!" << Log::endl;
    //ASSERT(false);
    return;
  }

  mace::vector<__EventStorageStruct__>& eventStorages = a_iter->second;

  mace::vector<__EventStorageStruct__> restEventStorage;
  for(mace::vector<__EventStorageStruct__>::iterator sIter = eventStorages.begin(); sIter != eventStorages.end(); sIter++ ){
    __EventStorageStruct__& eventStorage = *sIter;

    if( eventStorage.eventOpInfo.toContextName != contextName ) {
      restEventStorage.push_back(eventStorage);
      eventStorage.msg = NULL;
      continue;
    }
    if( eventStorage.contextEventType == ContextEvent::TYPE_ASYNC_EVENT ) {
      macedbg(1) << "Event("<< eventId <<") is an async event for "<< contextName << Log::endl;
      AsyncEvent_Message* msg = static_cast<AsyncEvent_Message*>(eventStorage.msg);
      mace::Event& event = msg->getEvent();
            
      ContextEvent ce(event.eventId, sv, eventStorage.contextEventType, eventStorage.msg, serviceId, this);
      enqueueExecuteContextEvent(sv, ce); 
      ce.param = NULL;
    } else if( eventStorage.contextEventType == ContextEvent::TYPE_BROADCAST_EVENT){
      macedbg(1) << "Event("<< eventId <<") is a broadcast event for "<< contextName << Log::endl;
      AsyncEvent_Message* msg = static_cast<AsyncEvent_Message*>(eventStorage.msg);
      mace::Event& event = msg->getEvent();
      uint64_t executeTicket = contextEventOrder.getExecuteEventTicket(event.eventId);
      if( executeTicket != 0 ) {
        ASSERTMSG( executeTicket <= this->now_serving_execute_ticket, "This event must still hold the context!");
        ContextEvent ce(event.eventId, sv, eventStorage.contextEventType, eventStorage.msg, serviceId, this);
        enqueueExecuteContextEventToHead(sv, ce);
        ce.param = NULL;
      } else {
        ContextEvent ce(event.eventId, sv, eventStorage.contextEventType, eventStorage.msg, serviceId, this);
        enqueueExecuteContextEvent(sv, ce);
        ce.param = NULL;
      }
    } else if( eventStorage.contextEventType == ContextEvent::TYPE_ROUTINE_EVENT ){
      Routine_Message* msg = static_cast<Routine_Message*>(eventStorage.msg);
      mace::Event& event = msg->getEvent();
      uint64_t executeTicket = contextEventOrder.getExecuteEventTicket(event.eventId);
      if( executeTicket != 0 ) {
        //macedbg(1) << "Broadcast Event("<< event.eventId <<")'s execute ticket in Context("<< contextName <<") is " << executeTicket << Log::endl;
        ASSERTMSG( executeTicket <= now_serving_execute_ticket, "This event must still hold the context!");
        ContextEvent ce(event.eventId, sv, eventStorage.contextEventType, eventStorage.msg, serviceId, this);
        enqueueExecuteContextEventToHead(sv, ce);
        ce.param = NULL;
      } else {
        ContextEvent ce(event.eventId, sv, eventStorage.contextEventType, eventStorage.msg, serviceId, this);
        enqueueExecuteContextEvent(sv, ce);
        ce.param = NULL;
      }
    }
  
    eventStorage.msg = NULL;
  }
  waitingEvents.erase(a_iter);

  if( restEventStorage.size() > 0 ){
    waitingEvents[eventId] = restEventStorage;
  }
}


void mace::ContextBaseClass::enqueueContextEvent( const BaseMaceService* sv, mace::Event& event ) {
  ADD_SELECTORS("ContextBaseClass::enqueueContextEvent#2");
  contextEventOrder.addExecuteEvent(event.eventId);
  /*
  const ContextService* _service = static_cast<const ContextService*>(sv);
  ContextStructure& contextStructure = _service->contextStructure;
  ScopedLock sl(executeEventMutex);
  if( contextStructure.isUpperBoundContext(this->contextName) ) {
    mace::set<mace::string> access_ctxs = contextStructure.getOrderingDecendantContexts(this->contextName);
    mace::map<mace::string, mace::set<PreEventInfo> > preEventInfos = contextEventOrder.addOrderingAccessContext(event.eventId, event.isReadOnly, 
      event.target_ctx_name, access_ctxs, true);
    event.addPreEventInfos(this->serviceId, preEventInfos);
    contextEventOrder.addExecuteEvent(event.eventId);
  }
  */
}

void mace::ContextBaseClass::forwardWaitingBroadcastRequset(BaseMaceService* sv, const EventOperationInfo& eventOpInfo ) {
  ADD_SELECTORS("ContextBaseClass::forwardWaitingBroadcastRequset");
  
  const mace::OrderID& eventId = eventOpInfo.eventId;
  EventStorageType::iterator a_iter = waitingEvents.find(eventId);
  if( a_iter == waitingEvents.end() ) {
    maceerr << "Something wrong! Fail to find event(" << eventOpInfo << ")'s broadcast event!" << Log::endl;
    ASSERT(false);
  }

  ContextService* _service = static_cast<ContextService*>(sv);
  mace::vector<__EventStorageStruct__>& eventStorages = a_iter->second;

  mace::vector<__EventStorageStruct__> restEventStorage;
  for(mace::vector<__EventStorageStruct__>::iterator sIter = eventStorages.begin(); sIter != eventStorages.end(); sIter++ ){
    __EventStorageStruct__& eventStorage = *sIter;

    if( eventStorage.eventOpInfo == eventOpInfo ) {
      _service->broadcastHead(eventStorage.msg);
      eventStorage.msg = NULL;
      eventStorages.erase(sIter);
      break;
    }
  }
  if( eventStorages.size() == 0 ){
    waitingEvents.erase(a_iter);
  }
}

bool mace::ContextBaseClass::checkBroadcastRequestExecutePermission( BaseMaceService* sv, const mace::EventOperationInfo& eventOpInfo, mace::AsyncEvent_Message* reqObj) {
  ADD_SELECTORS("ContextBaseClass::checkBroadcastRequestExecutePermission");
  ContextService* _service = static_cast<ContextService*>(sv);
  ContextStructure& contextStructure = _service->contextStructure;
  const mace::string dominator = contextStructure.getUpperBoundContextName( this->contextName );
  
  ScopedLock order_sl(this->contextEventOrderMutex);
  mace::set<mace::string> p_ctx_names;
  if( this->checkEventExecutePermission(sv, this->contextName, eventOpInfo, true, p_ctx_names) ){
    macedbg(1) << "In context("<< this->contextName <<"): " << eventOpInfo << " could be forwarded directly!" << Log::endl;
    return true;
  } 
  ScopedLock sl(this->executeEventMutex);
  macedbg(1) << "In dominator("<< this->contextName <<"): " << eventOpInfo << " should be enqueue until getting the permission!" << Log::endl;
  uint8_t ctxEventType = ContextEvent::TYPE_BROADCAST_EVENT;
  OrderID const& eventId = eventOpInfo.eventId;
  __EventStorageStruct__ eventStorage(reqObj, ctxEventType, mace::InternalMessage::ASYNC_EVENT, this->serviceId, eventOpInfo);
 
  waitingEvents[eventId].push_back(eventStorage);
  eventStorage.msg = NULL;
  return false;
}

void mace::ContextBaseClass::handleWaitingDominatorRequests(BaseMaceService* sv, mace::vector<DominatorRequest> const& dominatorRequests) {
  ADD_SELECTORS("ContextBaseClass::handleWaitingDominatorRequests");

  ContextService* _service = static_cast<ContextService*>(sv);
  for( uint32_t i=0; i<dominatorRequests.size(); i++ ){
    const DominatorRequest& request = dominatorRequests[i];
    if( request.lockType == mace::DominatorRequest::CHECK_PERMISSION ){
      mace::set<mace::string> p_ctx_names;
      if( this->checkEventExecutePermission(sv, request.ctxName, request.eventOpInfo, false, p_ctx_names ) ){
        mace::vector<mace::EventOperationInfo> eventOpInfos;
        mace::vector<mace::string> contextNames;

        eventOpInfos.push_back(request.eventOpInfo);
        for( mace::set<mace::string>::iterator iter = p_ctx_names.begin(); iter != p_ctx_names.end(); iter++ ){
          contextNames.push_back(*iter);
        }
        _service->send__event_replyEventExecutePermission( request.ctxName, this->contextName, request.eventOpInfo.eventId, 
          contextNames, eventOpInfos );
      }
    } else if( request.lockType == mace::DominatorRequest::UNLOCK_CONTEXT ) {
      this->unlockContext(sv, request.eventOpInfo, request.ctxName, request.toContextNames );
    } else if( request.lockType == mace::DominatorRequest::RELEASE_CONTEXT ){
      this->releaseContext(sv, request.eventId, request.ctxName, request.toContextNames );
    } else {
      ASSERT(false);
    }
  }
}

void ContextBaseClass::createEvent(BaseMaceService* sv, mace::OrderID& myEventId, mace::Event& event, const mace::string& targetContextName, const int8_t eventType) {
  ADD_SELECTORS("ContextBaseClass::createEvent");
  //macedbg(1) << "Context("<< contextName <<") creates event which target context " << targetContextName << Log::endl;
  //OrderID myEventId = newCreateTicket();

  ScopedLock sl(createEventMutex);
  macedbg(1) << "now_serving_create_ticket=" << now_serving_create_ticket << " create_ticket=" << myEventId.ticket << Log::endl;
  if( myEventId.ticket != now_serving_create_ticket ) {
    pthread_cond_t cond;
    pthread_cond_init( &cond, NULL );
    createWaitingThread[ myEventId.ticket ] = &cond;
    createWaitingFlag = true;
    pthread_cond_wait( &cond, &createEventMutex );

    createWaitingThread[ myEventId.ticket ] = NULL;
    createWaitingThread.erase(myEventId.ticket);
    pthread_cond_destroy( &cond );

    if( createWaitingThread.size() == 0 ) {
      createWaitingFlag = false;
    }
  }

  ASSERTMSG( myEventId.ticket == now_serving_create_ticket, "ContextBaseClass::createEvent");
  //macedbg(1) << "Now create event for ticket " << myEventId << Log::endl;
  sl.unlock();
  
  uint64_t ver = this->getContextMappingVersion();
  uint64_t cver = this->getContextStructureVersion();
  //if( !isTestFlag ) {
  event.initialize2(myEventId, false, this->contextName, targetContextName, eventType, ver, cver);
  
  //}
  event.addServiceID(serviceId);
  mace::EventOperationInfo opInfo(myEventId, mace::EventOperationInfo::ASYNC_OP, targetContextName, targetContextName, 1, event.isReadOnly);
  event.eventOpInfo = opInfo;
  //macedbg(1) << "EventId = " << myEventId <<" targetContext=" << targetContextName << " startContext=" << start_ctx_name << " accessContexts="<< accessCtxs<<" preEventIds=" << preCreateEventIds << Log::endl;
  
  sl.lock();
  now_serving_create_ticket ++;
  macedbg(1) << "Increasing Context("<< contextName<<")'s now_serving_create_ticket to be " << now_serving_create_ticket << Log::endl;
  enqueueReadyCreateEventQueue();
  sl.unlock();
  signalCreateThread();
}

bool ContextBaseClass::waitingForExecution(const BaseMaceService* sv, mace::Event& event) {
  ADD_SELECTORS("ContextBaseClass::waitingForExecution");
  macedbg(1) << "Enter ContextBaseClass::waitingForExecution!" << Log::endl;
  bool execute_flag = enqueueEvent(sv, event);
  return execute_flag;
}

void ContextBaseClass::commitEvent(const mace::OrderID& eventId) {
  ADD_SELECTORS("ContextBaseClass::commitEvent");
  ScopedLock sl_commit(_context_ticketbooth);
  if( readerEvents.count(eventId) > 0 || writerEvents.count(eventId) > 0 ){
    maceerr << "Event("<< eventId <<") still hold the lock on " << this->contextName << Log::endl;
    ASSERT(false);
  }
  sl_commit.unlock();

  ScopedLock sl(commitEventMutex);
  
  const uint64_t execute_ticket = contextEventOrder.getExecuteEventTicket( eventId );
  if( execute_ticket == 0 ){
    maceerr << "Event("<< eventId <<") is not found in Context("<< this->contextName <<")!" << Log::endl;
    return;
  }

  macedbg(1) << "To commit event("<< eventId <<") in " << this->contextName << Log::endl;
 
  markExecuteEventCommitted(eventId);
  contextEventOrder.removeEventExecuteTicket(eventId);
  // committedEventIds.push_back(eventId);
  sl.unlock();
  
  this->deleteEventExecutionInfo(eventId);
}

void ContextBaseClass::putBackEventObject(mace::Event* event) {
  //eventObjectPool.put(event);
  delete event;
}

void ContextBaseClass::enqueueSubEvents(mace::OrderID const& eventId) {
  ADD_SELECTORS("ContextBaseClass::enqueueSubEvents");
  mace::vector<mace::EventRequestWrapper> subevents = getSubEvents(eventId);
  if( !subevents.empty() ) {
    AsyncEventReceiver* sv = BaseMaceService::getInstance(this->serviceId);
    for( uint32_t i=0; i<subevents.size(); i++ ) {
      this->enqueueCreateEvent(sv, (HeadEventDispatch::eventfunc)&BaseMaceService::createEvent, subevents[i].request, true ); 
    }
    macedbg(1) << "Enqueue Event(" << eventId <<")'s subevents("<< subevents.size() <<") into waiting queue!" << Log::endl;
  } else {
    macedbg(1) << "Event(" << eventId <<") has no subevents!" << Log::endl;
  }
}


void ContextBaseClass::enqueueDeferredMessages( mace::OrderID const& eventId ) {
  ADD_SELECTORS("ContextBaseClass::enqueueDeferredMessages");
  mace::vector<mace::EventMessageRecord> messages = getExternalMessages(eventId);
  
  if( !messages.empty() ){
    ThreadStructure::ScopedContextID sc( ContextMapping::getHeadContextID() );
    for( mace::vector<mace::EventMessageRecord>::const_iterator msgIt = messages.begin(); msgIt != messages.end(); msgIt++ ){
      BaseMaceService* serviceInstance = BaseMaceService::getInstance( msgIt->sid );
      macedbg(1) << "In context("<< this->contextName <<"): Dispatch a message!" << Log::endl;
      serviceInstance->dispatchDeferredMessages( msgIt->dest, msgIt->message, msgIt->rid );
    }
    //macedbg(1) << "Dispatch event(" << eventId <<")'s messages("<< messages.size() <<")!" << Log::endl;
  } else {
    //macedbg(1) << "Event(" << eventId <<") has no messages!" << Log::endl;
  }
}

void ContextBaseClass::markExecuteEventCommitted(const mace::OrderID& eventId) {
  ADD_SELECTORS("ContextBaseClass::markExecuteEventCommitted");
  macedbg(1) << "Mark event("<< eventId <<") as committed in " << this->contextName;
  uint64_t executeTicket = getExecuteEventTicket(eventId);
  ASSERT( executeTicket != 0 );
  executedEventsCommitFlag[executeTicket] = true;
  macedbg(1) << "Mark event(" << eventId <<") in context "<< contextName <<" as committed. executeTicket="<< executeTicket<< " execute_now_committing_ticket=" 
    << execute_now_committing_ticket <<" executedEventsCommitFlag="<< executedEventsCommitFlag << Log::endl;
  while(true) {
    mace::map< uint64_t, bool >::iterator iter = executedEventsCommitFlag.find(execute_now_committing_ticket);
    if( iter == executedEventsCommitFlag.end() || !iter->second ) {
      break;
    } else {
      execute_now_committing_ticket ++;
      macedbg(1) << "Context("<< contextName <<") increases execute_now_committing_ticket to " << execute_now_committing_ticket << Log::endl;
      executedEventsCommitFlag.erase(iter);
    }
  }

  
  if( migrationEventWaiting ) {
    ContextLock::notifyMigrationEvent(*this);
  }
}

void ContextBaseClass::sendCommitDoneMsg(const mace::Event& event) {
  AsyncEventReceiver* sv = BaseMaceService::getInstance(this->serviceId);
  ContextService* _service = static_cast<ContextService*>(sv);

  _service->send__event_CommitDoneMsg(event.create_ctx_name, event.target_ctx_name, event.eventId);
}

void ContextBaseClass::signalCreateThread() {
  ADD_SELECTORS("ContextBaseClass::signalCreateThread");
  ScopedLock sl(createEventMutex);
  if( createWaitingFlag ) {
    std::map<uint64_t, pthread_cond_t*>::iterator iter = createWaitingThread.find(now_serving_create_ticket);
    if( iter != createWaitingThread.end() ) {
      pthread_cond_signal(iter->second);
      macedbg(1) << "Context("<< contextName <<") signals waiting create ticket " << now_serving_create_ticket << Log::endl;
    }
  }
}

uint64_t ContextBaseClass::getContextMappingVersion() const {
  BaseMaceService* sv = BaseMaceService::getInstance(this->serviceId);
  ContextService* _service = static_cast<ContextService*>(sv);

  uint64_t ver = _service->getContextMapping().getCurrentVersion();
  return ver; 
}

uint64_t ContextBaseClass::getContextStructureVersion() const {
  BaseMaceService* sv = BaseMaceService::getInstance(this->serviceId);
  ContextService* _service = static_cast<ContextService*>(sv);

  uint64_t ver = _service->contextStructure.getCurrentVersion();
  return ver; 
}

uint64_t ContextBaseClass::requireExecuteTicket( mace::OrderID const& eventId) {
  uint64_t executeTicket = contextEventOrder.addExecuteEvent(eventId);
  return executeTicket; 
}

void ContextBaseClass::waitForEventExecutePermission(BaseMaceService *sv, mace::EventOperationInfo const& eventOpInfo) {
  ADD_SELECTORS("ContextBaseClass::waitForEventExecutePermission");
  macedbg(1) << "Check event("<< eventOpInfo.eventId <<") permit to access context("<< eventOpInfo.toContextName <<") from context("<< eventOpInfo.fromContextName <<")!" << Log::endl;
    
  ScopedLock order_sl(this->contextEventOrderMutex);
  mace::set<mace::string> p_ctx_names;
  if( this->checkEventExecutePermission(sv, this->contextName, eventOpInfo, true, p_ctx_names ) ) {
    macedbg(1) << "Event("<< eventOpInfo.eventId <<") could access context("<< eventOpInfo.toContextName <<") from context("<< eventOpInfo.fromContextName <<")!" << Log::endl;
    return;
  }

  ScopedLock sl(eventExecutingSyncMutex);

  order_sl.unlock();

  pthread_cond_t cond;
  pthread_cond_init( &cond, NULL );
  eventExecutingSyncConds[eventOpInfo] = &cond;
  pthread_cond_wait( &cond, &eventExecutingSyncMutex );
  eventExecutingSyncConds[eventOpInfo] = NULL;
  eventExecutingSyncConds.erase(eventOpInfo);
  pthread_cond_destroy(&cond);

}

void ContextBaseClass::prepareHalt() {
  ADD_SELECTORS("ContextBaseClass::prepareHalt");
  this->waitingForMessagesDone();
  macedbg(1) << "After waitingForMessagesDone!!" << Log::endl;
  this->waitingForCreateEventsDone();
}

void ContextBaseClass::resumeExecution() {
  ADD_SELECTORS("ContextBaseClass::resumeExecution");
  macedbg(1) << "context("<< this->contextName <<") executeEventQueue=" << executeEventQueue.size() << " createEventQueue=" << createEventQueue.size() << Log::endl;

  enqueueReadyExecuteEventQueueWithLock();
  enqueueReadyCreateEventQueueWithLock();
}

void ContextBaseClass::resumeParams( BaseMaceService* sv, const ContextBaseClassParams* params ) {
  ADD_SELECTORS("ContextBaseClass::resumeParams");
  macedbg(1) << "context=" << params->contextName << Log::endl;

  this->contextName = params->contextName; ///< The canonical name of the context
  this->contextTypeName = params->contextTypeName;
  this->serviceId = params->serviceId; ///< The service in which the context belongs to
  this->contextId = params->contextId;

  ContextBaseClassParams* nonContextParams = const_cast<ContextBaseClassParams*>(params);
  mace::vector< mace::__CreateEventStorage__>::iterator createIter = nonContextParams->createEventQueue.begin();
  for(; createIter != nonContextParams->createEventQueue.end(); createIter++ ) {
    mace::__CreateEventStorage__& mcreateEvent = *createIter;
    HeadEventDispatch::HeadEvent thisev (sv, (HeadEventDispatch::eventfunc)&BaseMaceService::createEvent, mcreateEvent.msg, mcreateEvent.eventId, this->contextName);
    this->createEventQueue.push(thisev);
    mcreateEvent.msg = NULL;
    thisev.param = NULL;
  }
  macedbg(1) << "createEventQueue size=" << createEventQueue.size() << Log::endl;
  
  mace::ContextBaseClass::EventStorageType::iterator wIter = nonContextParams->waitingEvents.begin();
  for(; wIter != nonContextParams->waitingEvents.end(); wIter++ ) {
    mace::vector<mace::__EventStorageStruct__>& wevents = wIter->second;
    for( uint32_t i=0; i<wevents.size(); i++ ){
      mace::__EventStorageStruct__& we = wevents[i];
      this->waitingEvents[ wIter->first ].push_back(we);
      we.msg = NULL;
    }
  }
  macedbg(1) << "waitingEvents size="<< this->waitingEvents.size() << Log::endl;
  
  mace::map<uint64_t, mace::Event>::const_iterator iter = params->executeCommitEventQueue.begin();
  for(; iter != params->executeCommitEventQueue.end(); iter++) {
    Event* event = getEventObject();
    *event = iter->second;
    ContextCommitEvent* commitEvent = new ContextCommitEvent(sv, event->eventId, this, true);
    this->executeCommitEventQueue[iter->first] = commitEvent;
  }
  
  macedbg(1) << "executeCommitEventQueue size=" << this->executeCommitEventQueue.size() << Log::endl;
    
  macedbg(1) << "ContextBaseClassParams: executeEventQueue=" << nonContextParams->executeEventQueue.size() << Log::endl;
  while( !nonContextParams->executeEventQueue.empty() ) {
    ContextEvent& e = nonContextParams->executeEventQueue.front();
    ContextEvent ce(e.eventId, sv, e.type, e.param, e.source, e.sid, this);
    this->executeEventQueue.push_back(ce);
    e.param = NULL;
    nonContextParams->executeEventQueue.pop_front();
    ce.param = NULL;
  }
  macedbg(1) << "ContextBaseClass: executeEventQueue=" << this->executeEventQueue.size() << Log::endl;
    
  this->create_now_committing_ticket = params->create_now_committing_ticket;
  this->execute_now_committing_eventId = params->execute_now_committing_eventId;
  this->execute_now_committing_ticket = params->execute_now_committing_ticket;

  this->now_serving_eventId = params->now_serving_eventId;
  this->now_serving_execute_ticket = params->now_serving_execute_ticket;
  
  this->lastWrite = params->lastWrite;

  this->contextEventOrder = params->contextEventOrder;
  this->dominator = params->dominator;

  this->createTicketNumber = params->createTicketNumber;
  this->executeTicketNumber = params->executeTicketNumber;

  this->executedEventsCommitFlag = params->executedEventsCommitFlag;
  this->now_serving_create_ticket = params->now_serving_create_ticket;
  this->now_max_execute_ticket = params->now_max_execute_ticket;
  
  this->eventExecutionInfos = params->eventExecutionInfos; 
  this->readerEvents = params->readerEvents;
  this->writerEvents = params->writerEvents;
  this->migrationEventWaiting = params->migrationEventWaiting;

  this->numWriters = this->writerEvents.size();
  this->numReaders = this->readerEvents.size();

  macedbg(1) << "numReaders=" << this->readerEvents.size() << " numWriters=" << this->writerEvents << Log::endl; 
}

void mace::ContextBaseClass::increaseHandlingMessageNumber() {
  ADD_SELECTORS("ContextBaseClass::increaseHandlingMessageNumber");
  ScopedLock sl(contextMigratingMutex);
  handlingMessageNumber ++;
  macedbg(1) << "Increasing context("<< this->contextName <<")'s handlingMessageNumber to " << handlingMessageNumber << Log::endl;
}

void mace::ContextBaseClass::decreaseHandlingMessageNumber() {
  ADD_SELECTORS("ContextBaseClass::decreaseHandlingMessageNumber");
  ScopedLock sl(contextMigratingMutex);
  handlingMessageNumber --;

  if( isWaitingForHandlingMessages ){
    macedbg(1) << "decreasing context("<< this->contextName <<")'s handlingMessageNumber to " << handlingMessageNumber << Log::endl;
  }
  if( isWaitingForHandlingMessages && handlingMessageNumber == 0) {
    macedbg(1) << "context("<< this->contextName <<") release waiting migration event!" << Log::endl;
    pthread_cond_signal(&contextMigratingCond);
  }
}

void mace::ContextBaseClass::waitingForMessagesDone() {
  ADD_SELECTORS("ContextBaseClass::waitingForMessagesDone");
  ScopedLock sl(contextMigratingMutex);
  macedbg(1) << "Current handling messages for Context("<< contextName<<") is " << handlingMessageNumber << Log::endl;
  if( handlingMessageNumber > 0){
    isWaitingForHandlingMessages = true;
    pthread_cond_wait( &contextMigratingCond, &contextMigratingMutex);
    isWaitingForHandlingMessages = false;
  }
  ASSERT( handlingMessageNumber == 0 );
  macedbg(1) << "Now handling messages for Context("<< contextName<<") is " << handlingMessageNumber << Log::endl; 
}

void mace::ContextBaseClass::waitingForCreateEventsDone() {
  ADD_SELECTORS("ContextBaseClass::waitingForCreateEventsDone");
  ScopedLock sl(createEventMutex);
  macedbg(1) << "Current handling create events for Context("<< contextName<<") is " << handlingCreateEventNumber << Log::endl;
  if( handlingCreateEventNumber > 0){
    isWaitingForHandlingCreateEvents = true;
    pthread_cond_wait( &contextMigratingCond, &createEventMutex);
    isWaitingForHandlingCreateEvents = false;
  }
  ASSERT( handlingCreateEventNumber == 0 );
  macedbg(1) << "Now handling create event for context("<< contextName<<") is " << handlingCreateEventNumber << Log::endl; 
}

void mace::ContextBaseClass::setMigratingFlag( const bool flag ) {
  ScopedLock sl(contextMigratingMutex);
  migrationEventWaiting = flag;
}

bool ContextBaseClass::checkEventExecutePermission(BaseMaceService* sv, mace::string const& requireContextName, 
    mace::EventOperationInfo const& eventOpInfo, const bool local_check, mace::set<mace::string>& p_ctx_names ) {
  ADD_SELECTORS("ContextBaseClass::checkEventExecutePermission");
  /*
  if( local_check ){
    if( this->checkEventExecutePermitCache(eventOpInfo.eventId, eventOpInfo.toContextName ) ){ // check local cache
      this->enqueueLocalLockRequest(eventOpInfo); // record this event operation
      return true;
    }
  }
  */
    
  mace::vector<DominatorRequest> dominatorRequests;

  ContextService* _service = static_cast<ContextService*>(sv);
  ContextStructure& contextStructure = _service->contextStructure;
  contextStructure.getLock(ContextStructure::READER);

  const mace::string dominatorContext = contextStructure.getUpperBoundContextName(requireContextName);
  bool execute_flag = false;
  if( dominatorContext == this->contextName ) {
    mace::set<mace::string> permittedContextNames = dominator.checkEventExecutePermission(sv, requireContextName, eventOpInfo);
    if( this->contextName == requireContextName && permittedContextNames.size() > 0 && local_check ){
      this->addEventPermitContexts(eventOpInfo.eventId, permittedContextNames );
    }
    macedbg(1) << "Event("<< eventOpInfo.eventId <<") could access " << permittedContextNames << " from " << requireContextName << Log::endl;
    if( permittedContextNames.count(eventOpInfo.toContextName) ){
      execute_flag = true;
    }
    dominatorRequests = dominator.checkWaitingDominatorRequests(eventOpInfo.eventId); // check delayed unlock request
    p_ctx_names = permittedContextNames;
  } else {
    if( eventOpInfo.fromContextName != eventOpInfo.toContextName && eventOpInfo.toContextName == this->contextName  ){
      // this event already get the permission from the dominator
      contextStructure.releaseLock(ContextStructure::READER);
      return true; 
    }

    _service->send__event_requireEventExecutePermission( dominatorContext, requireContextName, eventOpInfo );
  }
  contextStructure.releaseLock(ContextStructure::READER);

  // execute delay unlock requests
  for( uint32_t i=0; i<dominatorRequests.size(); i++ ){
    const DominatorRequest& dominatorRequest = dominatorRequests[i];
    ASSERT( dominatorRequest.lockType == DominatorRequest::UNLOCK_CONTEXT );
    this->unlockContext(sv, dominatorRequest.eventOpInfo, dominatorRequest.ctxName, dominatorRequest.toContextNames );
  }

  return execute_flag;
}

void ContextBaseClass::addEventPermitContexts( mace::OrderID const& eventId, mace::vector<mace::string> const& permitContexts) {
  ADD_SELECTORS("ContextBaseClass::addEventPermissionContexts");
  for( uint32_t i=0; i<permitContexts.size(); i++ ){
    const mace::string& ctxName = permitContexts[i];
    this->addEventPermitContext(eventId, ctxName);
  }
}

void ContextBaseClass::addEventPermitContexts( mace::OrderID const& eventId, mace::set<mace::string> const& permitContexts) {
  ADD_SELECTORS("ContextBaseClass::addEventPermissionContexts");
  for( mace::set<mace::string>::iterator iter=permitContexts.begin(); iter!=permitContexts.end(); iter++ ){
    this->addEventPermitContext(eventId, *iter);
  }
}

void ContextBaseClass::addEventPermitContext( mace::OrderID const& eventId, mace::string const& permitContext) {
  ADD_SELECTORS("ContextBaseClass::addEventPermissionContext");
  
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<OrderID, EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  if( iter == eventExecutionInfos.end() ){
    EventExecutionInfo info;
    info.addEventPermitContext(permitContext);
    eventExecutionInfos[eventId] = info;
  } else{
    (iter->second).addEventPermitContext(permitContext);
  }
}

bool ContextBaseClass::checkEventExecutePermitCache( const mace::OrderID& eventId, const mace::string& ctxName) {
  ADD_SELECTORS("ContextBaseClass::checkEventExecutePermitCache");
  
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<OrderID, EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  if( iter == eventExecutionInfos.end() ){
    return false;
  } else{
    return (iter->second).checkEventExecutePermitCache(ctxName);
  }
}

void ContextBaseClass::clearEventPermitCache( ) {
  ADD_SELECTORS("ContextBaseClass::clearEventPermitCache");
  ScopedLock sl(eventExecutingSyncMutex);
  
  mace::map<OrderID, EventExecutionInfo>::iterator iter;
  for( iter=eventExecutionInfos.begin(); iter!=eventExecutionInfos.end(); iter++ ){
    (iter->second).clearEventPermitCache();
  }
}

void ContextBaseClass::enqueueLocalLockRequest( const mace::EventOperationInfo& eventOpInfo ) {
  ADD_SELECTORS("ContextBaseClass::enqueueLocalLockRequest");
  
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<OrderID, EventExecutionInfo>::iterator eeinfo_iter = getEventExecutionInfo(eventOpInfo.eventId);
  ASSERT( eeinfo_iter != eventExecutionInfos.end() );
  (eeinfo_iter->second).enqueueLocalLockRequest(eventOpInfo);
}

void ContextBaseClass::setEventExecutionInfo( mace::OrderID const& eventId, mace::string const& createContextName,  
      mace::string const& targetContextName, const bool isReadOnly){

  mace::map<OrderID, EventExecutionInfo>::iterator eeinfo_iter = getEventExecutionInfo(eventId);
  if( eeinfo_iter == eventExecutionInfos.end() ) {
    EventExecutionInfo ee_info;
    ee_info.createContextName = createContextName;
    ee_info.targetContextName = targetContextName;
    ee_info.isReadOnly = isReadOnly;
    eventExecutionInfos[eventId] = ee_info;
  } else {
    (eeinfo_iter->second).createContextName = createContextName;
    (eeinfo_iter->second).targetContextName = targetContextName;
    (eeinfo_iter->second).isReadOnly = isReadOnly;
  }
}

void ContextBaseClass::enqueueSubEvent( OrderID const& eventId, mace::EventRequestWrapper const& eventRequest ) {
  ADD_SELECTORS("ContextBaseClass::enqueueSubEvent");
  ScopedLock sl(eventExecutingSyncMutex);
  macedbg(1) << "Enqueue a subevent to event("<< eventId <<") in context("<< contextName <<")" << Log::endl;
  mace::map<OrderID, EventExecutionInfo>::iterator eeinfo_iter = getEventExecutionInfo(eventId);
  if( eeinfo_iter == eventExecutionInfos.end() ) {
    EventExecutionInfo ee_info;
    ee_info.enqueueSubEvent(eventRequest);
    eventExecutionInfos[eventId] = ee_info;
  } else {
    (eeinfo_iter->second).enqueueSubEvent(eventRequest);
  }
}

void ContextBaseClass::enqueueExternalMessage( OrderID const& eventId, mace::EventMessageRecord const& msg ) {
  ADD_SELECTORS("ContextBaseClass::enqueueExternalMessage");
  ScopedLock sl(eventExecutingSyncMutex);
  macedbg(1) << "Enqueue a externalmessage to event("<< eventId <<") in context("<< this->contextName <<")" << Log::endl;
  mace::map<OrderID, EventExecutionInfo>::iterator eeinfo_iter = getEventExecutionInfo(eventId);
  if( eeinfo_iter == eventExecutionInfos.end() ) {
    EventExecutionInfo ee_info;
    ee_info.enqueueExternalMessage(msg);
    eventExecutionInfos[eventId] = ee_info;
  } else {
    (eeinfo_iter->second).enqueueExternalMessage(msg);
  }
}

mace::vector< mace::EventRequestWrapper > ContextBaseClass::getSubEvents(mace::OrderID const& eventId) {
  ADD_SELECTORS("ContextBaseClass::getSubEvents");
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<OrderID, EventExecutionInfo>::iterator eeinfo_iter = getEventExecutionInfo(eventId);
  ASSERT( eeinfo_iter != eventExecutionInfos.end() );
  return (eeinfo_iter->second).getSubEvents();
}

mace::vector< mace::EventMessageRecord > ContextBaseClass::getExternalMessages(mace::OrderID const& eventId) {
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<OrderID, EventExecutionInfo>::iterator eeinfo_iter = getEventExecutionInfo(eventId);
  ASSERT( eeinfo_iter != eventExecutionInfos.end() );
  return (eeinfo_iter->second).getExternalMessages();
}

uint64_t ContextBaseClass::getNextOperationTicket(OrderID const& eventId ){
  //ASSERTMSG( this->now_serving_eventId == eventId, "This context is locked by a different event");
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<OrderID, EventExecutionInfo>::iterator eeinfo_iter = getEventExecutionInfo(eventId);
  if( eeinfo_iter == eventExecutionInfos.end() ) {
    EventExecutionInfo ee_info;
    eventExecutionInfos[eventId] = ee_info;
  } 

  return eventExecutionInfos[eventId].getNextTicket();
}

void ContextBaseClass::enqueueEventOperation( OrderID const& eventId, EventOperationInfo const& opInfo ){
  ADD_SELECTORS("ContextBaseClass::enqueueEventOperation");
  macedbg(1) << "enqueue an ownershipOp("<< opInfo<<") of Event("<< eventId <<") to context("<< contextName<<")." << Log::endl; 
  ASSERTMSG( this->now_serving_eventId == eventId, "This context is locked by a different event" );
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<OrderID, EventExecutionInfo>::iterator eeinfo_iter = getEventExecutionInfo(eventId);
  if( eeinfo_iter == eventExecutionInfos.end() ) {
    EventExecutionInfo ee_info;
    ee_info.addEventOpInfo( opInfo );
    eventExecutionInfos[eventId] = ee_info;
  } else {
    (eeinfo_iter->second).addEventOpInfo( opInfo );
  }
}

void ContextBaseClass::enqueueOwnershipOpInfo( mace::OrderID const& eventId, mace::EventOperationInfo const& op ) {
  ADD_SELECTORS("ContextBaseClass::enqueueOwnershipOpInfo");
  ScopedLock sl(eventExecutingSyncMutex);
  macedbg(1) << "Enqueue a ownershipOp("<< op <<") to event("<< eventId <<") in context("<< this->contextName <<")" << Log::endl;
  mace::map<OrderID, EventExecutionInfo>::iterator eeinfo_iter = getEventExecutionInfo(eventId);
  if( eeinfo_iter == eventExecutionInfos.end() ) {
    EventExecutionInfo ee_info;
    ee_info.enqueueOwnershipOpInfo(op);
    eventExecutionInfos[eventId] = ee_info;
  } else {
    (eeinfo_iter->second).enqueueOwnershipOpInfo(op);
  }
}

mace::vector<mace::EventOperationInfo> ContextBaseClass::extractOwnershipOpInfos( OrderID const& eventId ) {
  //ASSERT( eventId == this->now_serving_eventId );
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<OrderID, EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  if( iter != eventExecutionInfos.end() ){
    return (iter->second).extractOwnershipOpInfos();
  } else {
    mace::vector<EventOperationInfo> empty_vector;
    return empty_vector;
  }
}

mace::EventOperationInfo ContextBaseClass::getNewContextOwnershipOp( mace::OrderID const& eventId, mace::string const& parentContextName,
    mace::string const& childContextName ) {
  //ASSERT( eventId == this->now_serving_eventId );
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<OrderID, EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  if( iter != eventExecutionInfos.end() ){
    return (iter->second).getNewContextOwnershipOp( parentContextName, childContextName);
  } else {
    mace::EventOperationInfo oop;
    return oop;
  }
}

bool ContextBaseClass::checkParentChildRelation(mace::OrderID& eventId, mace::string const& parentContextName, 
    mace::string const& childContextName ) {

  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<OrderID, EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  if( iter != eventExecutionInfos.end() ){
    return (iter->second).checkParentChildRelation(parentContextName, childContextName);
  } else {
    return false;
  }
}

void ContextBaseClass::applyOwnershipOperations( const BaseMaceService* sv, mace::EventOperationInfo const& eop, mace::vector<mace::EventOperationInfo> const& ownershipOpInfos ) {
  ADD_SELECTORS("ContextBaseClass::applyOwnershipOperations");
  // enqueue cached lock requests
  const ContextService* _service = static_cast<const ContextService*>(sv);
  ContextService* _nc_service = const_cast<ContextService*>(_service);
  mace::vector< mace::EventOperationInfo > eops = this->getLocalLockRequest(eop.eventId);
  this->removeLocalLockRequest(eop.eventId);
  if( eops.size() > 0 ){
    this->enqueueLockRequests( _nc_service, eops, this->contextName );
  }


  macedbg(1) << "Apply ownership operations: "<< ownershipOpInfos << Log::endl;
  ScopedLock sl(eventExecutingSyncMutex);
  _service->send__event_ownershipOperations(eop, this->contextName, ownershipOpInfos);
	pthread_cond_t cond;
	pthread_cond_init(&cond,  NULL);
	eventExecutingSyncConds[eop] = &cond;
  pthread_cond_wait( &cond, &eventExecutingSyncMutex );
	eventExecutingSyncConds[eop] = NULL;
	eventExecutingSyncConds.erase(eop);
  pthread_cond_destroy( &cond );
  macedbg(1) << "Ownership("<< ownershipOpInfos << ") are done!" << Log::endl;
}

void ContextBaseClass::addOwnershipOperations( const BaseMaceService* sv, mace::EventOperationInfo const& eop, 
    mace::vector<mace::EventOperationInfo> const& ownershipOpInfos ) {
  ADD_SELECTORS("ContextBaseClass::addOwnershipOperations");
  // enqueue cached lock requests
  const ContextService* _cservice = static_cast<const ContextService*>(sv);
  ContextService* _service = const_cast<ContextService*>(_cservice);
  
  mace::ContextBaseClass* ctxObj = _service->getContextObjByName(eop.fromContextName);
  if( ctxObj != NULL ) {
    for( uint32_t i=0; i<ownershipOpInfos.size(); i++ ){
      ctxObj->enqueueOwnershipOpInfo(eop.eventId, ownershipOpInfos[i] );
    }
  } else {
    macedbg(1) << "Try to send ownership ops of Event("<< eop.eventId <<") to " << eop.fromContextName << " from " << this->contextName << Log::endl;
    
    ScopedLock sl(eventExecutingSyncMutex);
    _service->send__event_enqueueOwnershipOps(eop, eop.fromContextName, this->contextName, ownershipOpInfos);
    
    pthread_cond_t cond;
    pthread_cond_init( &cond, NULL );
    eventExecutingSyncConds[ eop ] = &cond;
    pthread_cond_wait( &cond, &eventExecutingSyncMutex );
    pthread_cond_destroy( &cond );
    eventExecutingSyncConds[eop] = NULL;
    eventExecutingSyncConds.erase(eop);
    macedbg(1) << "Done send ownership ops of Event("<< eop.eventId <<") to " << eop.fromContextName << " from " << this->contextName << Log::endl;
  }
}

void ContextBaseClass::handleOwnershipOperationsReply( mace::EventOperationInfo const& eop ) {
  ADD_SELECTORS("ContextBaseClass::handleOwnershipOperationsReply");
  ScopedLock sl(eventExecutingSyncMutex);

  ASSERT( eventExecutingSyncConds.find(eop) != eventExecutingSyncConds.end() );
	pthread_cond_signal( eventExecutingSyncConds[eop] );
}

void ContextBaseClass::enqueueExecuteContextEvent( BaseMaceService* sv, ContextEvent& ce) {
  ADD_SELECTORS("ContextBaseClass::enqueueExecuteContextEvent");
  macedbg(1) << "Enqueue an ContextEvent("<< ce.eventId <<") to context " << this->contextName << Log::endl;
  bool push_back_flag = true;
  mace::deque<mace::ContextEvent>::iterator iter = executeEventQueue.begin();
  for(; iter != executeEventQueue.end(); iter ++ ) {
    const mace::ContextEvent& ce2 = *iter;
    if( ce2.eventId == ce.eventId ) {
      iter ++;
      if( iter != executeEventQueue.end() ) {
        executeEventQueue.insert(iter, ce);
        push_back_flag = false;
      }
      break;
    }
  }
  if( push_back_flag ) {
    executeEventQueue.push_back( ce );
  }
  ce.param = NULL;
  enqueueReadyExecuteEventQueue();
}

void ContextBaseClass::enqueueExecuteContextEventToHead( BaseMaceService* sv, ContextEvent& ce) {
  executeEventQueue.push_front( ce );
  ce.param = NULL;
  enqueueReadyExecuteEventQueue();
}

void ContextBaseClass::enqueueReadyExecuteEventQueueWithLock() {
  ScopedLock sl(executeEventMutex);
  enqueueReadyExecuteEventQueue();
}

void ContextBaseClass::enqueueReadyCreateEventQueueWithLock() {
  ScopedLock sl( createEventMutex );
  enqueueReadyCreateEventQueue();
}

// executeEventQueue should be locked before and during this method
bool ContextBaseClass::enqueueReadyExecuteEventQueue() {
  ADD_SELECTORS("ContextBaseClass::enqueueReadyExecuteEventQueue");
  if( executeEventQueue.empty() ){
    return false;
  }
  
  ContextEvent& e = executeEventQueue.front();
  ContextService* _service = static_cast<ContextService*>(e.sv);

  uint64_t execute_ticket = contextEventOrder.getExecuteEventTicket(e.eventId);
  mace::EventOperationInfo eop;
  // this event already lock this context
  if( execute_ticket != 0 && execute_ticket <= this->now_serving_execute_ticket ) {
    macedbg(1) << "Event("<< e.eventId <<") executed in context("<< this->contextName <<") before!" << Log::endl;
    
    if( e.type == ContextEvent::TYPE_BROADCAST_EVENT ) {
      AsyncEvent_Message* msg = static_cast<AsyncEvent_Message*>(e.param);
      mace::Event& event = msg->getEvent();
      eop = event.eventOpInfo;
    } else if( e.type == ContextEvent::TYPE_ROUTINE_EVENT ) {
      Routine_Message* msg = static_cast<Routine_Message*>(e.param);
      mace::Event& event = msg->getEvent();
      eop = event.eventOpInfo;
    }
    this->addEventFromContext( e.eventId, eop.fromContextName );
    _service->enqueueReadyExecuteEventQueue(e);
    e.param = NULL;
    executeEventQueue.pop_front();
    return true;
  } else {
    
    macedbg(1) << "context("<< this->contextName<<") executeTicket=" << execute_ticket << " nextExecuteTicketNumber=" << 
      contextEventOrder.getExecuteTicketNumber() << " now_serving_execute_ticket="<< this->now_serving_execute_ticket << Log::endl;
    
    ASSERT( contextEventOrder.getExecuteTicketNumber() >= this->now_serving_execute_ticket );

    ContextStructure& contextStructure = _service->contextStructure;
    if( execute_ticket == 0 && contextEventOrder.getExecuteTicketNumber() == this->now_serving_execute_ticket ){ // context allow next event to execute
      mace::EventExecutionInfo eventInfo;
      
      if( e.type == ContextEvent::TYPE_ASYNC_EVENT ){
        AsyncEvent_Message* msg = static_cast<AsyncEvent_Message*>(e.param);
        mace::Event& event = msg->getEvent();
        eventInfo.targetContextName = event.target_ctx_name;
        eventInfo.createContextName = event.create_ctx_name;
        eventInfo.isReadOnly = event.isReadOnly;
        eop = event.eventOpInfo;

        event.eventContextStructureVersion = contextStructure.getCurrentVersion();
        contextEventOrder.addExecuteEvent(event.eventId);
      } else if( e.type == ContextEvent::TYPE_BROADCAST_EVENT ) {
        AsyncEvent_Message* msg = static_cast<AsyncEvent_Message*>(e.param);
        mace::Event& event = msg->getEvent();
        //macedbg(1) << "Event("<< event.eventId <<") is a broadcast event!" << Log::endl;
        eventInfo.targetContextName = event.target_ctx_name;
        eventInfo.createContextName = event.create_ctx_name;
        eventInfo.isReadOnly = event.isReadOnly;
        eop = event.eventOpInfo;
        
        this->contextEventOrder.addExecuteEvent(e.eventId);
      } else if( e.type == ContextEvent::TYPE_ROUTINE_EVENT ) {
        Routine_Message* msg = static_cast<Routine_Message*>(e.param);
        mace::Event& event = msg->getEvent();
        eventInfo.targetContextName = event.target_ctx_name;
        eventInfo.createContextName = event.create_ctx_name;
        eventInfo.isReadOnly = event.isReadOnly;
        eop = event.eventOpInfo;
        
        this->contextEventOrder.addExecuteEvent(e.eventId);
        
      } else {
        ASSERTMSG(false, "Invalid event type!");
        return false;
      }

      const uint64_t executeTicket = this->contextEventOrder.getExecuteEventTicket(e.eventId);
      ASSERT( executeTicket>0 && executeTicket == this->now_serving_execute_ticket );

      ScopedLock execute_sl( eventExecutingSyncMutex );
      mace::map<mace::OrderID, EventExecutionInfo>::iterator einfo_iter = getEventExecutionInfo(e.eventId);
      macedbg(1) << "Create EventExecutionInfo for event("<< e.eventId <<") in " << this->contextName << Log::endl;
      if( einfo_iter == eventExecutionInfos.end() ) {
        eventExecutionInfos[e.eventId] = eventInfo;
      } else {
        mace::EventExecutionInfo& eInfo = einfo_iter->second;
        eInfo.targetContextName = eventInfo.targetContextName;
        eInfo.createContextName = eventInfo.createContextName;
        eInfo.isReadOnly = eventInfo.isReadOnly;
      }
      execute_sl.unlock();

      this->addEventFromContext( e.eventId, eop.fromContextName );
      _service->enqueueReadyExecuteEventQueue(e);
      e.param = NULL;
      this->executeEventQueue.pop_front();
      return true;
    } 
  }
  return false;
}

bool mace::ContextBaseClass::enqueueReadyCreateEventQueue(){
  ADD_SELECTORS("ContextBaseClass::enqueueReadyCreateEventQueue");
  if( this->migrationEventWaiting ) {
    return false;
  }

  if( createEventQueue.empty() ) {
    return false;
  }
  
  HeadEventDispatch::HeadEvent& top = createEventQueue.front();
  ContextService* _service = static_cast<ContextService*>(top.cl);
  if( top.eventId.ticket == this->now_serving_create_ticket ) {
    _service->enqueueReadyCreateEventQueue(top);
    top.param = NULL;
    createEventQueue.pop();
    this->handlingCreateEventNumber ++;
    return true;    
  } 
  return false;
}

bool mace::ContextBaseClass::enqueueReadyCommitEventQueue() {
  ADD_SELECTORS("ContextBaseClass::enqueueCommitExecuteEventQueue");
  ScopedLock sl(commitEventMutex);
  mace::ContextCommitEvent* committingEvent = NULL;
  if( executeCommitEventQueue.find(execute_now_committing_ticket) != executeCommitEventQueue.end() ) {
    committingEvent = executeCommitEventQueue[execute_now_committing_ticket];
  } else {
    macedbg(1) << "There is no available commit events! execute_now_committing_ticket="<< execute_now_committing_ticket << Log::endl;
    return false;
  }
  executeCommitEventQueue[execute_now_committing_ticket] = NULL;
  executeCommitEventQueue.erase(execute_now_committing_ticket);
  sl.unlock();
  ContextService* _service = static_cast<ContextService*>(committingEvent->sv);
  _service->enqueueReadyCommitEventQueue(*committingEvent);
  return true;
}

uint32_t mace::ContextBaseClass::createNewContext(BaseMaceService* sv, mace::string const& contextTypeName) {
  ADD_SELECTORS("ContextBaseClass::createNewContext");
  const mace::OrderID& eventId = ThreadStructure::myEventID();
  macedbg(1) << "Event("<< eventId <<") try to create a new context of "<< contextTypeName << "!" << Log::endl;
  const mace::EventOperationInfo& eventOpInfo = ThreadStructure::myEvent().eventOpInfo;
  ContextService* _service = static_cast<ContextService*>(sv);
  ScopedLock sl(eventExecutingSyncMutex);
  _service->send__event_createNewContext(this->contextName, contextTypeName, eventOpInfo);
  pthread_cond_t cond;
  pthread_cond_init( &cond, NULL );
  eventExecutingSyncConds[ eventOpInfo ] = &cond;
  pthread_cond_wait( &cond, &eventExecutingSyncMutex );
  mace::map<mace::OrderID, mace::EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  ASSERT( iter != eventExecutionInfos.end() );
  pthread_cond_destroy( &cond );
  eventExecutingSyncConds[eventOpInfo] = NULL;
  eventExecutingSyncConds.erase(eventOpInfo);
  return (iter->second).getNewContextID();
}

void mace::ContextBaseClass::handleCreateNewContextReply(mace::EventOperationInfo const& eventOpInfo, const uint32_t& newContextId) {
  ADD_SELECTORS("ContextBaseClass::handleCreateNewContextReply");
  const mace::OrderID& eventId = eventOpInfo.eventId;
  macedbg(1) << "Event("<< eventId <<") create a new contextId=" << newContextId << Log::endl;
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<mace::OrderID, mace::EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  if( iter == eventExecutionInfos.end() ) {
    EventExecutionInfo info;
    eventExecutionInfos[eventId] = info;
  }
  eventExecutionInfos[eventId].setNewContextID(newContextId);
  std::map<mace::EventOperationInfo, pthread_cond_t*>::iterator cond_iter = eventExecutingSyncConds.find(eventOpInfo);
  if( cond_iter != eventExecutingSyncConds.end() ) {
    pthread_cond_signal(cond_iter->second);
  }
}

void mace::ContextBaseClass::enqueueSubEvent(BaseMaceService* sv, mace::EventOperationInfo const& eventOpInfo, mace::string const& targetContextName, mace::EventRequestWrapper const& reqObject) {
  ADD_SELECTORS("ContextBaseClass::enqueueSubEvent");
  ContextService* _service = static_cast<ContextService*>(sv);
  mace::ContextBaseClass* ctxObj = _service->getContextObjByName(targetContextName);
  if( ctxObj != NULL ) {
    ctxObj->enqueueSubEvent(eventOpInfo.eventId, reqObject);
  } else {
    macedbg(1) << "Try to send a subevent of Event("<< eventOpInfo.eventId <<") to " << targetContextName << " from " << this->contextName << Log::endl;
    
    ScopedLock sl(eventExecutingSyncMutex);
    _service->send__event_enqueueSubEvent(eventOpInfo, targetContextName, this->contextName, reqObject);
    
    pthread_cond_t cond;
    pthread_cond_init( &cond, NULL );
    eventExecutingSyncConds[ eventOpInfo ] = &cond;
    pthread_cond_wait( &cond, &eventExecutingSyncMutex );
    pthread_cond_destroy( &cond );
    eventExecutingSyncConds[eventOpInfo] = NULL;
    eventExecutingSyncConds.erase(eventOpInfo);
    macedbg(1) << "Done send a subevent of Event("<< eventOpInfo.eventId <<") to " << targetContextName << " from " << this->contextName << Log::endl;
  }
}

bool ContextBaseClass::deferExternalMessage( mace::EventOperationInfo const& eventOpInfo, mace::string const& targetContextName, uint8_t instanceUniqueID, 
    MaceKey const& dest,  std::string const&  message, registration_uid_t const rid ) {
  ADD_SELECTORS("ContextBaseClass::deferExternalMessage");
  AsyncEventReceiver* sv = BaseMaceService::getInstance(this->serviceId);
  ContextService* _service = static_cast<ContextService*>(sv);

  macedbg(1)<<"defer an external message sid="<<(uint16_t)instanceUniqueID<<", dest="<<dest<<", rid="<<rid<<Log::endl;
  EventMessageRecord emr(instanceUniqueID, dest, message, rid );

  mace::ContextBaseClass* ctxObj = _service->getContextObjByName(targetContextName);
  if( ctxObj != NULL ) {
    ctxObj->enqueueExternalMessage(eventOpInfo.eventId, emr);
  } else {
    macedbg(1) << "Try to send a externalmessage of Event("<< eventOpInfo.eventId <<") to " << targetContextName << " from " << this->contextName << Log::endl;
    
    ScopedLock sl(eventExecutingSyncMutex);
    _service->send__event_enqueueExternalMessage(eventOpInfo, targetContextName, this->contextName, emr);
    
    pthread_cond_t cond;
    pthread_cond_init( &cond, NULL );
    eventExecutingSyncConds[ eventOpInfo ] = &cond;
    pthread_cond_wait( &cond, &eventExecutingSyncMutex );
    pthread_cond_destroy( &cond );
    eventExecutingSyncConds[eventOpInfo] = NULL;
    eventExecutingSyncConds.erase(eventOpInfo);
    macedbg(1) << "Done send a externalmessage of Event("<< eventOpInfo.eventId <<") to " << targetContextName << " from " << this->contextName << Log::endl;
  }
  return true;
}

void mace::ContextBaseClass::handleEnqueueSubEventReply(mace::EventOperationInfo const& eventOpInfo) {
  ADD_SELECTORS("ContextBaseClass::handleEnqueueSubEventReply");
  const mace::OrderID& eventId = eventOpInfo.eventId;
  macedbg(1) << "Recv enqueue subevent reply for Event("<< eventId <<")!" << Log::endl;
  ScopedLock sl(eventExecutingSyncMutex);
  std::map<mace::EventOperationInfo, pthread_cond_t*>::iterator cond_iter = eventExecutingSyncConds.find(eventOpInfo);
  if( cond_iter != eventExecutingSyncConds.end()  ) {
    pthread_cond_signal(cond_iter->second);
    macedbg(1) << "Signal Event("<< eventId <<") in " << this->contextName << Log::endl;
  }
}

void mace::ContextBaseClass::handleEnqueueExternalMessageReply(mace::EventOperationInfo const& eventOpInfo) {
  ADD_SELECTORS("ContextBaseClass::handleEnqueueExternalMessageReply");
  const mace::OrderID& eventId = eventOpInfo.eventId;
  macedbg(1) << "Recv enqueue enqueue message reply for Event("<< eventId <<")!" << Log::endl;
  ScopedLock sl(eventExecutingSyncMutex);
  std::map<mace::EventOperationInfo, pthread_cond_t*>::iterator cond_iter = eventExecutingSyncConds.find(eventOpInfo);
  if( cond_iter != eventExecutingSyncConds.end()  ) {
    pthread_cond_signal(cond_iter->second);
    macedbg(1) << "Signal Event("<< eventId <<") in " << this->contextName << Log::endl;
  }
}

void mace::ContextBaseClass::handleEnqueueOwnershipOpsReply(mace::EventOperationInfo const& eventOpInfo) {
  ADD_SELECTORS("ContextBaseClass::handleEnqueueOwnershipOpsReply");
  const mace::OrderID& eventId = eventOpInfo.eventId;
  macedbg(1) << "Recv enqueue oops reply for Event("<< eventId <<")!" << Log::endl;
  ScopedLock sl(eventExecutingSyncMutex);
  std::map<mace::EventOperationInfo, pthread_cond_t*>::iterator cond_iter = eventExecutingSyncConds.find(eventOpInfo);
  if( cond_iter != eventExecutingSyncConds.end()  ) {
    pthread_cond_signal(cond_iter->second);
    macedbg(1) << "Signal Event("<< eventId <<") in " << this->contextName << Log::endl;
  }
}

void mace::ContextBaseClass::handleEventExecutePermission(BaseMaceService* sv, mace::OrderID const& eventId, mace::vector<mace::string> const& permitContexts,
      mace::vector<mace::EventOperationInfo> const& eventOpInfos) {

  ADD_SELECTORS("ContextBaseClass::handleEventExecutePermission");
  macedbg(1) << "Event("<< eventId <<") recv permission in " << this->contextName << ":" << eventOpInfos << Log::endl;
  
  for( uint32_t i=0; i<eventOpInfos.size(); i++ ){
    const EventOperationInfo& eventOpInfo = eventOpInfos[i];

    if( eventOpInfo.fromContextName == this->contextName ){
      this->addEventPermitContexts(eventOpInfo.eventId, permitContexts );
    }

    ScopedLock order_sl(this->contextEventOrderMutex);
    if( eventOpInfo.toContextName == this->contextName ) { // get permit to execute in toContext
      ScopedLock sl(this->executeEventMutex);
      this->enqueueContextEvent(sv, eventOpInfo.eventId);
    } else {
      if( eventOpInfo.opType == mace::EventOperationInfo::ROUTINE_OP ){
        ScopedLock sl(eventExecutingSyncMutex);
        std::map<mace::EventOperationInfo, pthread_cond_t*>::iterator cond_iter = eventExecutingSyncConds.find(eventOpInfo);
        if( cond_iter != eventExecutingSyncConds.end()  ) { // it's a sync call which is blocked
          pthread_cond_signal(cond_iter->second);
          macedbg(2) << "Signal Event("<< eventId <<") in " << this->contextName << Log::endl;
        }
      } else if( eventOpInfo.opType == mace::EventOperationInfo::BROADCAST_OP ){
        ScopedLock sl(this->executeEventMutex);
        this->forwardWaitingBroadcastRequset(sv, eventOpInfo);
      } else {
        ASSERT(false);
      }
    }
  }
}

void mace::ContextBaseClass::handleEventCommitDone( BaseMaceService* sv, mace::OrderID const& eventId ){
  ADD_SELECTORS("ContextBaseClass::handleEventCommitDone");
  ASSERT( contextEventOrder.getExecuteEventTicket(eventId)>0 );
  this->enqueueCommitEventQueue(sv, eventId, false);
}

void mace::ContextBaseClass::enqueueLockRequests(BaseMaceService* sv, mace::vector<mace::EventOperationInfo> const& eops, 
    mace::string const& requireContextName ) {
  ADD_SELECTORS("ContextBaseClass::enqueueLockRequests");

  if( eops.size() == 0 ){
    return;
  }
  macedbg(1) << "Enqueue localLockRequests=" << eops << " from " << requireContextName << Log::endl; 
  ContextService* _service = static_cast<ContextService*>(sv);
  ContextStructure& contextStructure = _service->contextStructure;

  contextStructure.getLock(ContextStructure::READER);
  const mace::string dominatorName = contextStructure.getUpperBoundContextName(requireContextName);
  if( dominatorName != requireContextName ){
    contextStructure.releaseLock(ContextStructure::READER);
    _service->send__event_enqueueLockRequests( dominatorName, requireContextName, eops );
    return;
  }
  contextStructure.releaseLock(ContextStructure::READER);

  mace::set<mace::string> p_ctx_names;
  for( uint32_t i=0; i<eops.size(); i++ ){
    this->checkEventExecutePermission( sv, requireContextName, eops[i], false, p_ctx_names );
  }
}


void mace::ContextBaseClass::unlockContext( BaseMaceService* sv, mace::EventOperationInfo const& eventOpInfo, 
    mace::string const& srcContextName, mace::set<mace::string> const& toContextNames ) {
  ADD_SELECTORS("ContextBaseClass::unlockContext");
  ContextService* _service = static_cast<ContextService*>(sv);
  ContextStructure& contextStructure = _service->contextStructure;

  macedbg(1) << "Event("<< eventOpInfo.eventId <<") unlock context("<< eventOpInfo.toContextName <<") in dominator("<< this->contextName <<")!" << Log::endl;

  contextStructure.getLock(ContextStructure::READER);
  const mace::string dominatorName = contextStructure.getUpperBoundContextName(eventOpInfo.fromContextName);

  mace::vector<mace::string> releaseContexts;
  mace::map< mace::string, mace::map<mace::OrderID, mace::vector<mace::string> > >  permittedEvents;
  mace::map< mace::string, mace::map<mace::OrderID, mace::vector<mace::EventOperationInfo> > > permittedEventOps;
    
  if( dominatorName == this->contextName ){
    //macedbg(1) << "Event("<< eventOpInfo <<") tries to unlock context " << eventOpInfo.toContextName <<" in "<< this->contextName <<Log::endl;
    bool executed_flag = dominator.unlockContext( contextStructure, eventOpInfo, eventOpInfo.fromContextName, toContextNames, permittedEvents, permittedEventOps, releaseContexts );
    if( !executed_flag ) {
      contextStructure.releaseLock(ContextStructure::READER);
      return;
    }
  } else {
    contextStructure.releaseLock(ContextStructure::READER);
    _service->send__event_unlockContext(dominatorName, eventOpInfo, srcContextName, toContextNames);
    return;
  }

  //const ContextMapping& snapshot = _service->getLatestContextMapping();
  //mace::map< mace::MaceAddr, mace::vector<mace::string> > releaseContextAddrs;
  for( uint32_t i=0; i<releaseContexts.size(); i++ ) {
    const mace::string& releaseContext = releaseContexts[i];
    const mace::string releaseDominator = contextStructure.getUpperBoundContextName(releaseContext);
    macedbg(1) << "Dominator("<< this->contextName <<") try to notify dominator("<< releaseDominator <<") to release context("<< releaseContext <<") for " << eventOpInfo.eventId << Log::endl;
    if( releaseDominator != this->contextName ){
      mace::vector<mace::string> lockedContextNames;
      lockedContextNames.push_back(releaseContext);
      _service->send__event_releaseContexts(releaseDominator, eventOpInfo.eventId, dominatorName, lockedContextNames);

    } else {
      // both "from" and "to" contexts belong to this dominator, to release lock on "to" context directly
      if( releaseContext != this->contextName ) {
        _service->send__event_releaseLockOnContext( releaseContext, this->contextName, eventOpInfo.eventId );
      }
    }
  }

  contextStructure.releaseLock(ContextStructure::READER);
  // notify child dominator to release contexts
  /*
  mace::map< mace::MaceAddr, mace::vector<mace::string> >::const_iterator release_iter = releaseContextAddrs.begin();
  for(; release_iter != releaseContextAddrs.end(); release_iter ++ ){
    _service->send__event_releaseContexts(release_iter->first, eventOpInfo.eventId, dominatorName, release_iter->second);
  }
  */
  
  // notify next executing events
  mace::map< mace::string, mace::map<mace::OrderID, mace::vector<mace::string> > >::iterator permit_iter;
  for( permit_iter = permittedEvents.begin(); permit_iter != permittedEvents.end(); permit_iter ++ ){
    const mace::string& requireContextName = permit_iter->first;
    mace::map< mace::OrderID, mace::vector<mace::string> >& permittedContextNames = permit_iter->second;
    // const MaceAddr& addr = ContextMapping::getNodeByContext( snapshot, requireContextName );

    mace::map< mace::OrderID, mace::vector<mace::string> >::iterator ctx_iter;
    for( ctx_iter=permittedContextNames.begin(); ctx_iter!=permittedContextNames.end(); ctx_iter++ ){
      const mace::vector<mace::EventOperationInfo>& opInfos = permittedEventOps[requireContextName][ctx_iter->first];

      macedbg(1) << "Dominator("<< this->contextName <<") release requireContextName="<< requireContextName 
        <<"; event="<< ctx_iter->first <<"; eventOps="<< opInfos << Log::endl;
      if( requireContextName == this->contextName ){
        this->handleEventExecutePermission( sv, ctx_iter->first, ctx_iter->second, opInfos );
      } else {
        _service->send__event_replyEventExecutePermission( requireContextName, dominatorName, ctx_iter->first, ctx_iter->second, 
          opInfos );
      }
    }
  }
}

void mace::ContextBaseClass::releaseContext( BaseMaceService* sv, mace::OrderID const& eventId, mace::string const& lockedContextName,
    mace::set<mace::string> const& toContextNames ) {

  ADD_SELECTORS("ContextBaseClass::releaseContext");
  macedbg(1) << "Context("<< this->contextName <<") release locked context("<< lockedContextName <<") toContextNames("<< toContextNames <<") for " << eventId << Log::endl;

  ContextService* _service = static_cast<ContextService*>(sv);
  ContextStructure& contextStructure = _service->contextStructure;
  contextStructure.getLock(ContextStructure::READER);

  //const mace::ContextMapping& snapshot = _service->getLatestContextMapping();

  const mace::string dominatorContext = contextStructure.getUpperBoundContextName(lockedContextName);
  
  mace::vector<mace::string> releaseContexts;
  mace::set<mace::string> latestReleasedContexts;
  mace::map< mace::string, mace::map<mace::OrderID, mace::vector<mace::string> > >  permittedEvents;
  mace::map< mace::string, mace::map<mace::OrderID, mace::vector<mace::EventOperationInfo> > > permittedEventOps;
  
  if( dominatorContext == this->contextName ){
    bool executed_flag = dominator.releaseContext( contextStructure, eventId, lockedContextName, toContextNames, permittedEvents, 
      permittedEventOps, releaseContexts, latestReleasedContexts );
    if( !executed_flag ){
      contextStructure.releaseLock(ContextStructure::READER);
      return;
    }
  } else {
    contextStructure.releaseLock(ContextStructure::READER);
    mace::vector<mace::string> lockedContextNames;
    lockedContextNames.push_back(lockedContextName);
    for( mace::set<mace::string>::const_iterator iter=toContextNames.begin(); iter!=toContextNames.end(); iter++ ) {
      lockedContextNames.push_back(*iter);
    }

    _service->send__event_releaseContexts( dominatorContext, eventId, this->contextName, lockedContextNames);
    return;
  }

  // release lock on locked context
  if( this->contextName == lockedContextName ){
    this->releaseLock(sv, eventId);
  } else {
    
  }

  // notify locked contexts that should be released.
  // mace::map< mace::MaceAddr, mace::vector<mace::string> > releaseContextAddrs;
  for( uint32_t i=0; i<releaseContexts.size(); i++ ) {
    const mace::string& releaseContext = releaseContexts[i];
    mace::string releaseDominator = contextStructure.getUpperBoundContextName(releaseContext);
    //macedbg(1) << "Try to notify dominator("<< releaseDominator <<") to release context("<< releaseContext <<") for " << eventId << Log::endl;
    if( releaseDominator != this->contextName ){
      mace::vector<mace::string> lockedContextNames;
      lockedContextNames.push_back(releaseContext);
      _service->send__event_releaseContexts(releaseDominator, eventId, this->contextName, lockedContextNames);
      macedbg(1) << "Dominator("<< this->contextName <<") Event("<< eventId <<") try to release: " << releaseContext << " in " << releaseDominator <<Log::endl;
    } else {
      // both "from" and "to" contexts belong to this dominator, to release lock on "to" context directly
      if( releaseContext != this->contextName ) {
        //macedbg(1) << "To release context("<< releaseContext <<") for event "<< eventId << Log::endl;
        _service->send__event_releaseLockOnContext( releaseContext, this->contextName, eventId);
        macedbg(1) << "Dominator("<< this->contextName <<") Event("<< eventId <<") try to release: " << releaseContext << " in " << releaseDominator <<Log::endl;
      }
    } 
  }
  contextStructure.releaseLock(ContextStructure::READER);

  // notify next executing events
  mace::map< mace::string, mace::map<mace::OrderID, mace::vector<mace::string> > >::iterator permit_iter;
  for( permit_iter = permittedEvents.begin(); permit_iter != permittedEvents.end(); permit_iter ++ ){
    const mace::string& requireContextName = permit_iter->first;
    mace::map< mace::OrderID, mace::vector<mace::string> >& permittedContextNames = permit_iter->second;
    //const MaceAddr& addr = ContextMapping::getNodeByContext( snapshot, requireContextName );

    mace::map< mace::OrderID, mace::vector<mace::string> >::iterator ctx_iter;
    for( ctx_iter=permittedContextNames.begin(); ctx_iter!=permittedContextNames.end(); ctx_iter++ ){
      const mace::vector<mace::EventOperationInfo>& opInfos = permittedEventOps[requireContextName][ctx_iter->first];
      macedbg(2) << "Dominator("<< this->contextName <<") release requireContextName="<< requireContextName 
        <<"; event="<< ctx_iter->first <<"; permittedContextNames="<< ctx_iter->second <<"; eventOps="<< opInfos << Log::endl;
      if( requireContextName == this->contextName ){
        this->handleEventExecutePermission( sv, ctx_iter->first, ctx_iter->second, opInfos );
      } else {
        _service->send__event_replyEventExecutePermission( requireContextName, this->contextName, ctx_iter->first, ctx_iter->second, opInfos );
      }
    }
  }
}

void mace::ContextBaseClass::handleEventOperationDone( BaseMaceService const* sv, mace::EventOperationInfo const& eop ) {
  ADD_SELECTORS("ContextBaseClass::handleEventOperationDone");
  ContextService const* _service = static_cast<ContextService const*>(sv);

  ContextService* _non_service = const_cast<ContextService*>(_service);

  mace::vector< mace::EventOperationInfo > eops = this->getLocalLockRequest(eop.eventId);
  this->removeLocalLockRequest(eop.eventId);
  if( eops.size() > 0 ){
    this->enqueueLockRequests( _non_service, eops, this->contextName );
  }

  mace::set<mace::string> toContextNames = this->getEventToContextNames( eop.eventId );
  this->unlockContext( _non_service, eop, eop.fromContextName, toContextNames );
}

void mace::ContextBaseClass::getReadyToCommit( BaseMaceService* sv, mace::OrderID const& eventId, int debug ) {
  ADD_SELECTORS("ContextBaseClass::getReadyToCommit");
  
  if( this->checkEventIsLockContext(eventId) ){
    macedbg(1) << "Event("<< eventId <<") hasn't committed in " << this->contextName << Log::endl;
    return;
  }

  ContextService* _service = static_cast<ContextService*>(sv);
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<mace::OrderID, mace::EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  if( iter == eventExecutionInfos.end() ) {
    macedbg(1) << "Fail to find event("<< eventId <<")'s info in " << this->contextName << Log::endl;
    /*
    maceerr << "Fail to find event("<< eventId <<") in " << this->contextName << " debug=" << debug << Log::endl;
    maceerr << eventExecutionInfos << Log::endl;
    maceerr << "Deleted events=" << deletedEventIds << Log::endl;
    maceerr << "Release lock events=" << releaseLockEventIds << Log::endl;
    maceerr << "Committed events=" << committedEventIds << Log::endl;
    */
    return;
  }
  
  if( debug == 0 ) {
    // releaseLockEventIds.push_back(eventId );
  }
  
  const mace::ContextMapping& snapshot = _service->getLatestContextMapping();

  mace::EventExecutionInfo& eeInfo = iter->second;
  if( eeInfo.getToContextSize() == 0 && !eeInfo.checkAlreadyCommittedFlag() ){
    macedbg(1) << "Event("<< eventId <<") could commit in "<< this->contextName << Log::endl;
    eeInfo.setAlreadyCommittedFlagTrue();
    if( eeInfo.targetContextName == this->contextName ){
      sl.unlock();
      this->enqueueCommitEventQueue( sv, eventId, true );
      return;
    }

    const mace::set<mace::string>& executedContexts = eeInfo.getToContextsCopy();
    mace::vector<mace::string> v_executedContexts;
    for( mace::set<mace::string>::const_iterator cIter = executedContexts.begin(); cIter != executedContexts.end(); cIter++ ){
      v_executedContexts.push_back( *cIter );
    }

    const mace::set<mace::string>& fromContexts = eeInfo.getFromContexts();
    ASSERT( fromContexts.size() > 0 );
    mace::map< mace::MaceAddr, mace::vector<mace::string> > fromContextAddrs;
    for( mace::set<mace::string>::const_iterator cIter = fromContexts.begin(); cIter != fromContexts.end(); cIter ++ ) {
      const mace::string& fromContext = *cIter;
      ASSERT( fromContext != this->contextName );
      
      const mace::MaceAddr& addr = mace::ContextMapping::getNodeByContext(snapshot, fromContext );
      fromContextAddrs[addr].push_back(fromContext);
    }

    mace::map< mace::MaceAddr, mace::vector<mace::string> >::const_iterator from_iter = fromContextAddrs.begin();
    for(; from_iter != fromContextAddrs.end(); from_iter ++ ){
      _service->send__event_notifyReadyToCommit(from_iter->first, eventId, this->contextName, from_iter->second, v_executedContexts );
    }
  }
}

void mace::ContextBaseClass::notifyReadyToCommit( BaseMaceService* sv, mace::OrderID const& eventId, mace::string const& toContext, 
    mace::vector<mace::string> const& executedContextNames ) {
  ADD_SELECTORS("ContextBaseClass::notifyReadyToCommit");
  macedbg(1) << "Event("<< eventId <<") toContext=" << toContext << " executedContextNames=" << executedContextNames << " in " << this->contextName <<Log::endl; 
  //ContextService* _service = static_cast<ContextService*>(sv);
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<mace::OrderID, mace::EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  ASSERT( iter!= eventExecutionInfos.end() );
  //const mace::ContextMapping& snapshot = _service->getLatestContextMapping();

  mace::EventExecutionInfo& eeInfo = iter->second;
  eeInfo.eraseToContext( toContext );
  for( uint32_t i=0; i<executedContextNames.size(); i++ ){
    eeInfo.addEventToContextCopy( executedContextNames[i] );
  }
  sl.unlock();

  this->getReadyToCommit(sv, eventId, 1);
}

void mace::ContextBaseClass::updateDominator(BaseMaceService* sv, mace::map<mace::string, mace::string> const& prePDominators, 
    mace::map<mace::string, mace::string> const& preDominators) {
  ADD_SELECTORS("ContextBaseClass::updateDominator");

  this->clearEventPermitCache();
  mace::vector<DominatorRequest> dominatorRequests;
  
  ContextService* _service = static_cast<ContextService*>(sv);
  ContextStructure& ctxStructure = _service->contextStructure;
  
  ctxStructure.getLock(ContextStructure::READER);
  if( dominator.updateDominator(sv, prePDominators, preDominators, dominatorRequests) ){
    ContextService* _service = static_cast<ContextService*>(sv);
    mace::set<mace::string> ctxNames;
    ctxNames.insert( this->contextName);
    _service->send__event_updateOwnershipReply(ctxNames);

    dominator.clearWaitingDominatorRequests();
    this->handleWaitingDominatorRequests( sv, dominatorRequests );
  }
  ctxStructure.releaseLock(ContextStructure::READER);
}

void mace::ContextBaseClass::updateEventQueue(BaseMaceService* sv, mace::string const& src_contextName, 
    mace::ContextEventDominator::EventLockQueue const& lockQueues ) {
  ADD_SELECTORS("ContextBaseClass::updateEventQueue");
  mace::vector<DominatorRequest> dominatorRequests;
  if( dominator.updateEventQueue(sv, src_contextName, lockQueues, dominatorRequests) ){
    ContextService* _service = static_cast<ContextService*>(sv);
    mace::set<mace::string> ctxNames;
    ctxNames.insert( this->contextName);
    _service->send__event_updateOwnershipReply(ctxNames);

    dominator.clearWaitingDominatorRequests();
    this->handleWaitingDominatorRequests( sv, dominatorRequests );
  }
}

void mace::ContextBaseClass::addEventToContext( mace::OrderID const& eventId, mace::string const& toContext ) {
  ADD_SELECTORS("ContextBaseClass::addEventToContext");
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<mace::OrderID, mace::EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  ASSERT( iter != eventExecutionInfos.end() );
  macedbg(1) << "Add event("<< eventId <<")'s new toContext("<< toContext <<") in " << this->contextName << Log::endl;
  (iter->second).addEventToContext( toContext );
}


void mace::ContextBaseClass::addEventFromContext( mace::OrderID const& eventId, mace::string const& fromContext ) {
  ADD_SELECTORS("ContextBaseClass::addEventFromContext");
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<mace::OrderID, mace::EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  ASSERT( iter != eventExecutionInfos.end() );
  // record all executed context names
  (iter->second).addEventFromContext( fromContext );
}

mace::set<mace::string> mace::ContextBaseClass::getEventToContextNames( mace::OrderID const& eventId ) {
  ADD_SELECTORS("ContextBaseClass::getEventToContextNames");
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<mace::OrderID, mace::EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  ASSERT( iter != eventExecutionInfos.end() );
  // record all executed context names
  return (iter->second).getToContextNames();
}

mace::vector< mace::EventOperationInfo > mace::ContextBaseClass::getLocalLockRequest( mace::OrderID const& eventId ) {
  ADD_SELECTORS("ContextBaseClass::getLocalLockRequest");
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<mace::OrderID, mace::EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  ASSERT( iter != eventExecutionInfos.end() );
  
  return (iter->second).getLocalLockRequest();
}

void mace::ContextBaseClass::removeLocalLockRequest( mace::OrderID const& eventId ) {
  ADD_SELECTORS("ContextBaseClass::removeLocalLockRequest");
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<mace::OrderID, mace::EventExecutionInfo>::iterator iter = getEventExecutionInfo(eventId);
  ASSERT( iter != eventExecutionInfos.end() );
  // record all executed context names
  (iter->second).removeLocalLockRequest();
}


void mace::ContextBaseClass::releaseLock( BaseMaceService* sv, mace::OrderID const& eventId ) {
  ADD_SELECTORS("ContextBaseClass::releaseLock");
  macedbg(1) << "Release lock of event("<< eventId <<") on " << this->contextName << Log::endl;
  int8_t lock_flag;
  
  ScopedLock sl(_context_ticketbooth);
  if( this->readerEvents.count(eventId) > 0 ) {
    lock_flag = mace::ContextLock::RELEASE_READ_MODE;
  } else if(this->writerEvents.count(eventId) > 0 ) {
    lock_flag = mace::ContextLock::RELEASE_WRITE_MODE;
  } else {
    maceerr << "Event("<< eventId <<") doesn't lock " << this->contextName << Log::endl;
    ASSERT(false);
  }
  sl.unlock();

  mace::ContextLock _lock( *this, eventId, true, lock_flag);

  this->getReadyToCommit(sv, eventId, 0);
}

bool mace::ContextBaseClass::checkEventIsLockContext( mace::OrderID const& eventId ) {
  ScopedLock sl(_context_ticketbooth);
  if( this->readerEvents.count(eventId) > 0 || this->writerEvents.count(eventId) > 0 ) {
    return true;
  } else {
    return false;
  }
}

void mace::ContextBaseClass::addReaderEvent(mace::OrderID const& eventId) {
  if( readerEvents.count(eventId) == 0 ) {
    readerEvents.insert(eventId);
  }
}

void mace::ContextBaseClass::addWriterEvent(mace::OrderID const& eventId) {
  if( writerEvents.count(eventId) == 0 ) {
    writerEvents.insert(eventId);
  }
}

void mace::ContextBaseClass::removeReaderEvent(mace::OrderID const& eventId) {
  readerEvents.erase(eventId);
}
void mace::ContextBaseClass::removeWriterEvent(mace::OrderID const& eventId) {
  ADD_SELECTORS("ContextBaseClass::removeWriterEvent");
  macedbg(1) << "context("<< this->contextName <<") removes writer event("<< eventId <<")!" << Log::endl;
  writerEvents.erase(eventId);
}

bool mace::ContextBaseClass::checkReEnterEvent(mace::OrderID const& eventId) const {
  ADD_SELECTORS("ContextBaseClass::checkReEnterEvent");

  if( readerEvents.count(eventId)!=0 || writerEvents.count(eventId) != 0 ) {
    return true;
  } else {
    return false;
  }
}

void mace::ContextBaseClass::notifyExecutedContexts(mace::OrderID const& eventId ) {
  ADD_SELECTORS("ContextBaseClass::notifyExecutedContexts");
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map< mace::OrderID, EventExecutionInfo >::iterator iter = getEventExecutionInfo(eventId);
  ASSERT( iter != eventExecutionInfos.end() );
  mace::set<mace::string> executedContextNames = (iter->second).getToContextsCopy();
  mace::set<mace::string>::iterator sIter = executedContextNames.begin();
  AsyncEventReceiver* sv = BaseMaceService::getInstance(this->serviceId);
  ContextService* _service = static_cast<ContextService*>(sv);
  for(; sIter != executedContextNames.end(); sIter ++ ) {
    const mace::string& ctxName = *sIter;
    if( ctxName == this->contextName ) {
      continue;
    }
    macedbg(1) << "Inform context("<< ctxName <<") to commit event("<< eventId <<") from " << this->contextName << Log::endl;
    _service->send__event_CommitDoneMsg(this->contextName, ctxName, eventId);
  }
  //eventExecutionInfos.erase(iter);
}

mace::map<mace::OrderID, EventExecutionInfo>::iterator ContextBaseClass::getEventExecutionInfo( const mace::OrderID& eventId ){
  ADD_SELECTORS("ContextBaseClass::getEventExecutionInfo");

  mace::map<mace::OrderID, EventExecutionInfo>::iterator iter = eventExecutionInfos.find(eventId);
  if( iter == eventExecutionInfos.end() ){
    for( mace::map<mace::OrderID, EventExecutionInfo>::iterator iter2=eventExecutionInfos.begin(); iter2!=eventExecutionInfos.end(); iter2++ ){
      if( iter2->first == eventId ){
        iter = iter2;
        ASSERTMSG(false, "How this could happen!!!!");
        break;
      }
    }
  }  
  return iter;
}

void ContextBaseClass::deleteEventExecutionInfo( OrderID const& eventId ) { 
  ADD_SELECTORS("ContextBaseClass::deleteEventExecutionInfo");
  macedbg(1) << "Remove event("<< eventId <<") executionInfo in " << this->contextName << Log::endl;
  ScopedLock sl(eventExecutingSyncMutex);
  mace::map<mace::OrderID, EventExecutionInfo>::iterator iter = this->getEventExecutionInfo( eventId );
  if( iter != eventExecutionInfos.end() ){
    eventExecutionInfos.erase(eventId); 
    // deletedEventIds.push_back(eventId);
  }
}

void mace::ContextEventOrder::clear() {
  executeTicketEventMap.clear();
  executeEventTicketMap.clear();
  executeTicketNumber = 1;
}


uint64_t mace::ContextEventOrder::addExecuteEvent(OrderID const& eventId) {
  ADD_SELECTORS("ContextEventOrder::addExecuteEvent");
  ScopedLock sl(eventOrderMutex);
  uint64_t executeTicket = executeTicketNumber ++;
  executeTicketEventMap[executeTicket] = eventId;
  executeEventTicketMap[eventId] = executeTicket;

  macedbg(1) << "Event("<< eventId <<")'s executeTicket=" << executeTicket << " in " << contextName <<Log::endl; 
  return executeTicket;
}

void mace::ContextEventOrder::removeEventExecuteTicket(mace::OrderID const& eventId ) {
  ADD_SELECTORS("ContextEventOrder::removeEventExecuteTicket");
  ScopedLock sl(eventOrderMutex);
  mace::map<OrderID, uint64_t>::iterator o_iter = executeEventTicketMap.find(eventId);
  if( o_iter != executeEventTicketMap.end() ) {
    const uint64_t ticket = o_iter->second;
    executeEventTicketMap.erase(eventId);
    executeTicketEventMap.erase(ticket);
    macedbg(1) << "Delete event("<< eventId <<")'s execute ticket in "<< this->contextName << Log::endl;
  }
}

OrderID mace::ContextEventOrder::getExecuteEventOrderID( const uint64_t ticket ) {
  ScopedLock sl(eventOrderMutex);
  mace::map<uint64_t, OrderID>::iterator iter = executeTicketEventMap.find(ticket);
  if( iter == executeTicketEventMap.end() ) {
    OrderID id;
    return id;
  } else {
    return iter->second;
  }
}

uint64_t mace::ContextEventOrder::getExecuteEventTicket( OrderID const& eventId ) {
  ADD_SELECTORS("ContextEventOrder::getExecuteEventTicket");
  //macedbg(1) << "ContextEventOrder("<< contextName <<") contextEventOrder="<< this <<" eventOrderMutex = " << &eventOrderMutex << Log::endl;
  ScopedLock sl(eventOrderMutex);
  mace::map<OrderID, uint64_t>::const_iterator iter = executeEventTicketMap.find(eventId);
  if( iter == executeEventTicketMap.end() ) {
    return 0;
  } else {
    if( iter->second >= executeTicketNumber ){
      maceerr << "In context("<< this->contextName <<") event("<< eventId <<") executeTicket=" << iter->second << " executeTicketNumber=" << executeTicketNumber << Log::endl;
      ASSERT(false);
    }
    return iter->second;
  }
}

void mace::ContextEventOrder::serialize(std::string& str) const{
  mace::serialize( str, &contextName );
  mace::serialize( str, &executeTicketEventMap );
  mace::serialize( str, &executeEventTicketMap );
  mace::serialize( str, &executeTicketNumber );
}

int mace::ContextEventOrder::deserialize(std::istream & is) throw (mace::SerializationException){
  int serializedByteSize = 0;
  serializedByteSize += mace::deserialize( is, &contextName );
  serializedByteSize += mace::deserialize( is, &executeTicketEventMap   );
  serializedByteSize += mace::deserialize( is, &executeEventTicketMap   );
  serializedByteSize += mace::deserialize( is, &executeTicketNumber   );
  return serializedByteSize;
}

void mace::__EventStorageStruct__::serialize(std::string& str) const{
  mace::serialize( str, &messageType );
  mace::serialize( str, msg );
  mace::serialize( str, &contextEventType );
  mace::serialize( str, &eventOpInfo );
}

int mace::__EventStorageStruct__::deserialize(std::istream & is) throw (mace::SerializationException){
  int serializedByteSize = 0;
  serializedByteSize += mace::deserialize( is, &messageType);
  switch( messageType ) {
    case mace::InternalMessage::ASYNC_EVENT: {
      serializedByteSize += deserializeEvent(is);
      break;
    }
    case mace::InternalMessage::ROUTINE: {
      serializedByteSize += deserializeRoutine(is);
      break;
    }
    case mace::InternalMessage::COMMIT_SINGLE_CONTEXT: {
      msg = InternalMessageHelperPtr( new commit_single_context_Message() );
      serializedByteSize += msg->deserialize(is);
      break;
    }

    default:
      ASSERTMSG(false, "Unkown message type!");
  }
  serializedByteSize += mace::deserialize( is, &contextEventType );
  serializedByteSize += mace::deserialize( is, &eventOpInfo );
  return serializedByteSize;
}

void mace::ContextBaseClassParams::initialize( ContextBaseClass* ctxObj) {
    ADD_SELECTORS("ContextBaseClassParams::initialize");
    macedbg(1) << "context=" << ctxObj->contextName << Log::endl;
    this->contextName = ctxObj->contextName; ///< The canonical name of the context
    this->contextTypeName = ctxObj->contextTypeName;
    this->serviceId = ctxObj->serviceId; ///< The service in which the context belongs to
    this->contextId = ctxObj->contextId;
    
    macedbg(1) << "createQueue=" << ctxObj->createEventQueue.size() << Log::endl;
    while( ctxObj->createEventQueue.size() > 0 ) {
      ContextBaseClass::RQType& createEvent = ctxObj->createEventQueue.front();
      mace::__CreateEventStorage__ mCreateEvent( static_cast<mace::InternalMessageHelperPtr>(createEvent.param), createEvent.eventId, serviceId );
      this->createEventQueue.push_back(mCreateEvent);
      createEvent.param = NULL;
      ctxObj->createEventQueue.pop();
      mCreateEvent.msg = NULL;
    }

    macedbg(1) << "waitingEvents=" << ctxObj->waitingEvents.size() << Log::endl;
    mace::ContextBaseClass::EventStorageType::iterator wIter = ctxObj->waitingEvents.begin();
    for(; wIter != ctxObj->waitingEvents.end(); wIter++ ) {
      mace::vector<mace::__EventStorageStruct__>& wevents = wIter->second;
      for( uint32_t i=0; i<wevents.size(); i++ ){
        mace::__EventStorageStruct__& we = wevents[i];
        this->waitingEvents[ wIter->first ].push_back(we);
        we.msg = NULL;
      }
    }
    
    ASSERT( executeCommitEventQueue.size() == 0 );

    macedbg(1) << "executeQueue=" << ctxObj->executeEventQueue.size() << Log::endl;
    while( ctxObj->executeEventQueue.size() > 0 ){
      mace::ContextEvent& ce = ctxObj->executeEventQueue.front();
      this->executeEventQueue.push_back(ce);
      ce.param = NULL;
      ctxObj->executeEventQueue.pop_front();
    }
    
    this->create_now_committing_ticket = ctxObj->create_now_committing_ticket;
    this->execute_now_committing_eventId = ctxObj->execute_now_committing_eventId;
    this->execute_now_committing_ticket = ctxObj->execute_now_committing_ticket;

    this->now_serving_eventId = ctxObj->now_serving_eventId;
    this->now_serving_execute_ticket = ctxObj->now_serving_execute_ticket;
    
    this->lastWrite = ctxObj->lastWrite;

    this->contextEventOrder = ctxObj->contextEventOrder;
    this->dominator = ctxObj->dominator;

    this->createTicketNumber = ctxObj->createTicketNumber;
    this->executeTicketNumber = ctxObj->executeTicketNumber;

    ASSERT( ctxObj->executedEventsCommitFlag.size() == 0 );
    this->executedEventsCommitFlag = ctxObj->executedEventsCommitFlag;

    this->now_serving_create_ticket = ctxObj->now_serving_create_ticket;
    this->now_max_execute_ticket = ctxObj->now_max_execute_ticket;
        
    this->eventExecutionInfos = ctxObj->eventExecutionInfos;
    this->readerEvents = ctxObj->readerEvents;
    this->writerEvents = ctxObj->writerEvents;
    this->migrationEventWaiting = ctxObj->migrationEventWaiting;

    macedbg(1) << "numReaders=" << this->readerEvents.size() << " numWriters=" << this->writerEvents.size() << Log::endl; 
}

void mace::ContextBaseClassParams::serialize(std::string& str) const{
  mace::serialize(str, &contextName); ///< The canonical name of the context
  mace::serialize(str, &contextTypeName);
  
  mace::serialize(str, &serviceId); ///< The service in which the context belongs to
  mace::serialize(str, &contextId);
  
  mace::serialize(str, &createEventQueue);
  mace::serialize(str, &waitingEvents);

  mace::serialize(str, &executeCommitEventQueue);
  
  mace::serialize(str, &executeEventQueue);

  mace::serialize(str, &create_now_committing_ticket);
  mace::serialize(str, &execute_now_committing_eventId);
  mace::serialize(str, &execute_now_committing_ticket);

  mace::serialize(str, &now_serving_eventId);
  mace::serialize(str, &now_serving_execute_ticket);
  
  mace::serialize(str, &lastWrite);

  mace::serialize(str, &contextEventOrder);
  mace::serialize(str, &dominator);

  mace::serialize(str, &createTicketNumber);
  mace::serialize(str, &executeTicketNumber);

  mace::serialize(str, &executedEventsCommitFlag);
  mace::serialize(str, &now_serving_create_ticket);
  mace::serialize(str, &now_max_execute_ticket);
  
  mace::serialize(str, &eventExecutionInfos);

  mace::serialize(str, &readerEvents);
  mace::serialize(str, &writerEvents);
  mace::serialize(str, &migrationEventWaiting);
}

int mace::ContextBaseClassParams::deserialize(std::istream & is) throw (mace::SerializationException){
  int serializedByteSize = 0;

  serializedByteSize += mace::deserialize(is, &contextName); ///< The canonical name of the context
  serializedByteSize += mace::deserialize(is, &contextTypeName);
  
  serializedByteSize += mace::deserialize(is, &serviceId); ///< The service in which the context belongs to
  serializedByteSize += mace::deserialize(is, &contextId);
  
  serializedByteSize += mace::deserialize(is, &createEventQueue);
  serializedByteSize += mace::deserialize(is, &waitingEvents);

  serializedByteSize += mace::deserialize(is, &executeCommitEventQueue);
  
  serializedByteSize += mace::deserialize(is, &executeEventQueue);
  serializedByteSize += mace::deserialize(is, &create_now_committing_ticket);
  serializedByteSize += mace::deserialize(is, &execute_now_committing_eventId);
  serializedByteSize += mace::deserialize(is, &execute_now_committing_ticket);

  serializedByteSize += mace::deserialize(is, &now_serving_eventId);
  serializedByteSize += mace::deserialize(is, &now_serving_execute_ticket);
  
  serializedByteSize += mace::deserialize(is, &lastWrite);

  serializedByteSize += mace::deserialize(is, &contextEventOrder);
  serializedByteSize += mace::deserialize(is, &dominator);

  serializedByteSize += mace::deserialize(is, &createTicketNumber);
  serializedByteSize += mace::deserialize(is, &executeTicketNumber);

  serializedByteSize += mace::deserialize(is, &executedEventsCommitFlag);
  serializedByteSize += mace::deserialize(is, &now_serving_create_ticket);
  serializedByteSize += mace::deserialize(is, &now_max_execute_ticket);
  
  serializedByteSize += mace::deserialize(is, &eventExecutionInfos);

  serializedByteSize += mace::deserialize(is, &readerEvents);
  serializedByteSize += mace::deserialize(is, &writerEvents);
  serializedByteSize += mace::deserialize(is, &migrationEventWaiting);
  return serializedByteSize;
}

bool LockRequest::enqueueEventOperation( mace::string const& requireContextName, mace::EventOperationInfo const& eventOpInfo ) {
  ADD_SELECTORS("LockRequest::enqueueEventOperation");
  bool exist = false;
  for( uint32_t i=0; i<eventOpInfos.size(); i++ ) {
    mace::pair<EventOperationInfo, bool>& p = eventOpInfos[i];
    if( p.first == eventOpInfo && requireContextName == requireContextNames[i] ){
      exist = true;
    }
  }

  if( !exist ){
    mace::pair<EventOperationInfo, bool> p(eventOpInfo, false);
    eventOpInfos.push_back(p);
    requireContextNames.push_back(requireContextName);
  }

  return true;
}

bool LockRequest::markAsNotified( mace::string const& requireContextName, mace::EventOperationInfo const& eventOpInfo ) {
  for( uint32_t i=0; i<eventOpInfos.size(); i++ ) {
    mace::pair<EventOperationInfo, bool>& p = eventOpInfos[i];
    if( p.first==eventOpInfo && requireContextName==requireContextNames[i] ){
      p.second = true;
      return true;
    }
  }

  return false;
}

bool LockRequest::unlock( mace::EventOperationInfo const& op, mace::string const& requireContextName ) {
  ADD_SELECTORS("LockRequest::unlock");

  EventOperationInfosType::iterator eop_iter;
  mace::vector< mace::string >::iterator r_iter;

  bool unlock_flag = false;
  bool continue_flag = true;

  while( continue_flag ){
    continue_flag = false;
    eop_iter = eventOpInfos.begin();
    r_iter = requireContextNames.begin();
    for( ; eop_iter != eventOpInfos.end(); eop_iter++, r_iter++ ) {
      mace::pair<mace::EventOperationInfo, bool>& p = *eop_iter;
      //const mace::string& rContextName = *r_iter;

      if( p.first == op /*&& rContextName == requireContextName*/ ){
        eventOpInfos.erase(eop_iter);
        requireContextNames.erase(r_iter);
        unlock_flag = true;
        continue_flag = true;
        break;
      } 
    }
  }
  return unlock_flag;
}

void LockRequest::getToNotifyEventOp( mace::vector<EventOperationInfo>& eops, mace::vector<mace::string>& rnames ) const {
  for( uint32_t i=0; i<eventOpInfos.size(); i++ ){
    const mace::pair<mace::EventOperationInfo, bool>& p = eventOpInfos[i];
    const mace::string& rContextName = requireContextNames[i];

    eops.push_back(p.first);
    rnames.push_back(rContextName);
  }
}

void LockRequest::markAllAsNotified() {
  for( uint32_t i=0; i<eventOpInfos.size(); i++ ){
    mace::pair<mace::EventOperationInfo, bool>& p = eventOpInfos[i];
    
    if( !p.second ){
      p.second = true;
    }
  }
}

void mace::LockRequest::serialize(std::string& str) const{
  mace::serialize( str, &lockType );
  mace::serialize( str, &eventId );
  mace::serialize( str, &lockedContextName );
  mace::serialize( str, &requireContextNames );
  mace::serialize( str, &eventOpInfos );
  mace::serialize( str, &hasNotified );
}

int mace::LockRequest::deserialize(std::istream & is) throw (mace::SerializationException){
  int serializedByteSize = 0;
  serializedByteSize += mace::deserialize( is, &lockType );
  serializedByteSize += mace::deserialize( is, &eventId   );
  serializedByteSize += mace::deserialize( is, &lockedContextName   );
  serializedByteSize += mace::deserialize( is, &requireContextNames   );
  serializedByteSize += mace::deserialize( is, &eventOpInfos   );
  serializedByteSize += mace::deserialize( is, &hasNotified   );
  return serializedByteSize;
}

void mace::DominatorRequest::serialize(std::string& str) const{
  mace::serialize( str, &lockType );
  mace::serialize( str, &eventId );
  mace::serialize( str, &ctxName );
  mace::serialize( str, &eventOpInfo );
  mace::serialize( str, &toContextNames );
}

int mace::DominatorRequest::deserialize(std::istream & is) throw (mace::SerializationException){
  int serializedByteSize = 0;
  serializedByteSize += mace::deserialize( is, &lockType );
  serializedByteSize += mace::deserialize( is, &eventId   );
  serializedByteSize += mace::deserialize( is, &ctxName   );
  serializedByteSize += mace::deserialize( is, &eventOpInfo   );
  serializedByteSize += mace::deserialize( is, &toContextNames );
  return serializedByteSize;
}

void ContextEventDominator::initialize( const mace::string& contextName, const mace::vector<mace::string>& dominateCtxs) {
  ADD_SELECTORS("ContextEventDominator::initialize");
  macedbg(1) << "To initialize Dominator("<< contextName <<") with dominateCtxs=" << dominateCtxs << Log::endl;
  ScopedLock sl(dominatorMutex);

  this->contextName = contextName;
  this->dominateContexts = dominateCtxs;
  this->updateDominatorFlag = false;

  this->eventOrderQueue.clear();
  for( uint32_t i=0; i<dominateContexts.size(); i++ ){
    mace::vector<LockRequest> queue;
    eventOrderQueue[ dominateContexts[i] ] = queue;
  }
}

mace::set<mace::string> ContextEventDominator::checkEventExecutePermission(BaseMaceService* sv, mace::string const& requireContextName, 
    mace::EventOperationInfo const& eventOpInfo ) {

  ADD_SELECTORS("ContextEventDominator::checkEventExecutePermission");
  
  
  ContextService* _service = static_cast<ContextService*>(sv);
  const ContextStructure& contextStructure = _service->contextStructure;
  mace::set<mace::string> permittedContextNames;

  ScopedLock sl(dominatorMutex);
  macedbg(2) << "Check "<< eventOpInfo <<" in context "<< this->contextName << Log::endl;

  if( updateDominatorFlag ){ // This dominator is updating
    macedbg(2) << "Keep " << eventOpInfo << " in waitingQueues!" << Log::endl;
    DominatorRequest d_req(DominatorRequest::CHECK_PERMISSION, requireContextName, eventOpInfo);
    waitingDominatorRequests.push_back(d_req);
    return permittedContextNames;
  }


  EventLockQueue::iterator iter = eventOrderQueue.find( eventOpInfo.toContextName );
  if( iter == eventOrderQueue.end() ){
    maceerr << "Fail to find context("<< eventOpInfo.toContextName <<") in " << this->contextName << " dominatedContexts=" << dominateContexts << Log::endl;
    ASSERT(false);
  }
  
  mace::vector<LockRequest>& queue = iter->second;

  uint16_t lockType = LockRequest::INVALID;
  uint16_t vlockType = LockRequest::INVALID;
  if( eventOpInfo.isReadOnly ) {
    lockType = LockRequest::RLOCK;
    vlockType = LockRequest::VRLOCK;
  } else {
    lockType = LockRequest::WLOCK;
    vlockType = LockRequest::VWLOCK;
  }

  bool exit_flag = false;
  for( uint32_t i=0; i<queue.size(); i++ ){
    if( queue[i].eventId == eventOpInfo.eventId ) {
      queue[i].lockType = lockType;
      queue[i].enqueueEventOperation( requireContextName, eventOpInfo );
      exit_flag = true;
      macedbg(2) << "Enqueue lock "<< queue[i] <<" into existing context("<< eventOpInfo.toContextName <<") in dominator("<< this->contextName <<")." << Log::endl;
    }
  }

  if( !exit_flag ){
    LockRequest lockRequest( lockType, eventOpInfo.toContextName, eventOpInfo.eventId );
    lockRequest.enqueueEventOperation( requireContextName, eventOpInfo );
    queue.push_back(lockRequest);
    macedbg(2) << "Enqueue lock "<< lockRequest <<" into context("<< eventOpInfo.toContextName <<") in dominator("<< this->contextName <<")." << Log::endl;
  }

  //enqueue vlock into children contexts' queues
  for( uint32_t i=0; i<dominateContexts.size(); i++ ){
    if( dominateContexts[i] == eventOpInfo.toContextName ){
      continue;
    }

    if( contextStructure.isElderContext(dominateContexts[i], eventOpInfo.toContextName) ){
      iter = eventOrderQueue.find( dominateContexts[i] );
      ASSERT( iter!=eventOrderQueue.end() );
      mace::vector<LockRequest>& queue = iter->second;

      exit_flag = false;
      for( uint32_t j=0; j<queue.size(); j++ ){
        if( queue[j].eventId == eventOpInfo.eventId ) {
          exit_flag = true;
          break;
        }
      }

      if( !exit_flag ){
        LockRequest lockRequest( vlockType, dominateContexts[i], eventOpInfo.eventId );
        macedbg(2) << "Enqueue vlock "<< lockRequest <<" into context("<< dominateContexts[i] <<") in dominator("<< this->contextName <<")." << Log::endl;
        queue.push_back(lockRequest);
      }

    }
  }

  // check contexts the event could access directly
  for( EventLockQueue::iterator iter=eventOrderQueue.begin(); iter != eventOrderQueue.end(); iter++ ) {
    mace::vector<LockRequest>& lockQueue = iter->second;
    for( uint32_t i=0; i<lockQueue.size(); i++ ){
      if( lockQueue[i].eventId == eventOpInfo.eventId ){
        lockQueue[i].hasNotified = true;
        permittedContextNames.insert(iter->first);
        break;
      } else if( lockType == LockRequest::WLOCK || lockQueue[i].lockType == LockRequest::WLOCK || lockQueue[i].lockType == LockRequest::VWLOCK || lockQueue[i].lockType == LockRequest::UNLOCK ){
        break;
      }
    }
  } 

  if( permittedContextNames.count(eventOpInfo.toContextName) == 0 ){
    macedbg(1) << "In dominator("<< this->contextName <<"), lockedContextName=" << eventOpInfo.toContextName <<", events before event("<< eventOpInfo.eventId<<"):" << Log::endl;
    mace::vector<LockRequest>& lockQueue = eventOrderQueue[ eventOpInfo.toContextName ];
    for( uint32_t i=0; i<lockQueue.size(); i++ ){
      macedbg(1) << lockQueue[i] << Log::endl;
    }
  }

  return permittedContextNames;
}

bool ContextEventDominator::checkContextInclusion( mace::string const& ctxName ) {
  ADD_SELECTORS("ContextEventDominator::checkContextInclusion");
  ScopedLock sl(dominatorMutex);
  if( eventOrderQueue.find(ctxName) != eventOrderQueue.end() ) {
    return true;
  } else {
    return false;
  }
}

bool ContextEventDominator::checkContextInclusionNoLock( mace::string const& ctxName ) const {
  ADD_SELECTORS("ContextEventDominator::checkContextInclusionNoLock");
  
  if( eventOrderQueue.find(ctxName) != eventOrderQueue.end() ) {
    return true;
  } else {
    return false;
  }
}

bool ContextEventDominator::unlockContext( ContextStructure& contextStructure, mace::EventOperationInfo const& eventOpInfo,
    mace::string const& requireContextName, mace::set<mace::string> const& toContextNames,
    mace::map< mace::string, mace::map<mace::OrderID, mace::vector<mace::string> > >&  permittedEvents,
    mace::map< mace::string, mace::map<mace::OrderID, mace::vector<mace::EventOperationInfo> > >& permittedEventOps,
    mace::vector<mace::string>& releaseContexts ) {
  
  ADD_SELECTORS("ContextEventDominator::unlockContext");
  ASSERT( contextStructure.getUpperBoundContextName(requireContextName) == this->contextName );
  ASSERT( checkContextInclusion(eventOpInfo.toContextName) );  

  ScopedLock sl(dominatorMutex);
  if( updateDominatorFlag ){ // This dominator is updating
    DominatorRequest d_req(DominatorRequest::UNLOCK_CONTEXT, requireContextName, eventOpInfo, toContextNames );
    waitingDominatorRequests.push_back(d_req);
    return false;
  } 
  

  macedbg(1) << eventOpInfo <<" tries to unlock context("<< eventOpInfo.toContextName <<") in dominator("<< this->contextName <<")!" << Log::endl;
  uint16_t lockType = LockRequest::INVALID;

  if( eventOpInfo.isReadOnly ) {
    lockType = LockRequest::RLOCK;
  } else {
    lockType = LockRequest::WLOCK;
  }

  mace::vector<LockRequest>& queue = eventOrderQueue[eventOpInfo.toContextName];
  bool unlock_flag = false;
  for( uint32_t i=0; i<queue.size(); i++ ){
    LockRequest& lockrequest = queue[i];
    if( lockrequest.eventId == eventOpInfo.eventId && lockrequest.lockType == lockType && lockrequest.unlock(eventOpInfo, requireContextName) ){
      if( lockrequest.getOpNumber() == 0 ) {
        macedbg(1) << "Change lockrequest("<< lockrequest <<") to UNLOCK in " << this->contextName <<Log::endl;
        lockrequest.lockType = LockRequest::UNLOCK;
      }
      unlock_flag = true;
      break;
    }
  }

  if( !unlock_flag ){
    macedbg(1) << "Enqueue lockrequest("<< eventOpInfo <<") to waitingQueue in " << this->contextName <<Log::endl;
    DominatorRequest d_req( DominatorRequest::UNLOCK_CONTEXT, requireContextName, eventOpInfo, toContextNames );
    waitingDominatorRequests.push_back(d_req);
    return false;
  }

  this->checkEventOrderQueue( contextStructure, eventOpInfo.eventId, toContextNames, permittedEvents, permittedEventOps, releaseContexts );
  
  mace::vector<LockRequest>& lockQueue = eventOrderQueue[ eventOpInfo.toContextName ];
  macedbg(1) << "In dominator("<< this->contextName <<"), lockedContextName=" << eventOpInfo.toContextName <<":" << lockQueue.size() << Log::endl;
  for( uint32_t i=0; i<lockQueue.size(); i++ ){
    if( i==0 && lockQueue[i].lockType == LockRequest::UNLOCK ){
      macedbg(1) << "WARNING!!!!" << Log::endl;
    }
    macedbg(1) << lockQueue[i] << Log::endl;
  }
  
  return true;
}

bool ContextEventDominator::releaseContext( ContextStructure& contextStructure, mace::OrderID const& eventId, 
    mace::string const& lockedContextName, mace::set<mace::string> const& toContextNames,
    mace::map< mace::string, mace::map<mace::OrderID, mace::vector<mace::string> > >&  permittedEvents,
    mace::map< mace::string, mace::map<mace::OrderID, mace::vector<mace::EventOperationInfo> > >& permittedEventOps, 
    mace::vector<mace::string>& releaseContexts, mace::set<mace::string>& latestReleasedContexts ) {
  ADD_SELECTORS("ContextEventDominator::releaseContext");

  ASSERT( checkContextInclusion(lockedContextName) );

  ScopedLock sl(dominatorMutex);
  if( updateDominatorFlag ){ // This dominator is updating
    DominatorRequest d_req(DominatorRequest::RELEASE_CONTEXT, lockedContextName, eventId, toContextNames);
    waitingDominatorRequests.push_back(d_req);
    return false;
  }

  mace::vector<LockRequest>& queue = eventOrderQueue[lockedContextName];

  for( mace::vector<LockRequest>::iterator iter=queue.begin(); iter!=queue.end(); iter++ ){
    LockRequest& lockrequest = *iter;
    if( lockrequest.eventId == eventId ){
      macedbg(1) << "Mark LockReuqeust of " << eventId << " as UNLOCK for "<< lockedContextName <<" in " << this->contextName << Log::endl;
      //lockrequest.clearOps();
      lockrequest.lockType = mace::LockRequest::UNLOCK;
      break;
    }
  }
  macedbg(1) << "Event("<< eventId <<") release "<< lockedContextName <<" in dominator("<< this->contextName <<")!" << Log::endl;
  latestReleasedContexts = this->checkEventOrderQueue( contextStructure, eventId, toContextNames, permittedEvents, permittedEventOps, releaseContexts );
  for( uint32_t i=0; i<releaseContexts.size(); i++ ){
    mace::vector<LockRequest>& lockQueue = eventOrderQueue[ releaseContexts[i] ];
    macedbg(1) << "In dominator("<< this->contextName <<"), lockedContextName=" << releaseContexts[i] <<":" << lockQueue.size() << Log::endl;
    for( uint32_t i=0; i<lockQueue.size(); i++ ){
      macedbg(1) << lockQueue[i] << Log::endl;
    }
  }

  return true;
}

mace::set<mace::string> ContextEventDominator::checkEventOrderQueue( ContextStructure& contextStructure, mace::OrderID const& eventId,
    mace::set<mace::string> const& toContextNames,
    mace::map< mace::string, mace::map<mace::OrderID, mace::vector<mace::string> > >&  permittedEvents,
    mace::map< mace::string, mace::map<mace::OrderID, mace::vector<mace::EventOperationInfo> > >& permittedEventOps,
    mace::vector<mace::string>& releaseContexts ) {
  
  ADD_SELECTORS("ContextEventDominator::checkEventOrderQueue");

  // remove vlock & unlock request of eventId from all queues
  mace::set<mace::string> latestContextNames;
  mace::set<mace::string> lockedContextNames; // contexts are locked by event
  for( uint32_t i=0; i<dominateContexts.size(); i++ ){
    bool continue_flag = false;
    for( mace::set<mace::string>::const_iterator cIter = lockedContextNames.begin(); cIter!=lockedContextNames.end(); cIter++ ){
      // if this context's ancestor contexts are locked by event, to ingore this event
      if( contextStructure.isElderContext( dominateContexts[i], *cIter) ) {
        macedbg(1) << "context("<< *cIter <<") is the parent of context("<< dominateContexts[i] <<"). And former context is locked by event("<< eventId <<"). Ignore this queue!" << Log::endl;
        continue_flag = true;
        break;
      }

    }

    if( continue_flag ){
      continue;
    }

    mace::vector<LockRequest>& queue = eventOrderQueue[ dominateContexts[i] ];

    for( mace::vector<LockRequest>::iterator iter=queue.begin(); iter!=queue.end(); iter++ ) {
      LockRequest& lockRequest = *iter;
      if( lockRequest.eventId == eventId ){
        if( lockRequest.lockType == LockRequest::UNLOCK ) {
          latestContextNames.insert( dominateContexts[i] );
          queue.erase(iter);
          macedbg(1) << "Remove UNLOCK of event("<< eventId <<") from " << dominateContexts[i] << " in dominator " << this->contextName << Log::endl;
        } else if( lockRequest.lockType == LockRequest::VRLOCK || lockRequest.lockType == LockRequest::VWLOCK ) {
          if( toContextNames.count( dominateContexts[i] ) == 0 ){
            queue.erase(iter);
            macedbg(2) << "Remove VLOCK of event("<< eventId <<") from " << dominateContexts[i] << " in dominator " << this->contextName << Log::endl;
          }
        } else {
          macedbg(1) << "In Dominator("<< this->contextName <<") event("<< eventId <<") locked " << dominateContexts[i] << Log::endl;
          lockedContextNames.insert( dominateContexts[i] );
        }
        break;
      }
    }
  }

  // check next executing events
  for( uint32_t i=0; i<dominateContexts.size(); i++ ){
    mace::vector<LockRequest>& queue = eventOrderQueue[ dominateContexts[i] ];
    bool first_flag = true;
    for( mace::vector<LockRequest>::iterator iter=queue.begin(); iter!=queue.end(); iter++ ) {
      LockRequest& lockRequest = *iter;
      if( !lockRequest.hasNotified && (lockRequest.lockType == LockRequest::WLOCK || lockRequest.lockType == LockRequest::RLOCK) ) {
        if( !first_flag && lockRequest.lockType == LockRequest::WLOCK ){
          break;
        }

        mace::vector<EventOperationInfo> eops;
        mace::vector<mace::string> rnames;
        lockRequest.getToNotifyEventOp( eops, rnames );
        lockRequest.hasNotified = true;
        ASSERT( eops.size() == rnames.size() );

        for( uint32_t j=0; j<eops.size(); j++ ){
          permittedEvents[ rnames[j] ][ eops[j].eventId ].push_back(dominateContexts[i]);
          permittedEventOps[ rnames[j] ][ eops[j].eventId ].push_back(eops[j]); 
        }
      }
      first_flag = false;
      if( lockRequest.lockType == LockRequest::WLOCK || lockRequest.lockType == LockRequest::VWLOCK || lockRequest.lockType == LockRequest::UNLOCK ){
        break;
      } 
    }
  }


  for( mace::set<mace::string>::iterator iter=latestContextNames.begin(); iter!=latestContextNames.end(); iter++ ) {
    releaseContexts.push_back(*iter);
  }

  return latestContextNames;
}

uint32_t ContextEventDominator::getLockedContextsNumber( mace::OrderID const& eventId ) {
  uint32_t n = 0;
  ScopedLock sl(dominatorMutex);
  for( uint32_t i=0; i<dominateContexts.size(); i++ ){
    mace::vector<LockRequest>& queue = eventOrderQueue[ dominateContexts[i] ];

    for( mace::vector<LockRequest>::iterator iter=queue.begin(); iter!=queue.end(); iter++ ) {
      LockRequest& lockRequest = *iter;
      if( lockRequest.eventId == eventId ){
        n++;
      }
    }
  }
  return n;
}

void mace::ContextEventDominator::serialize(std::string& str) const{
  mace::serialize( str, &contextName );
  mace::serialize( str, &dominateContexts );
  mace::serialize( str, &eventOrderQueue );
}

int mace::ContextEventDominator::deserialize(std::istream & is) throw (mace::SerializationException){
  int serializedByteSize = 0;
  serializedByteSize += mace::deserialize( is, &contextName );
  serializedByteSize += mace::deserialize( is, &dominateContexts   );
  serializedByteSize += mace::deserialize( is, &eventOrderQueue   );
  return serializedByteSize;
}

bool mace::ContextEventDominator::updateDominator( BaseMaceService* sv, mace::map<mace::string, mace::string> const& prePDominators,
    mace::map<mace::string, mace::string> const& preDominators, mace::vector<DominatorRequest>& dominatorRequests) {

  ADD_SELECTORS("ContextEventDominator::updateDominator");
  macedbg(2) << "Update Dominator("<< this->contextName <<") with prePDominators("<< prePDominators <<") and preDominators("<< preDominators <<")!" << Log::endl;
  macedbg(1) << "Update Dominator("<< this->contextName <<")!" << Log::endl;
  ContextService* _service = static_cast<ContextService*>(sv);

  ScopedLock sl(dominatorMutex);
  ASSERT( !updateDominatorFlag );
  updateDominatorFlag = true;
  //waitingDominatorRequests.clear();
    
  ContextStructure& ctxStructure = _service->contextStructure;
  const mace::ContextMapping& snapshot = _service->getLatestContextMapping();
  
  const mace::vector<mace::string> newDominateContexts = ctxStructure.getDominateContexts( this->contextName );
    
  // send queues to new dominators
  mace::map< mace::string, EventLockQueue > sendEventLockQueues;
  for( uint32_t i=0; i<dominateContexts.size(); i++ ){
    const mace::string& ctxName = dominateContexts[i];

    mace::map<mace::string, mace::string>::const_iterator cmIter = prePDominators.find(ctxName);
    mace::string ctxPrePDominator = cmIter->second;

    cmIter = preDominators.find(ctxName);
    mace::string ctxPreDominator = cmIter->second;

    ASSERT( this->contextName == ctxPrePDominator  || this->contextName == ctxPreDominator );

    const mace::string newDominator = ctxStructure.getDominatorContext( ctxName );
    const mace::string newPDominator = ctxStructure.getParentDominatorContext( ctxName );

    if( newDominator == "NULL" || newPDominator == "NULL "){
      continue;
    }
    
    if( this->contextName == ctxPrePDominator  && this->contextName != newPDominator ){
      macedbg(2) << "context("<< ctxName <<") prePDominator=" << ctxPrePDominator << " newPDominator=" << newPDominator << Log::endl;
      macedbg(2) << "context("<< this->contextName <<") send context("<< ctxName <<")'s eventqueue("<< eventOrderQueue[ctxName].size() <<") to the new dominator("<< newPDominator <<")!" << Log::endl;
      if( sendEventLockQueues.find(newPDominator) == sendEventLockQueues.end() ){
        EventLockQueue lock_queues;
        sendEventLockQueues[ newPDominator ] = lock_queues;
      }
      sendEventLockQueues[newPDominator][ctxName] = eventOrderQueue[ctxName];
    }

    if( this->contextName == ctxPreDominator && this->contextName != newDominator){
      macedbg(2) << "context("<< ctxName <<") preDominator=" << ctxPreDominator << " newDominator=" << newDominator << Log::endl;
      macedbg(2) << "context("<< this->contextName <<") send context("<< ctxName <<")'s eventqueue("<< eventOrderQueue[ctxName].size() <<") to the new dominator("<< newDominator <<")!" << Log::endl;
      if( sendEventLockQueues.find(newDominator) == sendEventLockQueues.end() ){
        EventLockQueue lock_queues;
        sendEventLockQueues[ newDominator ] = lock_queues;
      }
      sendEventLockQueues[newDominator][ctxName] = eventOrderQueue[ctxName];
    }
  }

  for( mace::map< mace::string, EventLockQueue >::const_iterator cIter = sendEventLockQueues.begin(); cIter != sendEventLockQueues.end(); cIter ++ ){
    if( ContextMapping::hasContext2( snapshot, cIter->first) == 0){
      continue;
    }

    _service->send__event_updateDominatorEventLockQueues( cIter->first, this->contextName, cIter->second );
  }

  // check waiting event lock queues
  for( uint32_t i=0; i<newDominateContexts.size(); i++ ){
    const mace::string& ctxName = newDominateContexts[i];
    
    mace::string newDominator = ctxStructure.getDominatorContext( ctxName );
    mace::string newPDominator = ctxStructure.getParentDominatorContext( ctxName );

    ASSERT( this->contextName == newPDominator || this->contextName == newDominator );

    mace::map<mace::string, mace::string>::const_iterator cmIter = prePDominators.find(ctxName);
    if( cmIter == prePDominators.end() ) {
      continue;
    }
    mace::string ctxPDominator = cmIter->second;

    cmIter = preDominators.find(ctxName);
    if( cmIter == preDominators.end() ) {
      continue;
    }
    mace::string ctxDominator = cmIter->second;

    if( newPDominator == this->contextName && ctxPDominator!=this->contextName ){
      macedbg(2) << "context("<< ctxName <<") prePDominator=" << ctxPDominator << " newPDominator=" << newPDominator << Log::endl;
      if( waitingContexts.count(ctxPDominator) == 0 && ContextMapping::hasContext2( snapshot, ctxPDominator) > 0 ) {
        waitingContexts.insert( ctxPDominator );
      }
    }

    if( newDominator == this->contextName && ctxDominator!=this->contextName ){
      macedbg(2) << "context("<< ctxName <<") preDominator=" << ctxDominator << " newPDominator=" << newDominator << Log::endl;
      if( waitingContexts.count(ctxDominator) == 0 && ContextMapping::hasContext2( snapshot, ctxDominator) > 0) {
        waitingContexts.insert( ctxDominator );
      }
    }
  }

  macedbg(2) << "context("<< this->contextName <<") wait for eventqueues from " << waitingContexts << Log::endl;

  // remove event lock queues that are not dominated by this context
  dominateContexts = newDominateContexts;
  macedbg(1) << "Dominator("<< this->contextName <<")'s new dominate contexts: " << dominateContexts << Log::endl;

  mace::set<mace::string> dctxs;
  for( uint32_t i=0; i<dominateContexts.size(); i++ ){
    dctxs.insert( dominateContexts[i] );
  }

  bool continue_flag = true;
  while( continue_flag ){
    continue_flag = false;
    for( EventLockQueue::iterator iter = eventOrderQueue.begin(); iter != eventOrderQueue.end(); iter++ ){
      if( dctxs.count(iter->first) == 0 ) {
        // this context is removed from the DAG, to release locked events
        
        if( !ctxStructure.hasContextNode(iter->first) ) {
          maceerr << "context("<< iter->first <<") is removed from DAG!" << Log::endl;
          const mace::vector<LockRequest> queue = iter->second;
          for( uint32_t i=0; i<queue.size(); i++ ) {
            macedbg(1) << "Dominator("<< this->contextName <<") event("<< queue[i].eventId <<") try to release context("<< iter->first <<")!" << Log::endl;
            _service->send__event_releaseLockOnContext( iter->first, this->contextName, queue[i].eventId);
          }
        }
        
        macedbg(1) << "Dominator("<< this->contextName <<") remove context("<< iter->first <<")'s queue!" << Log::endl;
        eventOrderQueue.erase( iter );
        continue_flag = true;
        break;
      }
    }
  }

  dominatorRequests = waitingDominatorRequests;
  return checkAndUpdateEventQueues(_service->contextStructure);
}

bool mace::ContextEventDominator::updateEventQueue( BaseMaceService* sv, mace::string const& src_contextName, 
    mace::ContextEventDominator::EventLockQueue const& lockQueues, mace::vector<DominatorRequest>& dominatorRequests){
  ADD_SELECTORS("ContextEventDominator::updateEventQueue");
  ScopedLock sl(dominatorMutex);
  macedbg(1) << "Dominator("<< this->contextName <<") receive eventqueues("<< lockQueues <<") from " << src_contextName <<" waitingContexts=" << waitingContexts << Log::endl;
  waitingContextsQueues[ src_contextName ] = lockQueues;
  dominatorRequests = waitingDominatorRequests;

  ContextService* _service = static_cast<ContextService*>(sv);
  return checkAndUpdateEventQueues(_service->contextStructure);
}

bool mace::ContextEventDominator::checkAndUpdateEventQueues(ContextStructure& contextStructure) {
  ADD_SELECTORS("ContextEventDominator::checkAndUpdateEventQueues");
  if( updateDominatorFlag && waitingContexts.size() == 0 ) {
    waitingContexts.clear();
    waitingContextsQueues.clear();
    updateDominatorFlag = false;

    for( uint32_t i=0; i<dominateContexts.size(); i++ ){
      if( eventOrderQueue.find(dominateContexts[i]) == eventOrderQueue.end() ) {
        mace::vector<LockRequest> lockqueue;
        
        ASSERT( eventOrderQueue.find(this->contextName) != eventOrderQueue.end() );
        mace::vector<LockRequest>& domLockQueue = eventOrderQueue[ this->contextName ];
        for( uint32_t j=0; j<domLockQueue.size(); j++ ){
          if( domLockQueue[j].lockType == LockRequest::WLOCK ){
            LockRequest lockRequest( LockRequest::VWLOCK, dominateContexts[i], domLockQueue[j].eventId );
            lockqueue.push_back(lockRequest);
          } else if( domLockQueue[j].lockType == LockRequest::RLOCK ){
            LockRequest lockRequest( LockRequest::VRLOCK, dominateContexts[i], domLockQueue[j].eventId );
            lockqueue.push_back(lockRequest);
          }
        }
        eventOrderQueue[ dominateContexts[i] ] = lockqueue;
        macedbg(1) << "Dominator("<< this->contextName <<") add context("<< dominateContexts[i] <<")'s queue!" << Log::endl;
      }
    }

    macedbg(1) << "Dominator("<< this->contextName <<") needn't wait for any eventqueues!" << Log::endl;
    return true;
  }

  if( !updateDominatorFlag || waitingContexts.size() != waitingContextsQueues.size() ){
    return false;
  }

  for( mace::set<mace::string>::iterator iter = waitingContexts.begin(); iter!=waitingContexts.end(); iter++ ){
    if( waitingContextsQueues.find(*iter) == waitingContextsQueues.end() ) {
      macedbg(1) << "ERROR: fail to find eventqueues from " << *iter << Log::endl;
      return false;
    }
  }

  macedbg(1) << "To update the dominator " << this->contextName << Log::endl;
  for( mace::set<mace::string>::iterator iter = waitingContexts.begin(); iter!=waitingContexts.end(); iter++ ){
    EventLockQueue& lockQueues = waitingContextsQueues[ *iter ];
    for( EventLockQueue::iterator newIter = lockQueues.begin(); newIter!=lockQueues.end(); newIter++ ){
      macedbg(1) << "context("<< newIter->first <<")'s queue("<< (newIter->second).size() <<") from " << *iter << Log::endl;
      if( eventOrderQueue.find(newIter->first) != eventOrderQueue.end() ) { // there are two queues for the same context
        macedbg(1) << "There are two queues of context("<< *iter <<") in dominator " << this->contextName << Log::endl;

        if( eventOrderQueue[newIter->first].size() == 0 ) {
          eventOrderQueue[newIter->first] = newIter->second;
          continue;
        }

        if( *iter == newIter->first ){
          mace::vector<LockRequest>& oldQueue = eventOrderQueue[newIter->first];
          mace::vector<LockRequest>& newQueue = newIter->second;

          // if one event is labeled as UNLOCK, it should be unlock
          for( uint32_t m=0; m<oldQueue.size(); m++ ){
            if( oldQueue[m].lockType == LockRequest::UNLOCK ){
              for( uint32_t n=0; n<newQueue.size(); n++ ){
                if( newQueue[n].eventId == oldQueue[m].eventId ){
                  newQueue[n].lockType = LockRequest::UNLOCK;
                  break;
                }
              }
            }
          }

          eventOrderQueue[ newIter->first ] = newQueue;
        } else {
          mace::vector<LockRequest>& oldQueue = newIter->second;
          mace::vector<LockRequest>& newQueue = eventOrderQueue[newIter->first];

          // if one event is labeled as UNLOCK, it should be unlock
          for( uint32_t m=0; m<oldQueue.size(); m++ ){
            if( oldQueue[m].lockType == LockRequest::UNLOCK ){
              for( uint32_t n=0; n<newQueue.size(); n++ ){
                if( newQueue[n].eventId == oldQueue[m].eventId ){
                  newQueue[n].lockType = LockRequest::UNLOCK;
                  break;
                }
              }
            }
          }

        }
      } else {
        eventOrderQueue[ newIter->first ] = newIter->second;
      }
    }
  }

  for( uint32_t i=0; i<dominateContexts.size(); i++ ){
    if( eventOrderQueue.find(dominateContexts[i]) == eventOrderQueue.end() ) {
      mace::vector<LockRequest> lockqueue;
      eventOrderQueue[ dominateContexts[i] ] = lockqueue;
      macedbg(1) << "Dominator("<< this->contextName <<") add context("<< dominateContexts[i] <<")'s queue!" << Log::endl;
    }
  }

  //remove unnecessary lockrequests
  mace::map< mace::OrderID, mace::set<mace::string> > lockedContextNames; // contexts are locked by event
  mace::map< mace::OrderID, mace::set<mace::string> > existContextNames;
  for( uint32_t i=0; i<dominateContexts.size(); i++ ){
    mace::vector<LockRequest>& queue = eventOrderQueue[ dominateContexts[i] ];

    for( mace::vector<LockRequest>::iterator iter=queue.begin(); iter!=queue.end(); iter++ ) {
      LockRequest& lockRequest = *iter;
      
      existContextNames[ lockRequest.eventId ].insert( dominateContexts[i] );
      if( lockRequest.lockType == LockRequest::RLOCK || lockRequest.lockType == LockRequest::WLOCK ){
        lockedContextNames[ lockRequest.eventId ].insert( dominateContexts[i] );
      }
    }
  }

  for( uint32_t i=0; i<dominateContexts.size(); i++ ){
    mace::vector<LockRequest>& queue = eventOrderQueue[ dominateContexts[i] ];

    bool continue_flag = true;
    while( continue_flag ){
      continue_flag = false;
      for( mace::vector<LockRequest>::iterator iter=queue.begin(); iter!=queue.end(); iter++ ) {
        LockRequest& lockRequest = *iter;
        if( lockRequest.lockType == LockRequest::VRLOCK || lockRequest.lockType == LockRequest::VWLOCK ){
          if( lockedContextNames.find(lockRequest.eventId) == lockedContextNames.end() ){
            macedbg(1) << "Remove " << *iter << " from lockedContext("<< dominateContexts[i] <<") in " << this->contextName << Log::endl;
            queue.erase(iter);
            continue_flag = true;
            break;
          } else {
            mace::set< mace::string >& lockedCtxNames = lockedContextNames[ lockRequest.eventId ];
            mace::set< mace::string >::iterator sIter = lockedCtxNames.begin();
            for( ; sIter != lockedCtxNames.end(); sIter ++ ){
              if( contextStructure.isElderContext(dominateContexts[i], *sIter) ){
                break;
              }
            }
            if( sIter == lockedCtxNames.end() ){
              macedbg(1) << "Remove " << *iter << " from lockedContext("<< dominateContexts[i] <<") in " << this->contextName << Log::endl;
              queue.erase(iter);
              continue_flag = true;
              break;
            }

          }
        }
      }
    }
  }

  // add new vlock
  mace::vector<LockRequest>& queue = eventOrderQueue[ this->contextName ];
  for( uint32_t i=0; i<queue.size(); i++ ){
    LockRequest& lrequest = queue[i];
    if( lrequest.lockType == LockRequest::WLOCK || lrequest.lockType == LockRequest::RLOCK ) {
      for( uint32_t j=0; j<dominateContexts.size(); j++ ){
        if( dominateContexts[j] == this->contextName ){
          continue;
        }

        if( existContextNames[lrequest.eventId].count(dominateContexts[j]) == 0 ){
          uint16_t vlockType;
          if( lrequest.lockType == LockRequest::WLOCK ){
            vlockType = LockRequest::VWLOCK;
          } else {
            vlockType = LockRequest::VRLOCK;
          }

          LockRequest lockRequest( vlockType, dominateContexts[j], lrequest.eventId );
          macedbg(1) << "Enqueue vlock "<< lockRequest <<" into context("<< dominateContexts[j] <<") in dominator("<< this->contextName <<")." << Log::endl;
          eventOrderQueue[ dominateContexts[j] ].push_back(lockRequest);
        }
      }
    }
  }

  printEventQueues();
  updateDominatorFlag = false;
  waitingContexts.clear();
  waitingContextsQueues.clear();

  
  return true;
}

void mace::ContextEventDominator::adjustEventQueue() {
  ADD_SELECTORS("ContextEventDominator::adjustEventQueue");

}

mace::vector<DominatorRequest> mace::ContextEventDominator::checkWaitingDominatorRequests( mace::OrderID const& eventId ) {
  ADD_SELECTORS("ContextEventDominator::checkWaitingDominatorRequests");
  macedbg(1) << "Check delay requests for " << eventId << Log::endl;
  ScopedLock sl( dominatorMutex );
  mace::vector<DominatorRequest> dominatorRequests;

  if( updateDominatorFlag || waitingDominatorRequests.size() == 0 ){
    return dominatorRequests;
  }


  bool continue_flag = true;
  while(continue_flag) {
    continue_flag = false;
    mace::vector<DominatorRequest>::iterator iter;
    for( iter = waitingDominatorRequests.begin(); iter != waitingDominatorRequests.end(); iter++ ){
      const DominatorRequest& request = *iter;
      if( request.lockType == DominatorRequest::UNLOCK_CONTEXT && request.eventOpInfo.eventId == eventId ){
        continue_flag = true;
        dominatorRequests.push_back( request );
        waitingDominatorRequests.erase(iter);
        break;
      }
    }
  }
  return dominatorRequests;
}

void mace::ContextEventDominator::printEventQueues() {
  ADD_SELECTORS("ContextEventDominator::printEventQueues");
  for( EventLockQueue::iterator iter = eventOrderQueue.begin(); iter!=eventOrderQueue.end(); iter++ ){
    macedbg(1) << "context("<< iter->first <<") queue: " << Log::endl;
    mace::vector<LockRequest>& lockqueue = iter->second;
    for( uint32_t i=0; i<lockqueue.size(); i++ ){
      macedbg(1) << lockqueue[i] << Log::endl;
    }
  }

}

template<class T> pthread_mutex_t ObjectPool< T >::lock = PTHREAD_MUTEX_INITIALIZER;

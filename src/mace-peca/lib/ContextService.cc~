#include "ContextService.h"
#include "ScopedContextRPC.h"
#include "ReadLine.h"
#include "AccessLine.h"
#include "params.h"
#include "HeadEventDispatch.h"
#include "ContextLock.h"

using mace::ReadLine;

mace::vector< mace::string > mace::__CheckMethod__::nullNames;

std::map< uint64_t, std::set< pthread_cond_t* > > ContextService::contextWaitingThreads;
std::map< mace::string, std::set< pthread_cond_t* > > ContextService::contextWaitingThreads2;
std::map< mace::OrderID, std::set< pthread_cond_t* > > ContextService::contextWaitingThreads3;
std::map< uint64_t, std::set< pthread_cond_t* > > ContextService::contextMappingUpdateWaitingThreads;
std::map< uint64_t, std::vector< PthreadCondPointer > > ContextService::contextStructureUpdateWaitingThreads;
std::map< uint64_t, pthread_cond_t* > ContextService::externalMsgWaitingThread;

pthread_mutex_t ContextService::waitExitMutex = PTHREAD_MUTEX_INITIALIZER;;
pthread_cond_t ContextService::waitExitCond = PTHREAD_COND_INITIALIZER;;

mace::vector< mace::pair<mace::string, mace::string> > ContextStructure::initialContextOwnerships;

const uint8_t ContextStructure::READER;
const uint8_t ContextStructure::WRITER;

void ContextService::acquireContextLocks(uint32_t const  targetContextID, mace::vector<uint32_t> const & snapshotContextIDs) const {
    mace::map< MaceAddr, mace::vector< uint32_t > > ancestorContextNodes;
    acquireContextLocksCommon(targetContextID, snapshotContextIDs, ancestorContextNodes );
    
    for( mace::map< MaceAddr, mace::vector< uint32_t > >::iterator nodeIt = ancestorContextNodes.begin(); nodeIt != ancestorContextNodes.end(); nodeIt ++ ){
      mace::InternalMessage msg( mace::enter_context , ThreadStructure::myEvent(), nodeIt->second );

      sender->sendInternalMessage( nodeIt->first, msg );
    }
}
void ContextService::acquireContextLocksCommon(uint32_t const targetContextID, mace::vector<uint32_t> const& snapshotContextIDs, mace::map< MaceAddr, mace::vector< uint32_t > >& ancestorContextNodes) const{
  ADD_SELECTORS("ContextService::acquireContextLocksCommon");
  /*
  const mace::ContextMapping& snapshotMapping = contextMapping.getSnapshot();
  mace::Event::EventContextType const& allContexts = ThreadStructure::getEventContexts( );
  mace::Event::EventContextType::const_iterator allContextsIterator = allContexts.find( instanceUniqueID );
  //ASSERT( allContextsIterator != allContexts.end() );
  const bool hasContexts = ( allContextsIterator != allContexts.end() ); 
  const mace::Event::EventServiceContextType& eventContexts =  allContextsIterator->second;

  mace::Event::EventSnapshotContextType const& allSnapshots = ThreadStructure::getEventSnapshotContexts( );
  mace::Event::EventSnapshotContextType::const_iterator allSnapshotsIterator = allSnapshots.find( instanceUniqueID );

  const bool hasSnapshot = ( allSnapshotsIterator == allSnapshots.end() )?false:true;

  const mace::Event::EventServiceSnapshotContextType& eventSnapshot =  allSnapshotsIterator->second;
  mace::set< uint32_t > ancestorContextIDs;
  if( targetContextID == 1 ){ // the target is global context. no ancestor
  }else{
    uint32_t nowID = targetContextID;
    do{
     uint32_t parentID = snapshotMapping.getParentContextID( nowID );
     if( (hasContexts && eventContexts.find( parentID ) == eventContexts.end()) && (hasSnapshot && eventSnapshot.find( parentID ) == eventSnapshot.end() ) ){
       ancestorContextIDs.insert( parentID );
     }else{
       break;
     }
     nowID = parentID;
    }while( nowID != 1 ); // loop until reaching the global (root) context
  }

  for(mace::vector<uint32_t>::const_iterator scIt = snapshotContextIDs.begin(); scIt != snapshotContextIDs.end(); scIt++ ){
    uint32_t nowID = *scIt;
    do{
     if( (hasContexts && eventContexts.find( nowID ) == eventContexts.end() ) && 
       (hasSnapshot && eventSnapshot.find( nowID ) == eventSnapshot.end() ) &&
       ancestorContextIDs.find( nowID ) == ancestorContextIDs.end()   ){
       ancestorContextIDs.insert( nowID );
     }else{
       break;
     }
     if( nowID == 1 ){ break; }
     nowID = snapshotMapping.getParentContextID( nowID );
    }while( true ); // loop until reaching the global (root) context
  }
  
  std::for_each( ancestorContextIDs.begin(), ancestorContextIDs.end(), ThreadStructure::insertEventContext );
  */
}
void ContextService::doDeleteContext( mace::string const& contextName  ){
  ADD_SELECTORS("ContextService::doDeleteContext");
  mace::Event& newEvent = ThreadStructure::myEvent();
  // must be head
  ASSERT( isLocal( this->contextMapping.getHead() ) );
  newEvent.newEventID( mace::Event::DELETECONTEXT );
  newEvent.initialize(  );
  mace::AgentLock lock( mace::AgentLock::WRITE_MODE ); // global lock is used to ensure new events are created in order

  const mace::ContextMapping* snapshotContext = & ( contextMapping.getSnapshot( newEvent.getLastContextMappingVersion() ) );
  uint32_t contextID = mace::ContextMapping::hasContext2( *snapshotContext, contextName );
  if( contextID == 0 ){ // context not found
    maceerr<<"Context '"<< contextName <<"' does not exist. Ignore delete request"<< Log::endl;
    lock.downgrade( mace::AgentLock::READ_MODE );
    HeadEventDispatch::HeadEventTP::commitEvent( newEvent ); // commit
    return;
  }

  //mace::Event::setLastContextMappingVersion( newEvent.eventId );
  //newEvent.eventContextMappingVersion = newEvent.eventID;

  mace::MaceAddr removeMappingReturn = contextMapping.removeMapping( contextName );
  const mace::ContextMapping* ctxmapCopy =  contextMapping.snapshot( newEvent.eventContextMappingVersion ) ; // create ctxmap snapshot
  ASSERT( ctxmapCopy != NULL );

  contextEventRecord.deleteContextEntry( contextName, contextID, newEvent.eventId );
  //newEvent.setSkipID( instanceUniqueID, contextID, newEvent.eventID );
  //mace::Event::EventSkipRecordType & skipIDStorage = newEvent.getPreEventIdsStorage( instanceUniqueID );
  //skipIDStorage.set( contextID, newEvent.eventId );

  BaseMaceService::globalNotifyNewContext( newEvent, instanceUniqueID );

  send__event_RemoveContextObject( newEvent.eventId, *ctxmapCopy, removeMappingReturn, contextID );
  BaseMaceService::globalNotifyNewEvent( newEvent, instanceUniqueID );

  lock.downgrade( mace::AgentLock::READ_MODE ); // downgrade to read mode to allow later events to enter.
}
void ContextService::handle__event_RemoveContextObject( mace::OrderID const eventID, mace::ContextMapping const& ctxmapCopy, 
      MaceAddr const& dest, uint32_t const& contextID ){
    ThreadStructure::setEventID( eventID );
    ThreadStructure::myEvent().eventType = mace::Event::DELETECONTEXT;
    mace::ContextBaseClass *thisContext = getContextObjByID( contextID ); 
    // make sure previous events have released the context.
    mace::ContextLock ctxlock( *thisContext, ThreadStructure::myEventID(), false, mace::ContextLock::WRITE_MODE );
    ctxlock.downgrade( mace::ContextLock::NONE_MODE );
    eraseContextData( thisContext );// erase the context from this node.

    // TODO: commit the delete context event
}
void ContextService::copyContextData(mace::ContextBaseClass* thisContext, mace::string& s ) const{
    mace::serialize(s, thisContext );
}
void ContextService::eraseContextData(mace::ContextBaseClass* thisContext){
    ADD_SELECTORS("ContextService::eraseContextData");
    uint32_t contextID = thisContext->getID();
    mace::string contextName = thisContext->getName();
    // (2) remove the context object from ctxobjIDMap & ctxobjNameMap
    ScopedLock sl(getContextObjectMutex);
    macedbg(1)<<"Erase context object '" << contextName << "'"<<Log::endl;
    // (1) erase the context object
    delete thisContext;

    ASSERT( contextID < ctxobjIDMap.size() && ctxobjIDMap[ contextID ] != NULL );
    ctxobjIDMap[ contextID ] = NULL;


    mace::hash_map< mace::string, mace::ContextBaseClass*, mace::SoftState >::const_iterator cpIt2 = ctxobjNameMap.find( contextName );
    ASSERT( cpIt2 != ctxobjNameMap.end() );
    ctxobjNameMap.erase( cpIt2 );
}

void ContextService::handleInternalMessages( mace::InternalMessage const& message, MaceAddr const& src ){
  ADD_SELECTORS("ContextService::handleInternalMessages");
  switch( message.getMessageType() ){
    case mace::InternalMessage::UNKNOWN: break;
    case mace::InternalMessage::ALLOCATE_CONTEXT_OBJECT: {
      mace::AllocateContextObject_Message* m = static_cast< mace::AllocateContextObject_Message* >( message.getHelper() );
      handle__event_AllocateContextObject( src, m->destNode, m->contextId, m->eventId, m->contextMapping, m->eventType, m->version );
      break;
    }
		case mace::InternalMessage::ALLOCATE_CONTEXT_OBJ_RESPONSE: {
			mace::AllocateContextObjectResponse_Message* m = static_cast<mace::AllocateContextObjectResponse_Message*>( message.getHelper() );
			handle__event_AllocateContextObjectResponse(m->ctx_name, m->eventId, m->isCreateContextEvent );
			break;
		}
		case mace::InternalMessage::ALLOCATE_CONTEXT_OBJ_REQ: {
      mace::AllocateContextObjReq_Message* m = static_cast<mace::AllocateContextObjReq_Message* >( message.getHelper() );
			handle__event_AllocateContextObjReq( m->ctxName, m->eventId, m->parentCtxName, m->policyEntry, src );
      message.unlinkHelper();
			break;
		}
		case mace::InternalMessage::UPDATE_CONTEXT_MAPPING: {
			mace::UpdateContextMapping_Message* m = static_cast<mace::UpdateContextMapping_Message*>(message.getHelper());
			handle__event_UpdateContextMapping( m->ctxMapping, m->ctxName );
			break;
		}
    case mace::InternalMessage::COMMIT_DONE: {
      mace::CommitDone_Message* m = static_cast<mace::CommitDone_Message*>(message.getHelper());
      macedbg(1) << "Received a commit_done control message for " << message.getTargetContextName() << Log::endl;
      mace::ContextBaseClass* ctxObj = getContextObjByName(message.getTargetContextName());
      ASSERT( ctxObj != NULL );
      if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
        handle__event_CommitDone( m->target_ctx_name, m->eventId, message, src );
        ctxObj->decreaseHandlingMessageNumber();
      }
      break;
    }
    case mace::InternalMessage::CONTEXT_OWNERSHIP_CONTROL: {
      mace::ContextOwnershipControl_Message* m = static_cast<mace::ContextOwnershipControl_Message*>( message.getHelper());
      if( m->type == mace::ContextOwnershipControl_Message::OWNERSHIP_MODIFY ) {
        const mace::vector<mace::EventOperationInfo>& eops = m->ownershipOpInfos;
        const mace::EventOperationInfo& eop = eops[0];
        mace::vector<mace::EventOperationInfo> ownershipOpInfos;
        for( uint32_t i=1; i<eops.size(); i++ ){
          ownershipOpInfos.push_back( eops[i] );
        }

        handle__event_modifyOwnership( eop, m->src_contextName, ownershipOpInfos );
      } else if( m->type == mace::ContextOwnershipControl_Message::OWNERSHIP_UPDATE ) {
        handle__event_updateOwnership( m->ownerships, m->contextNames, m->ver);
      } else if( m->type == mace::ContextOwnershipControl_Message::OWNERSHIP_UPDATE_REQUEST ) {
        const mace::ContextMapping& snapshot = getLatestContextMapping();
        ASSERT( Util::getMaceAddr() == mace::ContextMapping::getHead(snapshot) );

        mace::vector< mace::pair<mace::string, mace::string> > ownerships = contextStructure.getAllOwnerships();
        const uint64_t ver = contextStructure.getCurrentVersion();
        mace::set<mace::string> emptyCtxNames;
        send__event_updateOwnership( src, emptyCtxNames, ownerships, ver);
      } else if( m->type == mace::ContextOwnershipControl_Message::OWNERSHIP_MODIFY_DONE ) {
        if( m->dest_contextName == ""){
          //this->contextStructure.releaseLock(ContextStructure::WRITER);
        } else {
          mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
          if( ctxObj == NULL ) {
            macedbg(1) << "Fail to find Context("<< m->dest_contextName <<")!!!" << Log::endl;
            ASSERT(false);
          }
          ctxObj->handleOwnershipOperationsReply(m->ownershipOpInfos[0]);
        }
      } else if( m->type == mace::ContextOwnershipControl_Message::OWNERSHIP_UPDATE_DONE ) {
        const mace::ContextMapping& snapshot = getLatestContextMapping();
        ASSERT( Util::getMaceAddr() == mace::ContextMapping::getHead(snapshot) );
        HeadEventDispatch::HeadEventTP::handleContextOwnershipUpdateReply( m->contextNames );
      } else if( m->type == mace::ContextOwnershipControl_Message::OWNERSHIP_AND_DOMINATOR_UPDATE) {
        handle__event_updateOwnershipAndDominators( m->ownerships, m->contextNames, m->ver, m->prePDominators, m->preDominators);
      } else if( m->type == mace::ContextOwnershipControl_Message::DOMINATOR_LOCK_QUEUE_UPDATE) {
        mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
        if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
          ctxObj->updateEventQueue(this, m->src_contextName, m->eventLockQueues);
          ctxObj->decreaseHandlingMessageNumber();
        }
      }
      break;
    }
    case mace::InternalMessage::CONTEXT_POLICY_CONTROL: {
      mace::ContextPolicyControl_Message* m = static_cast<mace::ContextPolicyControl_Message*>( message.getHelper() );
      if( m->control_type == mace::ContextPolicyControl_Message::ADD_NEW_POLICY ) {
        mace::ContextMapping::createNewContextPolicy( m->contextName, m->policyEntry);
      }
    }
    case mace::InternalMessage::CONTEXTMAPPING_UPDATE_SUGGEST: {
      mace::ContextMappingUpdateSuggest_Message* m = static_cast<mace::ContextMappingUpdateSuggest_Message*>(message.getHelper() );
      handle__event_contextmapping_update_suggest(m->expectVersion);
      break;
    }
    case mace::InternalMessage::EXTERNALCOMM_CONTROL:{
      mace::ExternalCommControl_Message* m = static_cast< mace::ExternalCommControl_Message*>( message.getHelper() );
      handle__event_ExternalCommControl(m);
      break;
    }
    case mace::InternalMessage::CONTEXT_MIGRATION_REQUEST:{
      mace::ContextMigrationRequest_Message* m = static_cast< mace::ContextMigrationRequest_Message* >( message.getHelper() );
      handle__event_ContextMigrationRequest( src, m->dest, m->event, m->prevContextMapVersion, m->migrateContextIds, m->contextMapping );
      break;
    }
    case mace::InternalMessage::TRANSFER_CONTEXT:{
      mace::TransferContext_Message* m = static_cast< mace::TransferContext_Message* >( message.getHelper() );
      handle__event_TransferContext( src, m->ctxParams, m->checkpoint, m->eventId );
      break;
    }
    case mace::InternalMessage::MIGRATION_CONTROL: {
      mace::MigrationControl_Message* m = static_cast< mace::MigrationControl_Message* >(message.getHelper() );
      handle__event_MigrationControl( m );
      break;
    }
    case mace::InternalMessage::CREATE:{
      mace::create_Message* m = static_cast< mace::create_Message* >( message.getHelper() );
      handle__event_create( src, m->extra, m->counter, m->create_ctxId );
      break;
    }
    case mace::InternalMessage::CREATE_HEAD:{
      mace::create_head_Message* m = static_cast< mace::create_head_Message* >( message.getHelper() );
      handle__event_create_head( m->extra, m->counter, m->src );
      break;
    }
    case mace::InternalMessage::CREATE_RESPONSE:{
      mace::create_response_Message* m = static_cast< mace::create_response_Message* >( message.getHelper() );
      handle__event_create_response( m->event , m->counter , m->targetAddress);
      break;
    }
    case mace::InternalMessage::EXIT_COMMITTED:{
      handle__event_exit_committed(  );
      break;
    }
    case mace::InternalMessage::ENTER_CONTEXT:{
      mace::enter_context_Message* m = static_cast< mace::enter_context_Message* >( message.getHelper() );
      handle__event_enter_context( m->event, m->contextIDs );
      break;
    }
    case mace::InternalMessage::COMMIT:{
      mace::commit_Message* m = static_cast< mace::commit_Message* >( message.getHelper() );
      macedbg(1) << "Received a commit message for " << message.getTargetContextName() << Log::endl;
      if( message.getTargetContextName() == "" ) {
        mace::Event event = m->event;
        handle__event_commit( event, message, src );
        return;
      }
      mace::ContextBaseClass* ctxObj = getContextObjByName(message.getTargetContextName());
      if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
        mace::Event event = m->event;
        handle__event_commit( event, message, src );
        ctxObj->decreaseHandlingMessageNumber();
      }  
      break;
    }
    case mace::InternalMessage::SNAPSHOT:{
      mace::snapshot_Message* m = static_cast< mace::snapshot_Message* >( message.getHelper() );
      handle__event_snapshot( m->event , m->ctxID , m->snapshotContextID , m->snapshot);
      break;
    }
    case mace::InternalMessage::DOWNGRADE_CONTEXT:{
      mace::downgrade_context_Message* m = static_cast< mace::downgrade_context_Message* >( message.getHelper() );
      handle__event_downgrade_context( m->contextID , m->eventID , m->isresponse);
      break;
    }
    case mace::InternalMessage::EVICT:{
      handle__event_evict( src );
      break;
    }
    case mace::InternalMessage::MIGRATE_CONTEXT:{
      mace::migrate_context_Message* m = static_cast< mace::migrate_context_Message* >( message.getHelper() );
      handle__event_migrate_context( m->newNode, m->contextName, m->delay );
      break;
    }
    case mace::InternalMessage::MIGRATE_PARAM:{
      mace::migrate_param_Message* m = static_cast< mace::migrate_param_Message* >( message.getHelper() );
      handle__event_migrate_param( m->paramid  );
      break;
    }
    case mace::InternalMessage::REMOVE_CONTEXT_OBJECT:{
      mace::RemoveContextObject_Message* m = static_cast< mace::RemoveContextObject_Message* >( message.getHelper() );
      handle__event_RemoveContextObject( m->eventID , m->ctxmapCopy , m->dest , m->contextID);
      break;
    }
    case mace::InternalMessage::DELETE_CONTEXT:{
     mace::delete_context_Message* m = static_cast< mace::delete_context_Message* >( message.getHelper() );
     handle__event_delete_context( m->contextName  );
      break;
    }
    case mace::InternalMessage::NEW_HEAD_READY:{
      handle__event_new_head_ready( src  );
      break;
    }
    case mace::InternalMessage::ROUTINE_RETURN:{
      mace::routine_return_Message* m = static_cast< mace::routine_return_Message* >( message.getHelper() );
      handle__event_routine_return( m->returnValue, m->event  );
      break;
    }
    case mace::InternalMessage::ASYNC_EVENT:{
      mace::AsyncEvent_Message* h = static_cast< mace::AsyncEvent_Message*>( message.getHelper() );
      macedbg(1) << "Received an async message for " << message.getTargetContextName() << Log::endl;
      mace::ContextBaseClass* ctxObj = getContextObjByName(message.getTargetContextName());

      if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
        handleEventMessage( h, message, src );
        message.unlinkHelper();
        ctxObj->decreaseHandlingMessageNumber();
      }
      break;
    }
    case mace::InternalMessage::APPUPCALL:{
      mace::ApplicationUpcall_Message* m = static_cast< mace::ApplicationUpcall_Message* >( message.getHelper() );
      processRPCApplicationUpcall( m, src );
      break;
    }
    case mace::InternalMessage::APPUPCALL_RETURN:{
      mace::appupcall_return_Message* m = static_cast< mace::appupcall_return_Message* >( message.getHelper() );
      handle__event_appupcall_return( m->returnValue, m->event  );
      break;
    }
    case mace::InternalMessage::ROUTINE:{
      mace::Routine_Message* m = static_cast< mace::Routine_Message* >( message.getHelper() );

      mace::ContextBaseClass* ctxObj = getContextObjByName(message.getTargetContextName());
      if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
        handleRoutineMessage( m, src, message );
        message.unlinkHelper();
        ctxObj->decreaseHandlingMessageNumber();
      }
      break;
    }
    case mace::InternalMessage::TRANSITION_CALL:{
     mace::Routine_Message* m = static_cast< mace::Routine_Message* >( message.getHelper() );
      handleRoutineMessage( m, src, message );
      break;
    }
    case mace::InternalMessage::NEW_EVENT_REQUEST:{
      mace::AsyncEvent_Message* h = static_cast< mace::AsyncEvent_Message*>( message.getHelper() );
      addTimerEvent( h );
      message.unlinkHelper();
      break;
    }
    case mace::InternalMessage::CONTEXTMAPPING_UPDATE_REQ : {
      mace::ContextMappingUpdateReq_Message* m = static_cast<mace::ContextMappingUpdateReq_Message*>(message.getHelper());
      handle__event_contextmapping_update_req(m->expectVersion, src);
      break;
    }
    case mace::InternalMessage::EVENT_EXECUTION_CONTROL: {
      mace::EventExecutionControl_Message* m = static_cast<mace::EventExecutionControl_Message*>( message.getHelper() );
      if( m->control_type == mace::EventExecutionControl_Message::COMMIT_CONTEXTS ) {
        handle__event_commit_contexts(m->contextNames, m->src_contextName, m->eventId, src, src);
      } else if( m->control_type == mace::EventExecutionControl_Message::COMMIT_CONTEXT ) {
        mace::vector<mace::string> ctxNames;
        ctxNames.push_back(m->dest_contextName);
        handle__event_commit_contexts(ctxNames, m->src_contextName, m->eventId, message.getOrigAddr(), src);
      } else if( m->control_type == mace::EventExecutionControl_Message::TO_LOCK_CONTEXT) {
        const mace::EventOperationInfo& eventOpInfo = (m->opInfos)[0];
        const mace::string& dominator = contextStructure.getUpperBoundContextName( m->src_contextName );
        
        mace::ContextBaseClass* ctxObj = getContextObjByName(dominator);
        if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
          mace::set<mace::string> permittedContextNames;
          if( ctxObj->checkEventExecutePermission(this, m->src_contextName, eventOpInfo, false, permittedContextNames) ){
            ASSERT( permittedContextNames.size() > 0 );
            mace::vector<mace::EventOperationInfo> eventOpInfos;
            mace::vector<mace::string> contextNames;

            eventOpInfos.push_back(eventOpInfo);
            for( mace::set<mace::string>::iterator iter = permittedContextNames.begin(); iter != permittedContextNames.end(); iter++ ){
              contextNames.push_back(*iter);
            }
            send__event_replyEventExecutePermission( m->src_contextName, dominator, eventOpInfo.eventId, contextNames, eventOpInfos );
          }
          ctxObj->decreaseHandlingMessageNumber();
        }
      } else if( m->control_type == mace::EventExecutionControl_Message::ENQUEUE_LOCK_CONTEXTS) {
        const mace::vector<mace::EventOperationInfo>& eops = m->opInfos;
        const mace::string& dominator = contextStructure.getUpperBoundContextName( m->src_contextName );
        
        mace::ContextBaseClass* ctxObj = getContextObjByName(dominator);
        if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
          for( uint32_t i=0; i<eops.size(); i++ ){
            const mace::EventOperationInfo& eop = eops[i];
            mace::set<mace::string> permittedContextNames;
            ctxObj->checkEventExecutePermission(this, m->src_contextName, eop, false, permittedContextNames);
          }
          ctxObj->decreaseHandlingMessageNumber();
        } 
      } else if( m->control_type == mace::EventExecutionControl_Message::LOCK_CONTEXT_PERMISSION) {
        mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
        if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
          ctxObj->handleEventExecutePermission(this, m->eventId, m->contextNames, m->opInfos);
          ctxObj->decreaseHandlingMessageNumber();
        }
      } else if( m->control_type == mace::EventExecutionControl_Message::RELEASE_CONTEXTS) {
        const mace::vector<mace::string>& contextNames = m->contextNames;
        ASSERT( contextNames.size() > 0 );
        mace::set<mace::string> toContextNames;
        mace::string lockedContext;
        for( uint32_t i=0; i<contextNames.size(); i++ ){
          if( i == 0 ){
            lockedContext = contextNames[i];
          } else {
            toContextNames.insert( contextNames[i] );
          }
        }
         
        const mace::string dominatorContext = contextStructure.getUpperBoundContextName( lockedContext );
        mace::ContextBaseClass* ctxObj = getContextObjByName(dominatorContext);

        macedbg(1) << "event=" << m->eventId << " lockedContext=" << lockedContext << " dominatorContext=" << dominatorContext << " toContextNames=" << toContextNames <<Log::endl;
        if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
          ctxObj->releaseContext(this, m->eventId, lockedContext, toContextNames);
          ctxObj->decreaseHandlingMessageNumber();
        }
      } else if( m->control_type == mace::EventExecutionControl_Message::UNLOCK_CONTEXT ){
        const mace::EventOperationInfo& eventOpInfo = (m->opInfos)[0];
        const mace::string& dominator = contextStructure.getUpperBoundContextName( eventOpInfo.fromContextName );

        mace::set<mace::string> toContextNames;
        const mace::vector<mace::string>& contextNames = m->contextNames;
        for( uint32_t i=0; i<contextNames.size(); i++ ){
          toContextNames.insert( contextNames[i] );
        }
        
        mace::ContextBaseClass* ctxObj = getContextObjByName(dominator);
        if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
          ctxObj->unlockContext( this, eventOpInfo, m->src_contextName, toContextNames );
          ctxObj->decreaseHandlingMessageNumber(  );
        }

      }else if( m->control_type == mace::EventExecutionControl_Message::RELEASE_CONTEXT_REPLY) {  
        /*
        mace::ContextBaseClass* ctxObj = getContextObjByName( m->dest_contextName );
        if( ctxObj != NULL ) {
          ctxObj->eraseExecutedContextName(this, m->eventId, m->src_contextName, m->contextNames);
        }
        */
        ASSERTMSG(false, "No EventExecutionControl_Message::RELEASE_CONTEXT_REPLY any more!");
      }else if( m->control_type == mace::EventExecutionControl_Message::NEW_EVENT_OP) {
        ASSERTMSG(false, "No EventExecutionControl_Message::NEW_EVENT_OP any more!");
        mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
        if( ctxObj != NULL ) {
          ctxObj->enqueueEventOperation( m->eventId, m->opInfos[0]);
        }
      } else if( m->control_type == mace::EventExecutionControl_Message::EVENT_OP_DONE ) {
        ASSERT(false);
        /*
        const mace::EventOperationInfo& eop = m->opInfos[0];
        const mace::string dominator = contextStructure.getUpperBoundContextName( eop.fromContextName );
        mace::ContextBaseClass* ctxObj = getContextObjByName(dominator);
        if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
          ctxObj->unlockContext(this, eop, eop.fromContextName);
          ctxObj->decreaseHandlingMessageNumber();
        }
        */
      } else if( m->control_type == mace::EventExecutionControl_Message::CREATE_NEW_CONTEXT) {
        const mace::string& contextTypeName = m->contextNames[0];
        ScopedLock sl(serviceSharedDataMutex);
        mace::map<mace::string, uint32_t>::iterator iter = contextIds.find(contextTypeName);
        uint32_t newContextId;
        if( iter != contextIds.end() ) {
          newContextId = iter->second ++;
        } else {
          contextIds[contextTypeName] = 2;
          newContextId = 1;
        }

        send__event_createNewContextReply(m->src_contextName, m->opInfos[0], newContextId);
      } else if( m->control_type == mace::EventExecutionControl_Message::CREATE_NEW_CONTEXT_REPLY) {
        mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
        ASSERT( ctxObj != NULL );
        if( ctxObj != NULL ) {
          ctxObj->handleCreateNewContextReply( m->opInfos[0], m->newContextId);
        }
      } else if( m->control_type == mace::EventExecutionControl_Message::CHECK_COMMIT ) {
        mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
        ASSERT( ctxObj != NULL );
        if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
          ctxObj->getReadyToCommit( this, m->eventId, 3 );
          ctxObj->decreaseHandlingMessageNumber();
        }
      } else if( m->control_type == mace::EventExecutionControl_Message::RELEASE_LOCK_ON_CONTEXT ) {
        mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
        ASSERT( ctxObj != NULL );
        if( handleMessageToMigratingAndNullContext(ctxObj, message, src) ) {
          ctxObj->releaseLock(this, m->eventId);
          ctxObj->decreaseHandlingMessageNumber();
        }
      } else if( m->control_type == mace::EventExecutionControl_Message::READY_TO_COMMIT ) {
        const mace::vector<mace::string>& contextNames = m->contextNames;

        bool flag = true;
        mace::vector<mace::string> notifyContexts;
        mace::vector<mace::string> executedContexts;
        for( uint32_t i=0; i<contextNames.size(); i++ ){
          if( contextNames[i] == "#" ){
            flag = false;
            continue;
          }

          if( flag ){
            notifyContexts.push_back( contextNames[i] );
          } else {
            executedContexts.push_back( contextNames[i] );
          }
        }

        for( uint32_t i=0; i<notifyContexts.size(); i++ ){
          const mace::string& notifyContext = notifyContexts[i];

          mace::vector<mace::string> ctxNames;
          ctxNames.push_back(notifyContext);
          ctxNames.push_back("#");
          for( uint32_t i=0; i<executedContexts.size(); i++ ){
            ctxNames.push_back( executedContexts[i] );
          }
          
          mace::InternalMessageID msgId( Util::getMaceAddr(), notifyContext, 0);
          mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::READY_TO_COMMIT, 
            m->src_contextName, notifyContext, m->eventId, ctxNames, m->opInfos, m->newContextId);

          mace::ContextBaseClass* ctxObj = getContextObjByName(notifyContext);
          ASSERT( ctxObj != NULL );
          if( handleMessageToMigratingAndNullContext(ctxObj, msg, src) ) {
            ctxObj->notifyReadyToCommit(this, m->eventId, m->src_contextName, executedContexts );
            ctxObj->decreaseHandlingMessageNumber();
          }
        }
      } else if( m->control_type == mace::EventExecutionControl_Message::ENQUEUE_OWNERSHIP_OPS ) {
        mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
        ASSERT( ctxObj != NULL );
        const mace::vector< mace::EventOperationInfo >& oops = m->opInfos;
        mace::vector< mace::EventOperationInfo >::const_iterator iter = oops.begin();
        const mace::EventOperationInfo& eop = *iter;

        iter ++;
        for( ; iter != oops.end(); iter++ ) {
          ctxObj->enqueueOwnershipOpInfo( m->eventId, *iter );
        }
        send__event_enqueueOwnershipOpsReply(eop, m->src_contextName, ctxObj->contextName);
      } else if( m->control_type == mace::EventExecutionControl_Message::ENQUEUE_OWNERSHIP_OPS_REPLY ) {
        mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
        ASSERT( ctxObj != NULL && (m->opInfos).size() == 0 );
        const mace::EventOperationInfo& eop = (m->opInfos)[0];
        ctxObj->handleEnqueueOwnershipOpsReply(eop);
      }
      break;
    }
    case mace::InternalMessage::ENQUEUE_EVENT_REQUEST: {
      mace::EnqueueEventRequest_Message* m = static_cast<mace::EnqueueEventRequest_Message*>( message.getHelper() );
      mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
      ASSERT( ctxObj != NULL );
      ctxObj->enqueueSubEvent(m->eventOpInfo.eventId, m->request);
      send__event_enqueueSubEventReply(m->eventOpInfo, m->src_contextName, ctxObj->contextName);
      break;
    }
    case mace::InternalMessage::ENQUEUE_EVENT_REPLY: {
      mace::EnqueueEventReply_Message* m = static_cast<mace::EnqueueEventReply_Message*>( message.getHelper() );
      mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
      ASSERT( ctxObj != NULL );
      ctxObj->handleEnqueueSubEventReply(m->eventOpInfo);
      break;
    }
    case mace::InternalMessage::ENQUEUE_MESSAGE_REQUEST: {
      mace::EnqueueMessageRequest_Message* m = static_cast<mace::EnqueueMessageRequest_Message*>( message.getHelper() );
      mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
      ASSERT( ctxObj != NULL );
      ctxObj->enqueueExternalMessage(m->eventOpInfo.eventId, m->msg);
      send__event_enqueueExternalMessageReply(m->eventOpInfo, m->src_contextName, ctxObj->contextName);
      break;
    }
    case mace::InternalMessage::ENQUEUE_MESSAGE_REPLY: {
      mace::EnqueueEventReply_Message* m = static_cast<mace::EnqueueEventReply_Message*>( message.getHelper() );
      mace::ContextBaseClass* ctxObj = getContextObjByName(m->dest_contextName);
      ASSERT( ctxObj != NULL );
      ctxObj->handleEnqueueExternalMessageReply(m->eventOpInfo);
      break;
    }

    //default: throw(InvalidMaceKeyException("Deserializing bad internal message type "+boost::lexical_cast<std::string>(msgType)+"!"));
    
  }
}
// Assuming events created from message delivery, or downcall transition can only take place at head node.
bool ContextService::handleEventMessage( mace::AsyncEvent_Message* m, mace::InternalMessage const& msg, mace::MaceAddr const& src, uint32_t targetContextID ){
    ADD_SELECTORS("ContextService::handleEventMessage");
    mace::Event& e = m->getEvent();
    mace::ContextBaseClass * contextObject = getContextObjByName( e.eventOpInfo.toContextName );
    ASSERT( contextObject != NULL );
    
    checkAndUpdateContextMapping(e.eventContextMappingVersion);
    //checkAndUpdateContextMapping(0);
    checkAndUpdateContextStructure(e.eventContextStructureVersion);
      
    macedbg(1)<<"Enqueue a message into context("<< contextObject->contextName <<") event queue: "<< m <<Log::endl;
    contextObject->enqueueEvent(this,m ); 
    //contextObject->insertEventExecuteStartTime(e.eventId);
    
    return true;
 }

void ContextService::handleRoutineMessage( mace::Routine_Message* m, mace::MaceAddr const& source, mace::InternalMessage const& message ){
    ADD_SELECTORS("ContextService::handleRoutineMessage");
    
    //macedbg(1) << "Current Target Context = " << m->getEvent().curTarget_ctx_name << Log::endl;
  mace::ContextBaseClass * contextObject = getContextObjByName( m->getEvent().eventOpInfo.toContextName );
    
  contextObject->enqueueRoutine(this, m, source ); 
}

void ContextService::handle__event_AllocateContextObject( MaceAddr const& src, MaceAddr const& destNode, 
      mace::map< uint32_t, mace::string > const& ContextID, 
      mace::OrderID const& eventID, mace::ContextMapping const& contextMapping, int8_t const& eventType, 
      const uint64_t current_version){

    ADD_SELECTORS("ContextService::handle__event_AllocateContextObject");
    bool isCreateContextEvent = false;
    bool migrationFlag = false;
    bool contextMappingUpdateFlag = true;
    if(eventType == mace::Event::ALLOCATE_CTX_OBJECT) {
      macedbg(1) << "It's an allocateObj event for " << ContextID << Log::endl;
      isCreateContextEvent = true;
      migrationFlag = false;
      contextMappingUpdateFlag = true;
    } else {
      isCreateContextEvent = false;
      migrationFlag = true;
      contextMappingUpdateFlag = false;
    }
    
    mace::Event currentEvent( eventID );
    ThreadStructure::setEvent( currentEvent );

    ThreadStructure::setEventContextMappingVersion(current_version);

    MaceAddr headAddr = this->contextMapping.getHead();
    if( contextMappingUpdateFlag && this->contextMapping.getCurrentVersion() < contextMapping.getCurrentVersion() ) {
      this->contextMapping.updateToNewMapping(contextMapping);
    }
    this->getUpdatedContextStructure(0);
    if( isLocal( destNode ) && destNode != headAddr ){ 
      // if the context is at the head node, asyncHead() creates the context already
      for( mace::map< uint32_t, mace::string >::const_iterator ctxIt = ContextID.begin(); ctxIt != ContextID.end(); ctxIt++ ){
        mace::ContextBaseClass *thisContext = createContextObjectWrapper( eventID, ctxIt->second, ctxIt->first, current_version, migrationFlag ); // create context object
        ASSERTMSG( thisContext != NULL, "createContextObjectWrapper() returned NULL!");

        const mace::vector<mace::string> dominateContexts = contextStructure.getDominateContexts(thisContext->contextName);
        thisContext->initializeDominator(dominateContexts);

        macedbg(1) << "Create context(" << ctxIt->second <<") successfully!" << Log::endl;
        send__event_AllocateContextObjectResponseMsg(ctxIt->second, eventID, isCreateContextEvent);
      }
    }
		
}

void ContextService::handle__event_AllocateContextObjReq( mace::string const& ctxName, mace::OrderID const& eventId, mace::string const& parentCtxName,
    mace::ContextPolicyEntry const& policyEntry, const mace::MaceAddr& src){
	
  ADD_SELECTORS("ContextService::handle__event_AllocateContextObjReq");
  //macedbg(1) << "Create context object: " << ctxName <<Log::endl;
  HeadEventDispatch::HeadEventTP::executeContextCreateEvent(this, ctxName, eventId, parentCtxName, policyEntry, src);	
}

void ContextService::handle__event_AllocateContextObjectResponse(mace::string const& ctx_name, mace::OrderID const& eventId, bool const& isCreateContextEvent){
  this->notifyContextMappingUpdate(ctx_name);
  if( isCreateContextEvent ) {
    HeadEventDispatch::HeadEventTP::commitGlobalEvent(eventId.ticket);
  }
}

void ContextService::handle__event_UpdateContextMapping(mace::ContextMapping const& ctxMapping, mace::string const& ctxName){
	ADD_SELECTORS("ContextService::handle__event_UpdateContextMapping");
  if(ctxMapping.getCurrentVersion() > contextMapping.getCurrentVersion()){
		contextMapping.updateToNewMapping(ctxMapping);
  }

  wakeupContextMappingUpdateThreads(contextMapping.getCurrentVersion());

  if( !ctxName.empty() ) {
    macedbg(1) << "Try to wakeup threads waiting for Context " << ctxName << Log::endl;
    wakeupWaitingThreads(ctxName);
  }
}

void ContextService::handle__event_contextmapping_update_suggest( const uint64_t ver ) {
  if( ver > contextMapping.getCurrentVersion() && ver > contextMapping.getExpectVersion() ) {
    contextMapping.setExpectVersion(ver);
    //getUpdatedContextMapping(ver);
  }
}



void ContextService::handle__event_modifyOwnership( mace::EventOperationInfo const& eop, mace::string const& ctxName, mace::vector<mace::EventOperationInfo> const& ownershipOpInfos){
  ADD_SELECTORS("ContextService::handle__event_modifyOwnership");
  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  ASSERTMSG( ContextMapping::getHead(snapshot) == Util::getMaceAddr(), "Only head node could modify ownership structure" );
  HeadEventDispatch::HeadEventTP::executeModifyOwnershipEvent(this, eop, ctxName, ownershipOpInfos);
}



void ContextService::handle__event_updateOwnership( mace::vector< mace::pair<mace::string, mace::string> > const& ownerships, 
  mace::set<mace::string> const& ctxNames, const uint64_t& version ) {
  ADD_SELECTORS("ContextService::handle__event_updateOwnership");
  this->contextStructure.getLock(ContextStructure::WRITER);
  contextStructure.updateOwnerships(ownerships, version);
  this->contextStructure.releaseLock(ContextStructure::WRITER);
  wakeupContextStructureUpdateThreads(version);
}

void ContextService::handle__event_updateOwnershipAndDominators( mace::vector< mace::pair<mace::string, mace::string> > const& ownerships, 
    mace::set<mace::string> const& ctxNames, const uint64_t& version, mace::map<mace::string, mace::string> const& prePDominators,
    mace::map<mace::string, mace::string> const& preDominators ) {
  ADD_SELECTORS("ContextService::handle__event_updateOwnershipAndDominators");

  macedbg(1) << "ctxNames=" << ctxNames << " prePDominators=" << prePDominators << " preDominators=" << preDominators << Log::endl;

  if( Util::getMaceAddr() != contextMapping.getHead() ) {
    getUpdatedContextMapping(0);
  }
  
  
  this->contextStructure.getLock( ContextStructure::WRITER );
  this->contextStructure.updateOwnerships(ownerships, version);
  this->contextStructure.releaseLock( ContextStructure::WRITER );
  
  for( mace::set<mace::string>::const_iterator cIter=ctxNames.begin(); cIter!=ctxNames.end(); cIter++ ){
    const mace::string& ctxName = *cIter;
    mace::ContextBaseClass* ctxObj = this->getContextObjByName( ctxName );
    ASSERT( ctxObj != NULL );
    ctxObj->updateDominator(this, prePDominators, preDominators );
  }
}

/*
void ContextService::handle__event_ContextStructureUpdateReq( const mace::MaceAddr& src) {
  send__event_ContextStructureUpdate(contextStructure.getContextOwnerships(), contextStructure.getCurrentVersion(), src);
}
*/
void ContextService::handle__event_ContextMigrationRequest( MaceAddr const& src, MaceAddr const& dest, mace::Event const& event, 
    uint64_t const& prevContextMapVersion, mace::set<uint32_t> const& migrateContextIds, mace::ContextMapping const& ctxMapping ){
  
  ADD_SELECTORS("ContextService::handle__event_ContextMigrationRequest");
  ThreadStructure::setEvent( event );
  //ThreadStructure::ScopedServiceInstance si( instanceUniqueID );
    
  ThreadStructure::setEventContextMappingVersion( prevContextMapVersion );
  //const mace::ContextMapping& ctxmapSnapshot = contextMapping.getLatestContextMapping() ;
  
  mace::set<uint32_t>::const_iterator mctxIter = migrateContextIds.begin();
  const mace::ContextMapping& ctxmapSnapshot = contextMapping.getLatestContextMapping();
  for(; mctxIter != migrateContextIds.end(); mctxIter++) {
    macedbg(1) << "ContextID = " << *mctxIter << Log::endl;
    mace::ContextBaseClass *thisContext = getContextObjByID( *mctxIter ); // assuming context object already exists and this operation does not create new object.
    macedbg(1) << "ContextID = " << *mctxIter << Log::endl;
    

    ASSERT(thisContext != NULL);
    // adding migrating context information
        
    ASSERT( thisContext->requireExecuteTicket(event.eventId) > 0 );
    thisContext->setMigratingFlag(true);
    mace::ContextLock ctxlock( *thisContext, event.eventId, false, mace::ContextLock::MIGRATION_MODE );
    macedbg(1) << "Migration Event("<< event.eventId <<") enter migrating Context("<< thisContext->contextName<<")" << Log::endl;
    this->addMigratingContextName( thisContext->getName() );
    macedbg(1) << "After add migration context names!" << Log::endl;
    mace::map<uint32_t, mace::string> migrate_contexts;
  
    send__event_MigrationControlMsg( mace::ContextMapping::getHead(ctxmapSnapshot), mace::MigrationControl_Message::MIGRATION_RELEASE_CONTEXTMAPPING,
        event.eventId.ticket, migrate_contexts, ctxMapping);
    send__event_MigrationControlMsg( dest, mace::MigrationControl_Message::MIGRATION_UPDATE_CONTEXTMAPPING,
        event.eventId.ticket, migrate_contexts, ctxMapping);

    macedbg(1) << "Prepare to halt!!" << Log::endl;
    thisContext->prepareHalt();

    macedbg(1) << "Now Migration Event("<< event.eventId <<") could migrate Context("<< thisContext->contextName<<")!" << Log::endl;
    mace::string contextData;
    copyContextData( thisContext, contextData );
    mace::ContextBaseClassParams* ctxParams = new mace::ContextBaseClassParams();
    ctxParams->initialize(thisContext);

    eraseContextData( thisContext );
    send__event_TransferContext( dest, ctxParams, contextData, event.getEventID() );
    
      // If the entire context subtree will be migrated, send message to child contexts
    // erase the context from this node.
  }
}
void ContextService::handle__event_TransferContext( MaceAddr const& src, const mace::ContextBaseClassParams* ctxParams, 
      mace::string const& checkpoint, mace::OrderID const& eventId ){

    ADD_SELECTORS("ContextService::handle__event_TransferContext");
    const mace::string& contextName = ctxParams->contextName;
    checkContextCreation(contextName);
    mace::ContextBaseClass* thisContext = getContextObjByName(contextName);
    ASSERT( thisContext != NULL );
    // thisContext->resumeParams(this, ctxParams);
    
    ThreadStructure::ScopedServiceInstance si( instanceUniqueID );
    mace::Event& myEvent = ThreadStructure::myEvent();
    myEvent.eventType = mace::Event::MIGRATIONEVENT;
    myEvent.eventId = eventId;
    myEvent.target_ctx_name = contextName;
    myEvent.create_ctx_name = "";
    myEvent.createCommitFlag = false;
    
    // create object using name string
    mace::deserialize( checkpoint, thisContext );
    thisContext->resumeParams(this, ctxParams);
    ASSERT( thisContext->getNowServing() == eventId );
    thisContext->setMigratingFlag(false);
    macedbg(1) << "Migrating context(" << contextName <<") with eventId("<< myEvent.eventId <<") is done!" << Log::endl;
    // local commit.
    // notice that the same event has also already downgraded the original context object copy.
    mace::ContextLock c_lock( *thisContext, eventId, false, mace::ContextLock::MIGRATION_RELEASE_MODE );
    thisContext->commitEvent(ThreadStructure::myEventID());
    thisContext->resumeExecution();
    myEvent.clearEventRequests();
    myEvent.clearEventUpcalls();
    send__event_commit( contextMapping.getHead(), myEvent, "" );
  // TODO: send response
}
void ContextService::handle__event_MigrationControl( const mace::MigrationControl_Message* msg) {
  ADD_SELECTORS("ContextService::handle__event_MigrationControl");
  uint8_t type = msg->control_type;
  macedbg(1) << "msg type = " << (uint32_t)type << Log::endl;
  if( type == mace::MigrationControl_Message::MIGRATION_DONE ){
    const mace::ContextMapping& ctxMapping =  msg->ctxMapping;
    if( contextMapping.getCurrentVersion() < ctxMapping.getCurrentVersion() && Util::getMaceAddr() != contextMapping.getHead() ) {
      macedbg(1) << "Update context mapping to " << ctxMapping.getCurrentVersion() << Log::endl;
      contextMapping.updateToNewMapping(ctxMapping);
    }

    mace::set<mace::string> migrateContexts;
    const mace::map<uint32_t, mace::string>& contexts = msg->migrate_contexts;
    mace::map<uint32_t, mace::string>::const_iterator cIter = contexts.begin();
    for(; cIter != contexts.end(); cIter++) {
      migrateContexts.insert(cIter->second);
    }

    releaseBlockedMessageForMigration(migrateContexts);
  } else if (type == mace::MigrationControl_Message::MIGRATION_PREPARE_RECV_CONTEXTS ) {
    macedbg(1) << "Migrating event ticket = " << msg->ticket << Log::endl;
    const mace::map<uint32_t, mace::string>& migrate_contexts = msg->migrate_contexts;
    mace::map<uint32_t, mace::string>::const_iterator ctxIter = migrate_contexts.begin();
    ScopedLock sl(migratingContextMutex);
    receivedExternalMsgCount += 2;
    for(; ctxIter != migrate_contexts.end(); ctxIter++) {
      commingContexts.insert(ctxIter->second);
      commingContextsMap[ctxIter->first] = ctxIter->second;
      macedbg(1) << "Context("<< ctxIter->first<<", "<< ctxIter->second <<") is on the way!" << Log::endl;
    }

    isContextComming = true;

    send__event_MigrationControlMsg(contextMapping.getHead(), mace::MigrationControl_Message::MIGRATION_PREPARE_RECV_CONTEXTS_RESPONSE,
      msg->ticket, msg->migrate_contexts, msg->ctxMapping);
    receivedExternalMsgCount -= 2;
  } else if ( type == mace::MigrationControl_Message::MIGRATION_PREPARE_RECV_CONTEXTS_RESPONSE ) {
    HeadEventDispatch::HeadEventTP::signalMigratingContextThread(msg->ticket);
  } else if ( type == mace::MigrationControl_Message::MIGRATION_UPDATE_CONTEXTMAPPING) {
    if( Util::getMaceAddr() != contextMapping.getHead() && contextMapping.getCurrentVersion() < msg->ctxMapping.getCurrentVersion() ) {
      contextMapping.updateToNewMapping(msg->ctxMapping);
      macedbg(1) << "Update ContextMapping version to " << contextMapping.getCurrentVersion() << Log::endl;
    }
  } else if( type == mace::MigrationControl_Message::MIGRATION_RELEASE_CONTEXTMAPPING ){ 
    ASSERT(Util::getMaceAddr() == contextMapping.getHead());
    HeadEventDispatch::HeadEventTP::signalMigratingContextThread(msg->ticket);
  } else {
    ASSERTMSG(false, "Unkonw message type!");
  }
}

void ContextService::handle__event_create( MaceAddr const& src, __asyncExtraField const& extra, 
    uint64_t const& counter, uint32_t const& ctxID ){

  if( mace::Event::isExit ) {
    wasteTicket();
    return;
  }
  mace::InternalMessage m(mace::create_head, extra, counter, ctxID, src);
  //HeadEventDispatch::HeadEventTP::executeEvent( const_cast<ContextService*>(this), (HeadEventDispatch::eventfunc)&ContextService::handleInternalMessagesWrapper, new mace::InternalMessage(m), true );
  mace::ContextBaseClass* ctx_obj = getContextObjByID(ctxID);
  ctx_obj->enqueueCreateEvent(const_cast<ContextService*>(this), 
    (HeadEventDispatch::eventfunc)&ContextService::handleInternalMessagesWrapper, new mace::InternalMessage(m), true);
}
void ContextService::handle__event_commit( mace::Event& event, mace::InternalMessage const& message, mace::MaceAddr const& src) const {
  ADD_SELECTORS("ContextService::handle__event_commit");
  if( event.eventType == mace::Event::MIGRATIONEVENT ) {
    const mace::ContextMapping& ctxMapping = contextMapping.getLatestContextMapping();
    uint32_t ctxId = mace::ContextMapping::hasContext2(ctxMapping, event.target_ctx_name);
    HeadEventDispatch::HeadEventTP::commitMigrationEvent(this, event.eventId, ctxId);
    return;
  } else {
    ASSERT(false);
  }
}

void ContextService::handle__event_commit_contexts( mace::vector< mace::string > const& ctxNames, mace::string const& targetContextName,
      mace::OrderID const& eventId, mace::MaceAddr const& src, mace::MaceAddr const& orig_src ) {
    // recursively downgrade contexts until it reaches exceptionContextID or reaches the bottom of context lattice
    ADD_SELECTORS("ContextService::handle__event_commit_context");
    macedbg(1) << "ctxNames = "<<ctxNames<< " eventId = " << eventId << Log::endl;
    ASSERT( !ctxNames.empty() );

    ThreadStructure::ScopedServiceInstance si( instanceUniqueID );
    
    //const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
    for(  uint32_t i=0; i<ctxNames.size(); i++ ){
      const mace::string& thisContextName = ctxNames[i];
      mace::ContextBaseClass * thisContext = getContextObjByName( thisContextName);

      mace::InternalMessageID msgId( orig_src, thisContextName, 0);
      mace::vector<mace::string> contextNames; 
      mace::vector<mace::EventOperationInfo> opInfos; 
      uint32_t newContextId=0;
      mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::COMMIT_CONTEXT,  
        thisContextName, targetContextName, eventId, contextNames, opInfos, newContextId);
      
      if( handleMessageToMigratingAndNullContext(thisContext, msg, src) ){
        thisContext->commitContext(this, eventId);
        thisContext->decreaseHandlingMessageNumber();
      }
   }   
}

void ContextService::handle__event_create_response( mace::Event const& event, uint32_t const& counter, MaceAddr const& targetAddress){
  ADD_SELECTORS("ContextService::handle__event_create_response");
  // read from buffer
  
  ScopedLock sl( eventRequestBufferMutex );
  maceout<<"Event "<< event.eventId << ", counter = "<< counter <<" is sent to "<< targetAddress <<Log::endl;
  std::map< uint32_t, std::pair<mace::string*, mace::string > >::iterator ueIt = unfinishedEventRequest.find( counter );
  ASSERT( ueIt != unfinishedEventRequest.end() );
  std::pair< mace::string*, mace::string >& eventreq = ueIt->second;
  eventreq.first->erase(  eventreq.first->size() - eventreq.second.size() ); //remove the Event field from message
  /*__asyncExtraField extra;
  mace::deserialize( eventreq.second, &extra);*/
  /*extra.event = event;
  extra.isRequest = false;*/
  mace::string event_str;
  mace::serialize( event_str , &event );
  eventreq.first->append( event_str );

  mace::string* eventmsg = eventreq.first;

  unfinishedEventRequest.erase( ueIt );
  sl.unlock();

  const mace::MaceKey destNode( mace::ctxnode, targetAddress  );
  //sender->routeEventRequest( destNode, *eventmsg );

  delete eventmsg;

}

void ContextService::handle__event_enter_context( mace::Event const& event, mace::vector< uint32_t > const& contextIDs ){
  ThreadStructure::setEvent( event );
  for( mace::vector< uint32_t >::const_iterator ctxidIt = contextIDs.begin(); ctxidIt != contextIDs.end(); ctxidIt++ ){
    mace::ContextBaseClass * thisContext = getContextObjByID( *ctxidIt );
    mace::ContextLock __contextLock( *thisContext, event.eventId, false, mace::ContextLock::WRITE_MODE); // acquire context lock. 
  }

}
void ContextService::handle__event_exit_committed( ){
  // this message is supposed to be received by non-head nodes.
  // if the main thread is blocking in maceExit(), wake it up
  proceedExit();
  // if maceExit() has not been called at this node....?
}
void ContextService::handle__event_create_head(__asyncExtraField const& extra, uint64_t const& counter, 
    MaceAddr const& src){
  if( mace::Event::isExit ) {
    //mace::AgentLock::skipTicket();
    return;
  }

  //const mace::string& target_ctx_name = extra.targetContextID;
  //const mace::string& start_ctx_name = this->getStartContextName(target_ctx_name);
  // contextID;
  //asyncHead( ThreadStructure::myEvent(), extra, mace::Event::ASYNCEVENT, contextID );


  const MaceAddr& targetContextAddr = contextMapping.getNodeByContext( extra.targetContextID );
  send__event_create_response( src, ThreadStructure::myEvent(), counter, targetContextAddr );
}
void ContextService::handle__event_snapshot( mace::Event const& event, mace::string const& ctxID, 
    mace::string const& snapshotContextID, mace::string const& snapshot){
  // store the snapshoeventt
  pthread_mutex_lock(&mace::ContextBaseClass::eventSnapshotMutex );
  std::pair< mace::OrderID, mace::string > key( event.eventId, ctxID );
  std::map<mace::string, mace::string>& snapshots = mace::ContextBaseClass::eventSnapshotStorage[ key ];
  snapshots[ snapshotContextID ] = snapshot;
  // if the event is waiting in the target context, notify it.
  std::map<mace::OrderID, pthread_cond_t*>::iterator condIt = mace::ContextBaseClass::eventSnapshotConds.find( event.eventId );
  if( condIt !=  mace::ContextBaseClass::eventSnapshotConds.end() ){
      pthread_cond_signal( condIt->second );
  }
  pthread_mutex_unlock(&mace::ContextBaseClass::eventSnapshotMutex );
}
void ContextService::handle__event_downgrade_context( uint32_t const& contextID, mace::OrderID const& eventID, 
    bool const& isresponse ){
  if( isresponse ){
    mace::ScopedContextRPC::wakeup( eventID );
  }else{
    mace::Event currentEvent( eventID );
    ThreadStructure::setEvent( currentEvent );
    mace::ContextBaseClass *thisContext = getContextObjByID( contextID);
    mace::ContextLock cl( *thisContext, eventID, false, mace::ContextLock::READ_MODE );
  }
}
void ContextService::handle__event_routine_return( mace::string const& returnValue, mace::Event const& event){

  ThreadStructure::setEventContextMappingVersion ( event.eventContextMappingVersion );
  mace::ScopedContextRPC::wakeupWithValue( returnValue, event );
}
void ContextService::handle__event_appupcall_return( mace::string const& returnValue, mace::Event const& event){

  ThreadStructure::setEventContextMappingVersion ( event.eventContextMappingVersion );
  mace::ScopedContextRPC::wakeupWithValue( returnValue, event );
}
void ContextService::handle__event_evict( MaceAddr const& src ){
  
  // TODO: determine the contexts on the node
  mace::list< mace::string > contexts;
  // use the latest context mapping version
  contextMapping.getContextsOfNode( src, contexts );

  // TODO: call requestContextMigration() to migrate the contexts
  for( mace::list< mace::string >::iterator ctxIt = contexts.begin(); ctxIt != contexts.end(); ctxIt++ ){
    // app.getServiceObject()->requestContextMigration( serviceID, migctxIt->first, migctxIt->second, false );
    requestContextMigrationCommon( instanceUniqueID, *ctxIt,src, false );
  }

  // go to the lower services
}
/**
 * TODO: unfinished
 *
 * */
void ContextService::handle__event_new_head_ready( MaceAddr const& src ){
  

}
void ContextService::handle__event_migrate_context( mace::MaceAddr const& newNode, mace::string const& contextName, uint64_t const delay ){

}
#include "StrUtil.h"
void ContextService::handle__event_migrate_param( mace::string const& paramid ){
  // 1. split paramid into an array of parameter id
  StringList paramlist = StrUtil::split( " ", paramid);

  for (StringList::const_iterator i = paramlist.begin(); i != paramlist.end(); i++) {
    std::string const& param_id = *i;
    MaceAddr dest = MaceKey(ipv4, params::get<std::string>( param_id + ".dest" ) ).getMaceAddr();
    StringList contexts = StrUtil::split(" \n", params::get<mace::string>( param_id + ".contexts" ));
    uint8_t service = static_cast<uint8_t>(params::get<uint32_t>( param_id + ".service" ));
    ASSERT( service == instanceUniqueID );
    for( StringList::iterator ctxIt = contexts.begin(); ctxIt != contexts.end(); ctxIt ++ ){
      mace::string contextName = *ctxIt;
      std::cout << " migrate context "<< contextName <<" of service "<< service <<std::endl;
      requestContextMigrationCommon(service, contextName, dest , true);
    }
  }
}
void ContextService::handle__event_delete_context( mace::string const& contextName ){
  doDeleteContext( contextName );
}

void ContextService::handle__event_CommitDone( mace::string const& target_ctx_name, mace::OrderID const& eventId, mace::InternalMessage const& message, mace::MaceAddr const& src ) {
  ADD_SELECTORS("ContextService::handle__event_CommitDone");
  mace::ContextBaseClass* ctxObj = this->getContextObjByName(target_ctx_name);
  macedbg(1) << "To commit Event("<< eventId <<") in " << target_ctx_name << Log::endl;
  ctxObj->handleEventCommitDone(this, eventId);
}

void ContextService::handle__event_contextmapping_update_req( const uint64_t& expectVer, const mace::MaceAddr& src) {
  ADD_SELECTORS("ContextService::handle__event_contextmapping_update_req");
  macedbg(1) << "Receive context mapping update request("<< expectVer <<") from " << src << Log::endl;
  mace::string ctxName = "";
  notifyContextMappingUpdate(ctxName, src);
}

void ContextService::handle__event_ExternalCommControl( const mace::ExternalCommControl_Message* msg) {
  if( msg->control_type == mace::ExternalCommControl_Message::ADD_CLIENT_MAPPING) {
    ScopedLock sl(externalCommMutex);
    if( externalCommClassMap.find(msg->externalCommId) == externalCommClassMap.end() ){
      ExternalCommClass* exCommClass = new ExternalCommClass(msg->externalCommContextId, msg->externalCommId);
      externalCommClassMap[msg->externalCommId] = exCommClass;
      externalCommClasses.push_back(msg->externalCommId);
    }
  }
}

mace::MaceAddr const& ContextService::asyncHead( mace::OrderID& eventId, mace::string const& targetContextName, int8_t const eventType, uint32_t& contextId){
  ADD_SELECTORS("ContextService::asyncHead #2");
  if( eventType == mace::Event::UNDEFEVENT ){
    return SockUtil::NULL_MACEADDR;
  }
/*
  if( !contextStructure.hasContextNode(targetContextName) ) {
    getUpdatedContextStructure(0);
  }

  ASSERTMSG(contextStructure.hasContextNode(targetContextName), "Fail to find target context" );
*/
  const mace::ContextMapping& snapshotContext = contextMapping.getLatestContextMapping();
  contextId = mace::ContextMapping::hasContext2( snapshotContext, targetContextName );
  if( contextId > 0 ){ // the context exists
    return mace::ContextMapping::getNodeByContext( snapshotContext, contextId );    
  }else{// create a new context
    macedbg(1) << "Try to create context object(" << targetContextName << ")"<< Log::endl;
    const mace::Event& event = ThreadStructure::myEvent();
    mace::string parentContext = event.getParentContextName(targetContextName);
    trytoCreateNewContextObject( targetContextName, eventId, parentContext );
    
    const mace::ContextMapping& newSnapshotContext = contextMapping.getLatestContextMapping();
    contextId = mace::ContextMapping::hasContext2( newSnapshotContext, targetContextName );
    ASSERTMSG(contextId > 0, "Fail to create context!");
    return mace::ContextMapping::getNodeByContext( newSnapshotContext, contextId );
  }
}

mace::MaceAddr const& ContextService::asyncHead( mace::Message* msg, uint32_t& contextId){
  ADD_SELECTORS("ContextService::asyncHead #1");
  mace::AsyncEvent_Message* msgObj = static_cast<mace::AsyncEvent_Message*>( msg );
  ASSERT( msgObj != NULL );
  mace::Event& event = msgObj->getEvent();
  
  if( !contextStructure.hasContextNode(event.target_ctx_name) ) {
    macedbg(1) << "Fail to find context(" <<event.target_ctx_name <<") in contextStructure! Try to update contextstructure!" << Log::endl; 
    getUpdatedContextStructure(0);
    macedbg(1) << "Get latest version of ContextStructure!" << Log::endl;
  }

  //ASSERTMSG(contextStructure.hasContextNode(event.target_ctx_name), "Fail to find target context" );

  uint8_t eventType = event.eventType;
  if( eventType == mace::Event::UNDEFEVENT ){
    return SockUtil::NULL_MACEADDR;
  }
  event.eventContextMappingVersion = contextMapping.getCurrentVersion();
  const mace::ContextMapping& snapshotContext = contextMapping.getLatestContextMapping();
  contextId = mace::ContextMapping::hasContext2( snapshotContext, event.target_ctx_name );
  if( contextId > 0 ){ // the context exists
    send__event_asyncEvent( mace::ContextMapping::getNodeByContext( snapshotContext, contextId),  msgObj, event.target_ctx_name);
    return mace::ContextMapping::getNodeByContext( snapshotContext, contextId );
  }else{// create a new context
		const mace::Event& curEvent = ThreadStructure::myEvent();
    mace::string parentContextName = curEvent.getParentContextName(event.target_ctx_name);
    trytoCreateNewContextObject( event.target_ctx_name, event.eventId, parentContextName );
    macedbg(1) << "Wake up after creating context " << event.target_ctx_name << Log::endl;
    const mace::ContextMapping& newSnapshotContext = contextMapping.getLatestContextMapping();
    contextId = mace::ContextMapping::hasContext2( newSnapshotContext, event.target_ctx_name );
    ASSERTMSG(contextId > 0, "Fail to create context!");
    send__event_asyncEvent( mace::ContextMapping::getNodeByContext( newSnapshotContext, contextId),  msgObj, event.target_ctx_name);
    return mace::ContextMapping::getNodeByContext( newSnapshotContext, contextId );
  }
  
}

void ContextService::broadcastHead( mace::Message* msg ){
  ADD_SELECTORS("ContextService::broadcastHead");
  mace::AsyncEvent_Message* msgObj = static_cast<mace::AsyncEvent_Message*>( msg );

  mace::Event& event = msgObj->getEvent();
  const mace::string& toContextName = event.eventOpInfo.toContextName;
  if( !contextStructure.hasContextNode( toContextName ) ) {
    macedbg(1) << "Fail to find context(" << toContextName <<") in contextStructure!" << Log::endl; 
    getUpdatedContextStructure(0);
  }

  if( !contextStructure.hasContextNode(toContextName) ) {
    macedbg(1) << "context("<< toContextName <<") must be created by event("<< event.eventId <<")!" <<Log::endl;
  }

  uint8_t eventType = event.eventType;
  if( eventType == mace::Event::UNDEFEVENT ){
    return;
  }

  const mace::ContextMapping& snapshotContext = contextMapping.getLatestContextMapping();
  uint32_t contextId = mace::ContextMapping::hasContext2( snapshotContext, toContextName );
  if( contextId > 0 ){ // the context exists
    macedbg(1) << "Forward broadcast event: " << event.eventOpInfo << Log::endl;
    send__event_asyncEvent( mace::ContextMapping::getNodeByContext( snapshotContext, contextId),  msgObj, toContextName);
  }else{// create a new context
    const mace::Event& curEvent = ThreadStructure::myEvent();
    mace::string parentContextName = curEvent.getParentContextName(toContextName);
    macedbg(1) << "Event("<< event.eventId <<") tries to create context " << toContextName << Log::endl;
    trytoCreateNewContextObject( toContextName, event.eventId, parentContextName );

    const mace::ContextMapping& newSnapshotContext = contextMapping.getLatestContextMapping();
    contextId = mace::ContextMapping::hasContext2( newSnapshotContext, toContextName );
    ASSERTMSG(contextId > 0, "Fail to create context!");
    macedbg(1) << "Forward broadcast event: " << event.eventOpInfo << Log::endl;
    send__event_asyncEvent( mace::ContextMapping::getNodeByContext( newSnapshotContext, contextId),  msgObj, toContextName);
    
  }
  //macedbg(1) << "After event("<< event.eventId <<") broadcast request is send out!" << Log::endl;
}

void ContextService::__beginTransition( const uint32_t targetContextID, mace::vector<uint32_t> const& snapshotContextIDs, bool isRelease = true, bool newExecuteTicket = false  ) const {
  ThreadStructure::pushServiceInstance( instanceUniqueID ); 
  __beginMethod( targetContextID, snapshotContextIDs, isRelease, newExecuteTicket );
}
void ContextService::__beginMethod( const uint32_t targetContextID, mace::vector<uint32_t> const& snapshotContextIDs, bool isRelease = true, bool newExecuteTicket = false ) const {
  ADD_SELECTORS("ContextService::__beginMethod");
  ThreadStructure::pushContext( targetContextID );
  ThreadStructure::insertEventContext( targetContextID );
  mace::ContextBaseClass * thisContext = getContextObjByID( targetContextID );
  ASSERT( thisContext != NULL );
  ThreadStructure::setMyContext( thisContext );

  if( newExecuteTicket ) {
    bool execute_flag = thisContext->waitingForExecution(this, ThreadStructure::myEvent());
    ASSERTMSG( execute_flag, "The first event shouldn't wait any previous event!");
    mace::EventExecutionInfo ee_info(thisContext->contextName, thisContext->contextName, false);
    thisContext->setEventExecutionInfo(ThreadStructure::myEventID(), ee_info);
    //thisContext->enqueueLockedContextName(ThreadStructure::myEventID(), thisContext->contextName);
  }
  mace::Event& event = ThreadStructure::myEvent();

  macedbg(1) << "Try to execute "<< event.eventId<<" in " << thisContext->contextName << Log::endl;
  if( event.isReadOnly ) {
    mace::ContextLock __contextLock( *thisContext, ThreadStructure::myEventID(), isRelease, mace::ContextLock::READ_MODE);
  } else {
    mace::ContextLock __contextLock( *thisContext, ThreadStructure::myEventID(), isRelease, mace::ContextLock::WRITE_MODE); // acquire context lock.
  } 
}

void ContextService::__beginCommitContext( const uint32_t targetContextID ) const {
  ADD_SELECTORS("ContextService::__beginCommitContext");
  ThreadStructure::pushContext( targetContextID );
  ThreadStructure::insertEventContext( targetContextID );
  mace::ContextBaseClass * thisContext = getContextObjByID( targetContextID );
  ThreadStructure::setMyContext( thisContext );

  mace::ContextLock __contextLock( *thisContext, ThreadStructure::myEventID(), true, mace::ContextLock::COMMIT_MODE);  
}
void ContextService::__finishBroadcastTransition() const {
  ADD_SELECTORS("ContextService::__finishBroadcastTransition");
  mace::Event& currentEvent = ThreadStructure::myEvent();
  ASSERT( currentEvent.eventType == mace::Event::BROADCASTEVENT);

  mace::ContextBaseClass* ctxObj = ThreadStructure::myContext();
  ASSERT( ctxObj != NULL);
  macedbg(1) << "Broadcast Event("<< currentEvent.eventId <<") is executed in Context " << ctxObj->contextName << Log::endl;
  mace::vector<mace::EventOperationInfo> ownershipOpInfos = ctxObj->extractOwnershipOpInfos(currentEvent.eventId);
  if( ownershipOpInfos.size() > 0 ) {
    ctxObj->applyOwnershipOperations( this, currentEvent.eventOpInfo, ownershipOpInfos);
  }
  ctxObj->handleEventOperationDone( this, currentEvent.eventOpInfo );
}

void ContextService::__finishTransition(mace::ContextBaseClass* oldContext) const {
  ADD_SELECTORS("ContextService::__finishTransition");
 
  mace::Event& currentEvent = ThreadStructure::myEvent();
  mace::ContextBaseClass * thisContext = ThreadStructure::myContext();
  macedbg(1) << "Event("<< currentEvent.eventId <<") finishes event transition in " << thisContext->contextName << Log::endl;

  mace::vector<mace::EventOperationInfo> ownershipOpInfos = thisContext->extractOwnershipOpInfos(currentEvent.eventId);
  if( ownershipOpInfos.size() > 0 ) {
    thisContext->applyOwnershipOperations( this, currentEvent.eventOpInfo, ownershipOpInfos);
  }
  
  ContextService* _nc_service = const_cast<ContextService*>(this);
  mace::vector< mace::EventOperationInfo > eops = thisContext->getLocalLockRequest(currentEvent.eventId);
  thisContext->removeLocalLockRequest(currentEvent.eventId);
  if( eops.size() > 0 ){
    thisContext->enqueueLockRequests( _nc_service, eops, thisContext->contextName );
  }

  mace::set<mace::string> toContextNames = thisContext->getEventToContextNames(currentEvent.eventId);

  ScopedLock sl1(thisContext->contextMigratingMutex);
  thisContext->releaseContext(_nc_service, currentEvent.eventId, thisContext->contextName, toContextNames);
  sl1.unlock();

  __finishMethod(oldContext);
  ThreadStructure::popServiceInstance( ); 
}

void ContextService::__finishMethod(mace::ContextBaseClass* oldContext) const {
  ADD_SELECTORS("ContextService::__finishMethod");
  macedbg(1) << "Pop current context!" << Log::endl;
  ThreadStructure::popContext( );
  ThreadStructure::setMyContext( oldContext );
}

void ContextService::__finishCommitContext(mace::ContextBaseClass* oldContext) const {
  ThreadStructure::popContext( );
  ThreadStructure::setMyContext( oldContext );
}
void ContextService::enterInnerService (mace::string const& targetContextID ) const{
  ADD_SELECTORS("ContextService::enterInnerService");
  macedbg(1) << "Enter ContextService::enterInnerService"<<Log::endl;
  /*
  mace::vector< uint32_t > nextHops;
  uint32_t globalContextID = mace::ContextMapping::GLOBAL_CONTEXT_ID;
  const mace::string globalContextName(mace::ContextMapping::GLOBAL_CONTEXT_NAME);
  const mace::ContextMapping& snapshotMapping = contextMapping.getLatestContextMapping();
  nextHops.push_back( globalContextID );
  if( !ThreadStructure::isEventEnteredService(instanceUniqueID) && targetContextID != globalContextName ){
    // Since it is the first transition of this service,
    // it has to downgrade higher-level contexts before entering the call.
    // this is similar to async calls
    
    macedbg(1) << "To commit context: " << targetContextID << Log::endl;
    mace::Event& he = ThreadStructure::myEvent();
    uint32_t targetContextNID = snapshotMapping.findIDByName( targetContextID );
    
    const_send__event_commit_context( mace::ContextMapping::getNodeByContext( snapshotMapping, globalContextID ), nextHops, he.eventId, he.eventType, he.eventContextMappingVersion, he.eventOrderRecords, 
      false, true, targetContextNID, he.access_contexts, he.getBroadcastEventID() );
    
  }
  */
}
void ContextService::notifyNewEvent( mace::Event & he, const uint8_t serviceID ) {
    ADD_SELECTORS("ContextService::notifyNewEvent");

    if( serviceID == instanceUniqueID ) { return; }

    if( he.getEventType() == mace::Event::MIGRATIONEVENT ){
      // if it's a migration event and is not initiated in this service, don't update context event record
      // because the migration event will not enter this service at all.
      return;
    }

    // If the event is not created in this service, it is guaranteed the all the contexts in this service will be
    // explicitly downgraded by this event. So all later events entering this service should wait for this event
    // i.e. It is as if the event in this service starts from the global context
    //const mace::string globalContext = ""; 

    //contextEventRecord.updateContext( globalContext, he.eventId, he.getPreEventInfosStorage( instanceUniqueID ) );
}
void ContextService::notifyNewContext(mace::Event & he,  const uint8_t serviceID ) {
    ADD_SELECTORS("ContextService::notifyNewContext");

    if( serviceID == instanceUniqueID ) { return; }
    if( he.eventType == mace::Event::STARTEVENT ){
      const mace::string globalContextID = "";
      // if it's a start event, the head has to create a mapping to global context
      // to prevent race condition, the global context of every service in the composition has to be created explicitly in the first event (that is, maceInit)
      mace::ContextPolicy ctxPolicy;
      std::pair< mace::MaceAddr, uint32_t > newMappingReturn = contextMapping.newMapping( globalContextID, "", ctxPolicy );
      const mace::ContextMapping* ctxmapCopy =  contextMapping.snapshot( he.eventContextMappingVersion ) ; // create ctxmap snapshot
      ASSERT( ctxmapCopy != NULL );
      contextEventRecord.createContextEntry( globalContextID, newMappingReturn.second, he.eventId );
      //mace::Event::EventSkipRecordType & skipIDStorage = he.getPreEventIdsStorage( instanceUniqueID );
      //skipIDStorage.set( newMappingReturn.second, he.eventId );

      if( isLocal( newMappingReturn.first ) ){ // the new context co-locates with the head
        mace::ContextBaseClass *globalContext = createContextObjectWrapper( he.eventId, globalContextID, newMappingReturn.second, he.eventContextMappingVersion, false );
        ASSERT( globalContext != NULL );
        const mace::vector<mace::string> dominateContexts = contextStructure.getDominateContexts(globalContext->contextName);
        globalContext->initializeDominator(dominateContexts);
      }else{
        remoteAllocateGlobalContext( globalContextID, newMappingReturn, ctxmapCopy );
      }
      return;
    }

    ASSERTMSG( !contextMapping.hasSnapshot( he.eventContextMappingVersion ), "The new context is not created in this service, why does it have this version of context mapping?" );
    const mace::ContextMapping& ctxmapCopy =  contextMapping.getLatestContextMapping() ; // create ctxmap snapshot
    //ASSERT( ctxmapCopy != NULL );

    mace::map< uint32_t, mace::string > contextSet; // empty set
    send__event_AllocateContextObjectMsg( he.eventId, ctxmapCopy, SockUtil::NULL_MACEADDR, contextSet, 0, he.eventContextMappingVersion );
}

void ContextService::downgradeEventContext( ){
  ADD_SELECTORS("ContextService::downgradeEventContext");
  /*
  mace::Event myEvent = ThreadStructure::myEvent();
  mace::ContextBaseClass* ctxObj = ThreadStructure::myContext();
  const mace::OrderID myEventId = myEvent.getEventID();
  uint8_t commitInitiatorServiceID = 0;
  if( myEvent.eventType == mace::Event::ENDEVENT ){
    commitInitiatorServiceID = ThreadStructure::getServiceInstance();
  }
  ThreadStructure::ScopedServiceInstance si( instanceUniqueID );
  //ThreadStructure::ScopedContextID sc( ContextMapping::getHeadContextID() );
  // (1) move the block/write/read lines down to the bottom of the context hierarchy.
  // send the commit message to the read-line cut 

  switch( myEvent.eventType ){
    case mace::Event::NEWCONTEXTEVENT:
      return;
      break;
    case mace::Event::ENDEVENT:
      if( commitInitiatorServiceID != instanceUniqueID ){
        return;
      }
      break;
    case mace::Event::STARTEVENT:
      //return;
      break;
  }
  // if new-context-event, all contexts will be entered, no need to commit contexts again
  const mace::ContextMapping& snapshotMapping = contextMapping.getLatestContextMapping();
  
  
  mace::map< mace::MaceAddr, mace::set<mace::string> > cctxAddrs;    
  
  const mace::set<mace::string> lockedContextNames = ctxObj->getLockedContextNames(myEventId);
  for( mace::set< mace::string >::const_iterator cctxIt = lockedContextNames.begin(); cctxIt != lockedContextNames.end(); cctxIt ++ ){
    const mace::string& cctxName = *cctxIt;

    uint32_t cctxId = ContextMapping::hasContext2(snapshotMapping, cctxName);
    ASSERT( cctxId > 0 );
    
    const mace::MaceAddr& cctxAddr = mace::ContextMapping::getNodeByContext( snapshotMapping, cctxId );
    cctxAddrs[cctxAddr].insert(cctxName);
  }
      
  mace::map< mace::MaceAddr , mace::set< mace::string > >::iterator addrIt;
  for( addrIt = cctxAddrs.begin(); addrIt != cctxAddrs.end(); addrIt++ ){
    send__event_commitContextsMsg( addrIt->first, addrIt->second, myEvent.target_ctx_name, myEventId);
  }
  */
}

void ContextService::requestContextMigrationCommon(const uint8_t serviceID, const mace::string& contextName, const MaceAddr& destNode, const bool rootOnly){
  ADD_SELECTORS("ContextService::requestContextMigrationCommon");
  ASSERTMSG( contextMapping.getHead() == Util::getMaceAddr(), "Context migration is requested, but this physical node is not head node." );
  macedbg(1) << "Migrating context " << contextName << Log::endl;
  HeadEventDispatch::HeadEventTP::executeContextMigrationEvent(const_cast<ContextService*>(this), serviceID, contextName, destNode, rootOnly );
}


void ContextService::handle__event_MigrateContext( void *p ){
  // This function must be executed on headnode
  ADD_SELECTORS("ContextService::handle__event_MigrateContext");


  mace::__event_MigrateContext *msg = static_cast< mace::__event_MigrateContext * >( p );

  ThreadStructure::setEventID( msg->eventId );
  const mace::string& contextName = msg->contextName;
  const MaceAddr& destNode = msg->destNode;
  const bool rootOnly = msg->rootOnly;

  ASSERTMSG( rootOnly, "Now it only support to migrate context one by one!");

  mace::Event& newEvent = ThreadStructure::myEvent( );
  newEvent.newEventID( mace::Event::MIGRATIONEVENT );
  
  // 3. Then initializes the migration event

  newEvent.initialize3(contextName, contextMapping.getCurrentVersion()  );
  newEvent.addServiceID(instanceUniqueID);
  // 4. Get the latest contextmap snapshot to determine the existence of context.
  //    If it doesn't exist, just store the context and the destination node as the default mapping
  //    so that when the context is created in the future, it will be created at that node.
  const ContextMapping& ctxmapSnapshot = contextMapping.getLatestContextMapping( );
  if( !contextMapping.hasContext( contextName ) ){
    maceerr<<"Requested context does not exist. Ignore it but set it as the default mapping when the context is created in the future."<<Log::endl;
    mace::map<mace::MaceAddr ,mace::list<mace::string > > servContext;
    servContext[ destNode ].push_back( contextName );
    contextMapping.loadMapping( servContext );
    HeadEventDispatch::HeadEventTP::commitGlobalEvent( newEvent.eventId.ticket ); // commit
    return;
  }
  const MaceAddr& origNode = mace::ContextMapping::getNodeByContext( ctxmapSnapshot, contextName );
  // ignore the requests that migrate a context to its original physical node
  if( origNode == destNode ){
    maceerr << "ContextService::handle__event_MigrateContext: origNode=" << origNode << " destNode=" <<destNode << "for context " << contextName << Log::endl;
    HeadEventDispatch::HeadEventTP::commitGlobalEvent( newEvent.eventId.ticket ); // commit
    return;
  }
  // 5. Ok. Let's roll.
  //    Create a new version of context map. Update the event skip id
  //mace::Event::setLastContextMappingVersion( newEvent.eventId );
  const uint64_t prevContextMappingVersion = newEvent.eventContextMappingVersion;
  
  mace::map< uint32_t, mace::string > offsprings;
  std::pair<bool, uint32_t>  updatedContext;
  mace::map< mace::MaceAddr, mace::set<mace::string> > origContextAddrs;
  mace::map< mace::MaceAddr, mace::set<uint32_t> > origContextIdAddrs;
  const mace::ContextMapping& ctxMapping = contextMapping.getLatestContextMapping();
  mace::map<mace::MaceAddr ,mace::list<mace::string > > servContext;
  if( rootOnly ){
    //updatedContext = contextMapping.updateMapping( destNode, contextName ); 
    const uint32_t ctxId = mace::ContextMapping::hasContext2(ctxmapSnapshot, contextName);
    offsprings[ ctxId ] =  contextName;
    origContextAddrs[origNode].insert(contextName);
    origContextIdAddrs[origNode].insert(ctxId);
  }else{ // TODO: also update the mapping of child & all offspring contexts.
    // right now: support migrating the entire context subtree only if they all reside on the same physical node.
    mace::set< mace::string > offspringContextNames = contextStructure.getAllDecendantContexts(contextName);
    contextMapping.updateMapping< mace::set<mace::string> >( destNode, offspringContextNames );
    
    mace::set< mace::string >::const_iterator cIter = offspringContextNames.begin();
    
    for(; cIter != offspringContextNames.end(); cIter ++) {
      uint32_t ctxId = mace::ContextMapping::hasContext2(ctxMapping, *cIter);
      if( ctxId > 0) {
        const mace::MaceAddr& orig_addr = mace::ContextMapping::getNodeByContext(ctxMapping, *cIter);
        if( orig_addr != destNode ) {
          offsprings[ctxId] = *cIter;
          origContextAddrs[orig_addr].insert(*cIter);
          origContextIdAddrs[orig_addr].insert(ctxId);
          //contextMapping.updateMapping( destNode, *cIter );
        }
      }else {
        servContext[ destNode ].push_back( *cIter );
        //contextMapping.loadMapping( servContext );
      }
    } 
  }

  // Step 5, to notify the new node to accept possible messages for migration contexts

  HeadEventDispatch::HeadEventTP::setMigratingContexts( this, newEvent.eventId, offsprings, origContextAddrs, destNode );
  
  contextMapping.setUpdateFlag(false);
  macedbg(1) << "Now available ContextMapping("<< contextMapping.getCurrentVersion() <<")!" << Log::endl;
  if( servContext.size() > 0 ) {
    contextMapping.loadMapping( servContext );
  }

  // update contextMapping of head node
  mace::map< uint32_t, mace::string >::const_iterator offIter =  offsprings.begin();
  for(; offIter != offsprings.end(); offIter++ ) {
    contextMapping.updateMapping( destNode, offIter->second );
  }
  


  newEvent.eventContextMappingVersion = contextMapping.getCurrentVersion();
  const mace::ContextMapping* ctxmapCopy = contextMapping.getCtxMapCopy( ); 
  
  //macedbg(1)<<" The new version "<< newEvent.eventContextMappingVersion << " context map: "<< ctxmapCopy << Log::endl;
  // Step 6: to create Context Objects on new nodes 
  if( isLocal( destNode ) ){
    for( mace::map< uint32_t, mace::string >::const_iterator osIt = offsprings.begin(); osIt != offsprings.end(); osIt++ ){
      mace::ContextBaseClass* thisContext = createContextObjectWrapper( newEvent.eventId, osIt->second  , osIt->first, contextMapping.getLatestMappingVersion(), true );
      const mace::vector<mace::string> dominateContexts = contextStructure.getDominateContexts(thisContext->contextName);
      thisContext->initializeDominator(dominateContexts);
    }
  } else {
    send__event_AllocateContextObjectMsg( newEvent.eventId, *ctxmapCopy, destNode, offsprings, mace::Event::MIGRATIONEVENT, contextMapping.getLatestMappingVersion() ); 
  }
  
  HeadEventDispatch::HeadEventTP::waitingForMigrationContextMappingUpdate(this, origContextIdAddrs, destNode, 
    ThreadStructure::myEvent(), prevContextMappingVersion, *ctxmapCopy, newEvent.eventId);
  // Step 7: it could only update ContextMapping when migration event is executed
  macedbg(1) << "Release the latest ContextMapping("<< contextMapping.getCurrentVersion() <<")!" << Log::endl;
  //contextMapping.setUpdateFlag(true);
  
  delete ctxmapCopy;

  /*
  static bool recordFinishTime = params::get("EVENT_LIFE_TIME",false);
  if( recordFinishTime ){
    HeadEventDispatch::insertEventStartTime(newEvent.getEventID());
  }
  */

  delete msg;
}
void ContextService::sendAsyncSnapshot( __asyncExtraField const& extra, mace::string const& thisContextID, mace::ContextBaseClass* const& thisContext ){
  //ThreadStructure::myEvent().eventID = extra.event.eventID;
  mace::Event& myEvent = ThreadStructure::myEvent();
  mace::set<mace::string>::iterator snapshotIt = extra.snapshotContextIDs.find( thisContextID );
  if( snapshotIt != extra.snapshotContextIDs.end() ){
      mace::ContextLock ctxlock( *thisContext, ThreadStructure::myEventID(), false, mace::ContextLock::READ_MODE );// get read lock
      mace::string snapshot;// get snapshot
      mace::serialize(snapshot, thisContext );
      // send to the target context node.
      send__event_snapshot( contextMapping.getNodeByContext( extra.targetContextID ), myEvent,extra.targetContextID, *snapshotIt, snapshot );

      ctxlock.downgrade( mace::ContextLock::NONE_MODE );
  }else{
      mace::ContextLock ctxlock( *thisContext, ThreadStructure::myEventID(), false, mace::ContextLock::NONE_MODE );// get read lock
  }
}
// helper functions for maintaining context mapping
void ContextService::loadContextMapping(const mace::map<mace::MaceAddr ,mace::list<mace::string > >& servContext){
    contextMapping.setDefaultAddress ( Util::getMaceAddr() );
    contextMapping.loadMapping( servContext );
    contextMapping.snapshot( static_cast<uint64_t>( 0 ) );
}
void ContextService::downgradeContext( mace::string const& contextName ) {
  // TODO: 
  //(1) assert: the event has acquired the context before.
  const mace::ContextMapping& currentMapping = contextMapping.getSnapshot();
  const mace::Event::EventServiceContextType& eventContexts = ThreadStructure::getCurrentServiceEventContexts();
  const uint32_t contextID = currentMapping.findIDByName( contextName );
  ASSERTMSG( eventContexts.find( contextID ) != eventContexts.end(), "The event does not have the context" );   
  mace::AccessLine::checkDowngradeContext( instanceUniqueID, contextID, currentMapping );
  //(2) figure out the physical address of the context
  //(3) if it's local, call it. If not, send message and wait for response
  send__event_downgrade_context( mace::ContextMapping::getNodeByContext( currentMapping, contextID ), ThreadStructure::getCurrentContext(), ThreadStructure::myEvent().eventId, false );

  ThreadStructure::removeEventContext( ThreadStructure::getCurrentContext() );
}
/*
void ContextService::requestRouteEvent ( __asyncExtraField& extra, mace::Event& event, mace::Serializable& msg ) const{
  ADD_SELECTORS("ContextService::requestRouteEvent");
  static uint32_t counter = 0;
  mace::string* msg_str = new mace::string();
  mace::string event_str;
  mace::serialize(*msg_str, &msg);
  mace::serialize(event_str, &event);
  ScopedLock sl( eventRequestBufferMutex );
  uint32_t req_counter = counter;
  ASSERT( unfinishedEventRequest.find(req_counter) == unfinishedEventRequest.end() );
  unfinishedEventRequest[req_counter] =  std::pair<mace::string*,mace::string>(msg_str, event_str);
  counter ++;
  sl.unlock();

  const mace::string& start_ctx_name = contextStructure.getUpperBoundContextName(extra.targetContextID);
  const uint32_t ctxId = contextMapping.findIDByName(start_ctx_name);
  const mace::MaceAddr& addr = contextMapping.getNodeByContext(start_ctx_name);

  maceout<<"sending out event creation request. "<< extra<< ", counter = "<< req_counter << Log::endl;
  const_send__event_create( addr, extra, req_counter, ctxId);
}
*/
void ContextService::migrateContext( mace::string const& paramid ){
  send__event_migrate_param( paramid );
}
void ContextService::deleteContext( mace::string const& contextName ){
  send__event_delete_context( contextName );
}
void ContextService::__beginRemoteMethod( mace::Event const& event) const {
  ADD_SELECTORS("ContextService::__beginRemoteMethod");
  //macedbg(1) << "Event = " <<event.eventId << Log::endl;
  ThreadStructure::setEvent( event );
}
void ContextService::__finishRemoteMethodReturn( mace::MaceAddr const& src, mace::string const& returnValueStr ) const{
  send__event_routine_return( src, returnValueStr );
}
void ContextService::__appUpcallReturn( mace::MaceKey const& src, mace::string const& returnValueStr ) const{
  send__event_routine_return( src.getMaceAddr(), returnValueStr );
}
void ContextService::nullEventHead( void *p ){
  mace::NullEventMessage* nullEventMessage = static_cast< mace::NullEventMessage* >( p );
  __asyncExtraField extra;
  //uint32_t contextID;
  //asyncHead( nullEventMessage->getEvent(), extra, mace::Event::UNDEFEVENT, contextID );
  HeadEventDispatch::HeadEventTP::commitEvent( nullEventMessage->getEvent() ); // commit

  delete nullEventMessage;
}
void ContextService::wasteTicket( void ) const{
  mace::NullEventMessage* nullEventMessage = new mace::NullEventMessage( ThreadStructure::myEventID() );
  HeadEventDispatch::HeadEventTP::executeEvent( const_cast<ContextService*>(this), (HeadEventDispatch::eventfunc)&ContextService::nullEventHead, nullEventMessage, true ); 
}
void ContextService::notifyHeadExit(){
  bool isOuterMostTransition = ( instanceUniqueID == instanceID.size()-1  )?true: false;
  if( isOuterMostTransition ){
    if( isLocal( mace::ContextMapping::getHead(contextMapping) ) ){
      //mace::Event& myEvent = ThreadStructure::myEvent();
      //HeadEventDispatch::HeadEventTP::commitEvent( myEvent );
      // wait to confirm the event is committed.
      // remind other physical nodes the exit event has committed.
      const mace::map< MaceAddr, uint32_t >& nodes = contextMapping.getAllNodes();
      for( mace::map< MaceAddr, uint32_t >::const_iterator nodeIt = nodes.begin(); nodeIt != nodes.end(); nodeIt ++ ){
        if( isLocal( nodeIt->first ) ) continue;
        mace::InternalMessage msg( mace::exit_committed );
        sender->sendInternalMessage( nodeIt->first, msg );
      }
    }else{
      // wait for exit event to commit.
      waitExit();
    }
  }
}
void ContextService::processRPCApplicationUpcall( mace::ApplicationUpcall_Message* msg, MaceAddr const& src){
  // make sure this is the head node.
  ASSERT( contextMapping.getHead() == Util::getMaceAddr() );
  ThreadStructure::ScopedContextID sci( mace::ContextMapping::HEAD_CONTEXT_ID );

  mace::OrderID commitEventId;
  commitEventId.ctxId = ThreadStructure::myEventID().ctxId;
  commitEventId.ticket = ThreadStructure::myEventID().ticket-1;

  mace::AgentLock::waitAfterCommit( commitEventId );
  // wait until this event becomes the next to commit
  //
  // set up the current event
  //ThreadStructure::setEvent( msg->getEvent() );
  //
  // execute unprocessed application upcalls (which do not have return value)
  // and clear upcalls in the event
  ThreadStructure::myEvent().executeApplicationUpcalls();
  //
  // return back ( return value and update event )
  mace::string returnValue;
  this->executeDeferredUpcall( msg, returnValue );
  mace::InternalMessage m( mace::appupcall_return, returnValue, ThreadStructure::myEvent() );
  sender->sendInternalMessage( src, m);
}
void ContextService::processLocalRPCApplicationUpcall( mace::ApplicationUpcall_Message* msg, mace::string& returnValue ){
  ASSERT( contextMapping.getHead() == Util::getMaceAddr() );
  ThreadStructure::ScopedContextID sci( mace::ContextMapping::HEAD_CONTEXT_ID );

  mace::OrderID commitEventId;
  commitEventId.ctxId = ThreadStructure::myEventID().ctxId;
  commitEventId.ticket = ThreadStructure::myEventID().ticket-1;
  mace::AgentLock::waitAfterCommit( commitEventId );
  // wait until this event becomes the next to commit
  //
  // set up the current event
  //ThreadStructure::setEvent( msg->getEvent() );
  //
  // execute unprocessed application upcalls (which do not have return value)
  // and clear upcalls in the event
  ThreadStructure::myEvent().executeApplicationUpcalls();
  //
  // return back ( return value and update event )
  this->executeDeferredUpcall( msg, returnValue );
}

/*
void ContextService::addTransportEventRequest( mace::AsyncEvent_Message* reqObj, mace::MaceKey const& src){
  
  ADD_SELECTORS("ContextService::addTransportEventRequest");
  checkAndWaitExternalMessageHandle();
  const mace::ContextMapping& ctxsnapshotMapping = contextMapping.getLatestContextMapping();
  mace::string commCtxName = getExternalCommContextName(src);
  // macedbg(1) << "Context("<< src <<")'s external communication context: " << commCtxName << Log::endl;
  if( commCtxName == mace::ContextMapping::GLOBAL_CONTEXT_NAME) {
    ASSERT( mace::ContextMapping::getHead(ctxsnapshotMapping) == Util::getMaceAddr() );
  }

  if(reqObj->getExtra().targetContextID == "") {
    reqObj->getExtra().targetContextID = commCtxName;
  } else {
    if( commCtxName == mace::ContextMapping::GLOBAL_CONTEXT_NAME && clientFlag ) {
      commCtxName = reqObj->getExtra().targetContextID;
    }
  }

  mace::ContextBaseClass* ctxObj = getContextObjByName(commCtxName);
  ASSERT(ctxObj != NULL);
  mace::Event& event = reqObj->getEvent();
  mace::OrderID eventId = ctxObj->newCreateTicket();
  macedbg(1) << "Event("<< eventId <<")'s external comm context is " << commCtxName <<" msg="<< *reqObj << Log::endl;

  signalExternalMessageThread();
  ctxObj->createEvent(this, eventId, event, reqObj->getExtra().targetContextID, mace::Event::ASYNCEVENT);

  //signalExternalMessageThread();

  //delete reqObj;
  uint32_t contextId;
  asyncHead( reqObj, contextId );

}
*/

void ContextService::addTransportEventRequest( mace::AsyncEvent_Message* reqObj, mace::MaceKey const& src){
  
  ADD_SELECTORS("ContextService::addTransportEventRequest");
  checkAndWaitExternalMessageHandle();
  ExternalCommClass* exCommClass = getExternalCommClass();
  // macedbg(1) << "Context("<< src <<")'s external communication context: " << commCtxName << Log::endl;
  
  if(reqObj->getExtra().targetContextID == "") {
    reqObj->getExtra().targetContextID = mace::ContextMapping::GLOBAL_CONTEXT_NAME;
  } 
  signalExternalMessageThread();
  
  mace::Event& event = reqObj->getEvent();
  exCommClass->createEvent(this, event, reqObj->getExtra().targetContextID, false, instanceUniqueID);

  //signalExternalMessageThread();

  //delete reqObj;
  uint32_t contextId;
  asyncHead( reqObj, contextId );

}

void ContextService::addTimerEvent( mace::AsyncEvent_Message* reqObject){
  HeadEventDispatch::HeadEventTP::executeEvent(this,(HeadEventDispatch::eventfunc)&ContextService::createEvent, reqObject, false );
}
void ContextService::forwardHeadTransportThread( mace::MaceAddr const& dest, mace::AsyncEvent_Message* const eventObject ){
    HeadEventDispatch::HeadTransportTP::sendEvent( sender, dest, eventObject, instanceUniqueID );
}

bool ContextService::addNewCreateContext( mace::string const& ctx_name, const mace::MaceAddr& src) {
  ADD_SELECTORS("ContextService::addNewCreateContext");
  macedbg(1) << "Add new create context: " << ctx_name << Log::endl;
  ScopedLock sl(createNewContextMutex);
  mace::map< mace::string, mace::vector<mace::MaceAddr> >::iterator iter = processContextCreate.find(ctx_name);
  if( iter == processContextCreate.end() ) {
    macedbg(1) << "The context creation process is not started: " << ctx_name << Log::endl;
    mace::vector<mace::MaceAddr> addrs;
    addrs.push_back(src);
    processContextCreate[ctx_name] = addrs;
    return true;
  } else {
    iter->second.push_back(src);
    macedbg(1) << "The context creation process is already started: " << ctx_name << Log::endl;
    return false;
  }
}

bool ContextService::hasNewCreateContext( const mace::string& ctxName ) {
  ADD_SELECTORS("ContextService::hasNewCreateContext");
  macedbg(1) << "Check existence for " << ctxName << Log::endl;
  ScopedLock sl(createNewContextMutex);
  mace::map< mace::string, mace::vector<mace::MaceAddr> >::iterator iter = processContextCreate.find(ctxName);
  if( iter == processContextCreate.end() ) {
    macedbg(1) << "Exists! " << ctxName << Log::endl;
    return false;
  } else {
    macedbg(1) << "no Exists! " << ctxName << Log::endl;
    return true;
  }
}

void ContextService::notifyContextMappingUpdate(mace::string const& ctxName) {
  ADD_SELECTORS("ContextService::notifyContextMappingUpdate #1");
  ScopedLock sl(createNewContextMutex);

  mace::map< mace::string, mace::vector<mace::MaceAddr> >::iterator iter = processContextCreate.find(ctxName);
  if( iter == processContextCreate.end() ) {
    return;
  } else {
    mace::vector< mace::MaceAddr >& addrs = iter->second;
    const mace::ContextMapping& currentMapping = contextMapping;
    for( mace::vector<mace::MaceAddr>::const_iterator addr_iter = addrs.begin(); addr_iter != addrs.end(); addr_iter ++) {
      mace::InternalMessage msg(mace::UpdateContextMapping, currentMapping, ctxName);
      forwardInternalMessage( *addr_iter, msg);
    }
    macedbg(1) << "Notify waiting thread context(" << ctxName << ") has been created!" << Log::endl;
    processContextCreate.erase(iter);    
  }
}

void ContextService::notifyContextMappingUpdate(mace::string const& ctxName, const mace::MaceAddr& src) {
  const mace::ContextMapping& currentMapping = contextMapping.getLatestContextMapping();
  mace::InternalMessage msg(mace::UpdateContextMapping, currentMapping, ctxName);
  forwardInternalMessage( src, msg);
}


void ContextService::executeRoutineGrap( mace::Routine_Message* routineobject, mace::MaceAddr const& source ) {
  /*
  __beginRemoteMethod( routineobject->getEvent() );
  mace::Event& event = routineobject->getEvent();
  const mace::ContextMapping* snapshotContext = & ( contextMapping.getSnapshot() );
  const uint32_t ctxId = ContextMapping::hasContext2(*snapshotContext, event.curToContextName);
  ASSERT( ctxId >0 );

  mace::__ScopedRoutine__ p( this, ctxId, false );
  

  const mace::string& next_ctx_name =  contextStructure.nextSingleRootNodeOnPath(event.curToContextName, event.routine_target_ctx_name); 
  if( next_ctx_name == "" ) {
    return;
  }

  event.curToContextName = next_ctx_name;
  
  mace::InternalMessageID msgId( Util::getMaceAddr(), next_ctx_name, 0);
  mace::InternalMessage* im = new mace::InternalMessage(routineobject, msgId, instanceUniqueID);
  forwardInternalMessage(mace::ContextMapping::getNodeByContext( *snapshotContext, next_ctx_name),  *im);
  */
}

void ContextService::executeCommitContext( mace::commit_single_context_Message* const msg ) {
  /*
  ADD_SELECTORS("ContextService::executeCommitContext");
  macedbg(1) << "contextId = " << msg->ctxId << " Event = " << msg->eventId << Log::endl;
  const uint32_t ctxId = msg->ctxId;
  const mace::set<mace::string>& accessCtxs = msg->accessCtxs;
  mace::ContextBaseClass* ctxObj = this->getContextObjByID(ctxId);
  ASSERT(ctxObj != NULL);

  ctxObj->executedEvent(this, msg->eventId, false);
  ctxObj->commitEvent2(msg->eventId, false);

  if( !contextStructure.hasContextNode(ctxObj->contextName) ) {
    macedbg(1) << "Fail to find Context("<< ctxObj->contextName<<"). Try to update ContextStructure!" << Log::endl;
    getUpdatedContextStructure(0);
    ASSERT( contextStructure.hasContextNode(ctxObj->contextName) );
  }

  mace::vector< mace::string > children_ctxs = contextStructure.getAllChildContexts(ctxObj->contextName);
  macedbg(1) << "children contexts: " << children_ctxs << Log::endl;
  const mace::ContextMapping& snapshotMapping = this->contextMapping.getLatestContextMapping();
  
  mace::map< mace::MaceAddr, mace::vector<uint32_t> > cctxAddrs;    
    //macedbg(1)<<"cut="<< cut << Log::endl;
  for( mace::vector< mace::string >::const_iterator cctxIt = children_ctxs.begin(); cctxIt != children_ctxs.end(); cctxIt ++ ){
    const mace::string& cctxName = *cctxIt;
    if( accessCtxs.count(cctxName) == 0 ) {
      continue;
    }
    uint32_t cctxId = ContextMapping::hasContext2(snapshotMapping, cctxName);
    if( cctxId == 0) {
      mace::__asyncExtraField extra;
      extra.targetContextID = cctxName;

      asyncHead( ThreadStructure::myEvent(), extra, msg->eventType, cctxId);
    }

    const mace::ContextMapping& newMapping = contextMapping.getLatestContextMapping();
    const mace::MaceAddr& cctxAddr = mace::ContextMapping::getNodeByContext( newMapping, cctxId );
    mace::map< mace::MaceAddr, mace::vector<uint32_t> >::iterator addr_iter = cctxAddrs.find(cctxAddr);
    if( addr_iter == cctxAddrs.end() ) {
      mace::vector<uint32_t> cctxIds;
      cctxIds.push_back(cctxId);
      cctxAddrs[cctxAddr] = cctxIds;
    } else {
      addr_iter->second.push_back(cctxId);
    }
  }
    //macedbg(1)<<"nextHops="<< nextHops << Log::endl;
  mace::map< mace::MaceAddr , mace::vector< uint32_t > >::iterator addrIt;
  for( addrIt = cctxAddrs.begin(); addrIt != cctxAddrs.end(); addrIt++ ){
    const_send__event_commit_context( addrIt->first, addrIt->second, msg->eventId, msg->eventType, msg->eventContextMappingVersion, 
      msg->eventOrderRecords, msg->isresponse, msg->hasException, msg->exceptionContextId, msg->accessCtxs, msg->bEventId );
  }
  */
}

void ContextService::executeBroadcastCommitContext( mace::commit_single_context_Message* const msg ) {
  /*
  ADD_SELECTORS("ContextService::executeBroadcastCommitContext");
  macedbg(1) << "contextId = " << msg->ctxId << " Event = " << msg->eventId << Log::endl;
  const uint32_t ctxId = msg->ctxId;
  const mace::set<mace::string>& accessCtxs = msg->accessCtxs;
  mace::ContextBaseClass* ctxObj = this->getContextObjByID(ctxId);
  ASSERT( ctxObj != NULL );
  uint64_t executeTicket = ctxObj->getExecuteEventTicket(msg->eventId);

  if( executeTicket > 0 ) { //the event is holding the context 
    macedbg(1) << "Broadcast Event(" << msg->eventId << ") is holding context " << ctxObj->contextName <<" executeTicket="<< executeTicket <<" now_serving_execute_ticket=" << ctxObj->now_serving_execute_ticket << Log::endl;
      
    ctxObj->executedEvent(this, msg->eventId, true);
    ctxObj->commitEvent2(msg->eventId, true);
    ASSERT( executeTicket == ctxObj->now_serving_execute_ticket );

    mace::Event event;
    event.eventId = msg->eventId;
    //event.eventOrderRecords = msg->eventOrderRecords;
    event.eventType = msg->eventType;
      //event.eventContextMappingVersion = msg->eventContextMappingVersion;

    ThreadStructure::setEvent(event);
    __beginCommitContext(ctxObj->contextId);
    __finishCommitContext(ctxObj);

    ctxObj->commitEventDone(msg->eventId);

    mace::vector< mace::string > children_ctxs = contextStructure.getAllChildContexts(ctxObj->contextName);
    const mace::ContextMapping& snapshotMapping = getLatestContextMapping();
  
    mace::map< mace::MaceAddr, mace::vector<uint32_t> > cctxAddrs;    
    
    for( mace::vector< mace::string >::const_iterator cctxIt = children_ctxs.begin(); cctxIt != children_ctxs.end(); cctxIt ++ ){
      const mace::string& cctxName = *cctxIt;
      if( msg->accessCtxs.count(cctxName) == 0) {
        continue;
      }

      const uint32_t cctxId = ContextMapping::hasContext2(snapshotMapping, cctxName);
      if( cctxId == 0) {
        continue;
      }
      const mace::MaceAddr& cctxAddr = mace::ContextMapping::getNodeByContext( snapshotMapping, cctxId );
      mace::map< mace::MaceAddr, mace::vector<uint32_t> >::iterator addr_iter = cctxAddrs.find(cctxAddr);
      if( addr_iter == cctxAddrs.end() ) {
        mace::vector<uint32_t> cctxIds;
        cctxIds.push_back(cctxId);
        cctxAddrs[cctxAddr] = cctxIds;
      } else {
        addr_iter->second.push_back(cctxId);
      }
    }
    //macedbg(1)<<"nextHops="<< nextHops << Log::endl;
    mace::map< mace::MaceAddr , mace::vector< uint32_t > >::iterator addrIt;
    for( addrIt = cctxAddrs.begin(); addrIt != cctxAddrs.end(); addrIt++ ){
      const_send__event_commit_context( addrIt->first, addrIt->second, msg->eventId, msg->eventType, msg->eventContextMappingVersion, 
        msg->eventOrderRecords, msg->isresponse, msg->hasException, msg->exceptionContextId, msg->accessCtxs, msg->bEventId );
    }
    ctxObj->contextBroadcastEventsInfo.removeBroadcastEventInfo(event.eventId);
    return;
  }

  ctxObj->executedEvent(this, msg->eventId, false);
  ctxObj->commitEvent2(msg->eventId, false);

  mace::vector< mace::string > children_ctxs = contextStructure.getAllChildContexts(ctxObj->contextName);
  macedbg(1) << "children contexts: " << children_ctxs << Log::endl;
  const mace::ContextMapping& snapshotMapping = this->contextMapping.getLatestContextMapping();
  
  mace::map< mace::MaceAddr, mace::vector<uint32_t> > cctxAddrs;    
    //macedbg(1)<<"cut="<< cut << Log::endl;
  for( mace::vector< mace::string >::const_iterator cctxIt = children_ctxs.begin(); cctxIt != children_ctxs.end(); cctxIt ++ ){
    const mace::string& cctxName = *cctxIt;
    if( accessCtxs.count(cctxName) == 0 ) {
      continue;
    }
    uint32_t cctxId = ContextMapping::hasContext2(snapshotMapping, cctxName);
    if( cctxId == 0) {
      mace::__asyncExtraField extra;
      extra.targetContextID = cctxName;

      asyncHead( ThreadStructure::myEvent(), extra, msg->eventType, cctxId);
    }

    const mace::ContextMapping& newMapping = contextMapping.getLatestContextMapping();
    const mace::MaceAddr& cctxAddr = mace::ContextMapping::getNodeByContext( newMapping, cctxId );
    mace::map< mace::MaceAddr, mace::vector<uint32_t> >::iterator addr_iter = cctxAddrs.find(cctxAddr);
    if( addr_iter == cctxAddrs.end() ) {
      mace::vector<uint32_t> cctxIds;
      cctxIds.push_back(cctxId);
      cctxAddrs[cctxAddr] = cctxIds;
    } else {
      addr_iter->second.push_back(cctxId);
    }
  }
    //macedbg(1)<<"nextHops="<< nextHops << Log::endl;
  mace::map< mace::MaceAddr , mace::vector< uint32_t > >::iterator addrIt;
  for( addrIt = cctxAddrs.begin(); addrIt != cctxAddrs.end(); addrIt++ ){
    const_send__event_commit_context( addrIt->first, addrIt->second, msg->eventId, msg->eventType, msg->eventContextMappingVersion, 
      msg->eventOrderRecords, msg->isresponse, msg->hasException, msg->exceptionContextId, msg->accessCtxs, msg->bEventId );
  }
  ctxObj->contextBroadcastEventsInfo.removeBroadcastEventInfo(msg->eventId);
  */
}

void ContextService::executeStartEvent( mace::AsyncEvent_Message* async_msg ) {
  ADD_SELECTORS("ContextService::executeStartEvent");
  ASSERTMSG(false, "In ContextService::executeStartEvent");
  /*
  mace::Event& event = async_msg->getEvent();
  __beginRemoteMethod( event );

  const mace::ContextMapping& snapshotContext = contextMapping.getLatestContextMapping() ;
  
  mace::ContextBaseClass* ctxObj = this->getContextObjByName(event.start_ctx_name);
  ASSERT(ctxObj != NULL );
  ThreadStructure::setMyContext(ctxObj);

  mace::ContextLock __beginContextLock( *ctxObj, event.eventId, false, mace::ContextLock::WRITE_MODE);
  ctxObj->executedEvent(this, event.eventId);
  event.curTarget_ctx_name = event.target_ctx_name;
  mace::InternalMessageID msgId(Util::getMaceAddr(), event.target_ctx_name, 0);
  macedbg(1) << "Executed event("<< event.eventId<<") in start context("<< ctxObj->contextName <<") and then go to target context("<< event.target_ctx_name<<")!" << Log::endl;
  mace::InternalMessage m(async_msg, msgId, instanceUniqueID);
  forwardInternalMessage( mace::ContextMapping::getNodeByContext( snapshotContext, event.target_ctx_name),  m);
  mace::ContextLock __endContextLock( *ctxObj, event.eventId, false, mace::ContextLock::RELEASE_WRITE_MODE);
  */
}

void ContextService::checkAndUpdateContextMapping(const uint64_t contextMappingVer) {
  ADD_SELECTORS("ContextService::checkAndUpdateContextMapping");
  ScopedLock sl(contextMappingUpdateMutex);
  if( contextMappingVer <= contextMapping.getCurrentVersion() || contextMappingUpdatingFlag ) {
    return;
  }
  macedbg(1) << "Current version=" << contextMapping.getCurrentVersion() << " expectVersion=" << contextMappingVer << Log::endl;
  contextMappingUpdatingFlag = true;
  sl.unlock();
  
  //getUpdatedContextMapping(contextMappingVer);
  getUpdatedContextMapping(0);
  macedbg(1) << "Get updated context mapping!" << Log::endl;
  sl.lock();
  contextMappingUpdatingFlag = false;
}

void ContextService::checkAndUpdateContextStructure(const uint64_t contextStructureVer) {
  ScopedLock sl(contextStructureUpdateMutex);
  if( contextStructureVer <= contextStructure.getCurrentVersion() || contextStructureUpdatingFlag ) {
    return;
  }
  contextStructureUpdatingFlag = true;
  sl.unlock();
  getUpdatedContextStructure(0);

  sl.lock();
  contextStructureUpdatingFlag = false;
}

void ContextService::modifyOwnership( const uint8_t opType, mace::string const& parentContextName, mace::string const& childContextName ) {
  ADD_SELECTORS("ContextService::modifyOwnership");
  mace::ContextBaseClass* ctxObj = ThreadStructure::myContext();
  mace::Event& myEvent = ThreadStructure::myEvent();
  macedbg(1) << "Event("<< myEvent.eventId <<") modify ownership: type="<< (uint32_t)opType<<", p="<<parentContextName << ", c="<<childContextName<<Log::endl; 
  

  mace::EventOperationInfo opInfo(myEvent.eventId, opType, childContextName, parentContextName, 0, false);
  //myEvent.enqueueOwnershipOpInfo(opInfo);
  ctxObj->enqueueOwnershipOpInfo(myEvent.eventId, opInfo);
}

void ContextService::addMigratingContextName( mace::string const& ctx_name ) {
  ADD_SELECTORS("ContextService::addMigratingContextName");
  macedbg(1) << "Try to add context: " << ctx_name <<" count=" << receivedExternalMsgCount << Log::endl;
  ScopedLock sl(migratingContextMutex);
  receivedExternalMsgCount += 4;
  if( migratingContextNames.count(ctx_name) == 0 ) {
    migratingContextNames.insert(ctx_name);
    macedbg(1) << "Adding migrating context " << ctx_name << Log::endl;
  }
  isContextMigrating = true;
  receivedExternalMsgCount -= 4;
}

void ContextService::releaseBlockedMessageForMigration( mace::set<mace::string> const& migrate_contexts) {
  ADD_SELECTORS("ContextService::releaseBlockedMessageForMigration");
  macedbg(1) << "Migrating contexts=" << migrate_contexts << Log::endl;
  ScopedLock sl(migratingContextMutex);
  receivedExternalMsgCount += 3;

  const mace::ContextMapping& ctxMapping = contextMapping.getLatestContextMapping();
  mace::set<mace::string>::const_iterator iter = migrate_contexts.begin();
  for(; iter != migrate_contexts.end(); iter++) {
    const mace::string& ctxName = *iter;
    migratingContextNames.erase(*iter);
    std::map<mace::string, std::set<mace::InternalMessage*> >::iterator mIter = holdingMessageForMigration.find(*iter);
    if( mIter != holdingMessageForMigration.end()) {

      const MaceAddr& dest = mace::ContextMapping::getNodeByContext(ctxMapping, *iter);
      std::set<mace::InternalMessage*>& msgs = mIter->second;
      macedbg(1) << "Migrating context("<< mIter->first<<") has " << msgs.size() << " blocking messages!" << Log::endl;
      std::set<mace::InternalMessage*>::const_iterator msg_iter = msgs.begin();
      for(; msg_iter != msgs.end(); msg_iter ++) {
        forwardInternalMessage(dest, *(*msg_iter));
      }
      holdingMessageForMigration.erase(mIter);
    } else {
      macedbg(1) << "Migrating context("<< *iter <<") has no blocking messages!" << Log::endl;
    }

    mIter = holdingMessageForCommingContexts.find(*iter);
    commingContexts.erase(ctxName);
    macedbg(1) << "Delete incomming Context " << ctxName << Log::endl;

    uint32_t ctxId = mace::ContextMapping::hasContext2(ctxMapping, ctxName);
    commingContextsMap.erase(ctxId);

    if( mIter != holdingMessageForCommingContexts.end() ) {
      const MaceAddr& dest = mace::ContextMapping::getNodeByContext(ctxMapping, *iter);
      std::set<mace::InternalMessage*>& msgs = mIter->second;
      macedbg(1) << "Incomming context("<< mIter->first<<") has " << msgs.size() << " blocking messages!" << Log::endl;
      
      std::set<mace::InternalMessage*>::const_iterator msg_iter = msgs.begin();
      for(; msg_iter != msgs.end(); msg_iter ++) {
        forwardInternalMessage(dest, *(*msg_iter));
      }
      holdingMessageForCommingContexts.erase(mIter);
    } else {
      macedbg(1) << "Incomig context("<< *iter <<") has no blocking messages!" << Log::endl;
    }
  }

  if( commingContexts.size() == 0) {
    isContextComming = false;
  }

  if( migratingContextNames.size() == 0) {
    isContextMigrating = false;
  }
  macedbg(1) << "Done unblock messages!" << Log::endl;

  receivedExternalMsgCount -= 3;
}

bool ContextService::checkMigratingContext(mace::InternalMessage const& message) {
  ADD_SELECTORS("ContextService::checkMigratingContext");
  
  const mace::string& ctxName = message.getTargetContextName();
  if( migratingContextNames.count(ctxName) ) {
    mace::InternalMessage* mptr = new mace::InternalMessage(message);
    message.unlinkHelper();

    holdingMessageForMigration[ctxName].insert(mptr);
    macedbg(1) << "Keep a message for migrating context "<< ctxName << Log::endl;
    return true;
  }
  return false;
}
bool ContextService::checkCommingContext(mace::InternalMessage const& message) {
  ADD_SELECTORS("ContextService::checkCommingContext");
  
  const mace::string& ctxName = message.getTargetContextName();
  if( commingContexts.count(ctxName) ) {
    mace::InternalMessage* mptr = new mace::InternalMessage( message );
    message.unlinkHelper();

    holdingMessageForCommingContexts[ctxName].insert(mptr);
    macedbg(1) << "Keep a message("<< (void*)mptr <<") for incomming context "<< ctxName << Log::endl;
    return true;
  }
  return false;
}

void ContextService::newBroadcastEventID() {
  /*
  ADD_SELECTORS("ContextService::newBroadcastEventID");
  mace::ContextBaseClass* ctxObj = ThreadStructure::myContext();
  mace::Event& event = ThreadStructure::myEvent();
  
  mace::OrderID oldBroadcastId = event.getBroadcastEventID();
  mace::OrderID newBroadcastId = event.newBroadcastEventID( ctxObj->getID() );
  event.setBroadcastEventID(newBroadcastId);
  event.setPreBroadcastEventID(oldBroadcastId);

  macedbg(1) << "oldBroadcastId=" << oldBroadcastId << " newBroadcastId=" << newBroadcastId << Log::endl;
  
  if( oldBroadcastId.ticket > 0 ) {
    downgradeBroadcastEvent(ctxObj->contextName, event.eventId, oldBroadcastId, contextStructure.getBroadcastCPRelations(ctxObj->contextName), 
      ctxObj->contextBroadcastEventsInfo.getBroadcastTargetContextNames(event.eventId, oldBroadcastId) );
  }
  */
}

void ContextService::downgradeBroadcastEvent( mace::string const& ctxName, mace::OrderID const& eventId, mace::OrderID const& bEventId, 
    mace::map<mace::string, mace::set<mace::string> > const& cpRelations, mace::set<mace::string> const& targetContextNames ) const {

  ADD_SELECTORS("ContextService::downgradeBroadcastEvent");
/*  
  mace::vector<mace::string> children = contextStructure.getAllChildContexts(ctxName);
  const mace::ContextMapping& ctxMapping = contextMapping.getLatestContextMapping();
  for( uint32_t i=0; i<children.size(); i++ ) {
    uint32_t cctxId = ContextMapping::hasContext2(ctxMapping, children[i]);
    if( cctxId == 0) {
      mace::__asyncExtraField extra;
      extra.targetContextID = children[i];

      mace::Event myEvent;
      ContextService* _service = const_cast<ContextService*>(this);
      _service->asyncHead( myEvent, extra, mace::Event::BROADCASTCOMMITEVENT, cctxId);
      
    }
    const mace::ContextMapping& newCtxMapping = contextMapping.getLatestContextMapping();
    const mace::MaceAddr& dest = mace::ContextMapping::getNodeByContext(newCtxMapping, children[i]);

    macedbg(1) << "Send broadcast commit message("<< eventId <<") from " << ctxName << " to "<< children[i] << Log::endl;
    send__event_BroadcastControlMsg(dest, ctxName, children[i], 0, eventId, bEventId, cpRelations, targetContextNames);
  } 
*/   
}

void ContextService::executeEventBroadcastRequest( mace::AsyncEvent_Message* reqObj ) {
  ADD_SELECTORS("ContextService::executeEventBroadcastRequest");

  mace::__asyncExtraField& extra = reqObj->getExtra();
  mace::Event& event = ThreadStructure::myEvent();
  mace::Event& reqEvent = reqObj->getEvent();
  ASSERT( !extra.targetContextID.empty() );
  mace::ContextBaseClass* ctxObj = ThreadStructure::myContext();
  ASSERT( ctxObj != NULL );

  macedbg(1) << "Event("<< event.eventId <<") make a broadcast call to context("<< extra.targetContextID <<") from context("<< ctxObj->contextName <<")!" << Log::endl;

  mace::vector<mace::EventOperationInfo> ownershipOpInfos = ctxObj->extractOwnershipOpInfos(event.eventId);
  if( ownershipOpInfos.size() > 0 ) {
    ctxObj->applyOwnershipOperations( this, event.eventOpInfo, ownershipOpInfos);
  }

  //macedbg(1) << "Event("<< event.eventId<<") launch a broadcast request("<< event.getBroadcastEventID() <<") from "<< ctxObj->contextName <<" to " << extra.targetContextID << Log::endl;
  
  // if( !contextStructure.hasContextNode(extra.targetContextID) ) {
  //   if( ctxObj->checkParentChildRelation(event.eventId, ctxObj->contextName, extra.targetContextID) ) {
  //     mace::EventOperationInfo oop = ctxObj->getNewContextOwnershipOp( event.eventId, ctxObj->contextName, extra.targetContextID );      
  //     ASSERT( oop.opType != mace::EventOperationInfo::NULL_OP );

  //     mace::vector< mace::EventOperationInfo > oops;
  //     oops.push_back(oop);

  //     ctxObj->applyOwnershipOperations( this, event.eventOpInfo, oops );
  //   } else {
  //     getUpdatedContextStructure(0);
  //     if( !contextStructure.hasContextNode(extra.targetContextID) ){
  //       maceerr << "Context("<< ctxObj->contextName <<") is not Context("<< extra.targetContextID<<")'s parent!!" << Log::endl;
  //       ASSERT(false);
  //     }
  //   }
  // }

  //ASSERT( contextStructure.hasContextNode(extra.targetContextID) );

  if( !contextStructure.checkParentChildRelation(ctxObj->contextName, extra.targetContextID) ) {
    this->getUpdatedContextStructure(0);
    if( !contextStructure.checkParentChildRelation(ctxObj->contextName, extra.targetContextID) ) {
      maceerr << "Context("<< ctxObj->contextName <<") is not Context("<< extra.targetContextID <<")'s parent!!" << Log::endl;
      ASSERT(false);
    }
  }

  const uint32_t op_ticket = ctxObj->getNextOperationTicket(event.eventId);
  
  mace::EventOperationInfo op_info( event.eventId, mace::EventOperationInfo::BROADCAST_OP, extra.targetContextID, ctxObj->contextName, op_ticket, event.isReadOnly);
  reqEvent = event;
  reqEvent.eventType = mace::Event::BROADCASTEVENT;
  reqEvent.eventOpInfo = op_info;
  reqEvent.ownershipOps.clear();

  ctxObj->addEventToContext( event.eventId, extra.targetContextID );
  if( ctxObj->checkBroadcastRequestExecutePermission(this, op_info, reqObj) ) {
    broadcastHead(reqObj);
  } 
}

bool ContextStructure::addParentChildRelationNoLock( mace::string const& parent_ctx_name,  ContextStructureNode* child_node ) {
  ADD_SELECTORS("ContextStructure::addParentChildRelation");
  ContextStructureNode* parent_node = this->findContextNodeNoLock(parent_ctx_name);
  if(parent_node == NULL) {
    return false;
  }
  //macedbg(1) << "Add child(" << child_node->getCtxName() << ") for " << parent_node->getCtxName() << Log::endl;
  parent_node->addChild(child_node);
  child_node->addParent(parent_node);
  return true;
}

void ExternalCommClass::createEvent(BaseMaceService* sv, mace::Event& event, const mace::string& targetContextID, 
    const bool& isReadOnly, const uint8_t& instanceUniqueID) {
  ADD_SELECTORS("ExternalCommClass::createEvent");

  const ContextService* _service = static_cast<ContextService*>(sv); 
  ScopedLock sl(mutex);
  mace::OrderID eventId( contextId, createTicket);
  createTicket ++;
  sl.unlock();

  uint64_t ver = _service->getLatestContextMapping().getCurrentVersion();
  uint64_t cver = _service->contextStructure.getCurrentVersion();

  event.initialize2(eventId, isReadOnly, this->contextName, targetContextID, mace::Event::ASYNCEVENT, ver, cver);
  
  event.addServiceID(instanceUniqueID);
  mace::EventOperationInfo opInfo(eventId, mace::EventOperationInfo::ASYNC_OP, targetContextID, targetContextID, 1, event.isReadOnly);
  event.eventOpInfo = opInfo;
}

mace::MaceAddr ContextService::getExternalCommContextAddr( const MaceKey& src, const mace::string& identifier ) {
  ADD_SELECTORS("ContextService::getExternalCommContextAddr");
  const mace::ContextMapping& ctxmapSnapshot = contextMapping.getLatestContextMapping();
  ASSERTMSG( Util::getMaceAddr() == mace::ContextMapping::getHead(ctxmapSnapshot), "It's not the headnode!" );

  ScopedLock sl(externalCommMutex);
  mace::map<mace::string, MaceAddr>::const_iterator citer = headClientExCommContextMap.find(identifier);
  
  if( citer != headClientExCommContextMap.end() ) {
    macedbg(1) << "Node("<< identifier <<") has already been assigned an proxy node " << citer->second << Log::endl;
    return citer->second;
  } 
    
  uint32_t externalCommId = nextExternalCommContextId;
  nextExternalCommContextId = (nextExternalCommContextId+1) % externalCommContextNumber;
  std::ostringstream oss;
  oss << mace::ContextMapping::EXTERNAL_COMM_CONTEXT_NAME<< "[" << externalCommId << "]";
  mace::string ctxName = oss.str();

  mace::MaceAddr addr = contextMapping.getExternalCommContextNode( ctxName );

  headClientExCommContextMap[identifier] = addr;
  macedbg(1) << "Assign external communication context("<< ctxName <<") on node("<< addr <<") to " << identifier << Log::endl;

  uint32_t externalCommContextId = getExternalCommContextID(externalCommId);
  
  send__event_externalCommControlMsg( addr, 0, externalCommId, externalCommContextId );
    
  return addr;
}

void ContextService::checkAndWaitExternalMessageHandle() {
  ADD_SELECTORS("ContextService::checkAndWaitExternalMessageHandle");
  const mace::Event& event = ThreadStructure::myEvent();
  const uint64_t externalMessageTicket = event.externalMessageTicket;
  ASSERT( externalMessageTicket > 0 );
  macedbg(1) << "now_serving_external_message_ticket=" << now_serving_external_message_ticket << " message_ticket=" << externalMessageTicket << Log::endl;
  ScopedLock sl(externalCommMutex);
  ASSERT( externalMessageTicket >= now_serving_external_message_ticket );
  if( externalMessageTicket > now_serving_external_message_ticket) {
    pthread_cond_t cond;
    pthread_cond_init( &cond, NULL );
    externalMsgWaitingThread[ externalMessageTicket ] = &cond;
    pthread_cond_wait( &cond, &externalCommMutex );
    pthread_cond_destroy( &cond );
  }
  ASSERT( externalMessageTicket == now_serving_external_message_ticket );
  macedbg(1) << "Now serving external ticket " << externalMessageTicket << Log::endl;
}

void ContextService::signalExternalMessageThread() {
  ADD_SELECTORS("ContextService::signalExternalMessageThread");
  ScopedLock sl(externalCommMutex);
  macedbg(1) << "Ticket " << now_serving_external_message_ticket << " signal next external message!" << Log::endl;
  now_serving_external_message_ticket ++;
  std::map<uint64_t, pthread_cond_t*>::iterator iter = externalMsgWaitingThread.find(now_serving_external_message_ticket);
  if( iter != externalMsgWaitingThread.end() ) {
    macedbg(1) << "Signal waiting external message " << now_serving_external_message_ticket << Log::endl;
    pthread_cond_signal( iter->second );
    externalMsgWaitingThread.erase(iter);
  }
}

ExternalCommClass* ContextService::getExternalCommClass() {
  ADD_SELECTORS("ContextService::getExternalCommClass");
  ScopedLock sl(externalCommMutex);
  if( externalCommClasses.size() == 0 ) {
    const ContextMapping& ctxmapSnapshot = contextMapping.getLatestContextMapping();
    ASSERTMSG( Util::getMaceAddr() == mace::ContextMapping::getHead(ctxmapSnapshot), "It's not the headnode!" );

    uint32_t externalCommId = nextExternalCommContextId;
    nextExternalCommContextId = (nextExternalCommContextId+1) % externalCommContextNumber;
    uint32_t externalCommContextId = getExternalCommContextID(externalCommId);

    ExternalCommClass* exCommClass = new ExternalCommClass(externalCommContextId, externalCommId);
    externalCommClassMap[externalCommId] = exCommClass;
    externalCommClasses.push_back(externalCommId);
  }

  uint32_t externalCommId = externalCommClasses[nextExternalCommClassId];
  macedbg(1) << "externalCommContext["<< externalCommId <<"] will serve!" << Log::endl;
  nextExternalCommClassId = (nextExternalCommClassId+1) % externalCommClasses.size();

  return externalCommClassMap[externalCommId];
}

void ContextService::send__event_commit( MaceAddr const& destNode, mace::Event const& event, mace::string const& ctxName ){
    mace::InternalMessageID msgId( Util::getMaceAddr(), ctxName, 0);
    mace::InternalMessage msg( mace::commit, msgId, event );
    forwardInternalMessage( destNode, msg );
  }
  void ContextService::const_send__event_commit( MaceAddr const& dest, mace::Event const& event, mace::string const& ctxName ) const{
    ADD_SELECTORS("ContextService::const_send__event_commit");
    ContextService *self = const_cast<ContextService *>( this );
    mace::InternalMessageID msgId( Util::getMaceAddr(), ctxName, 0);
    mace::InternalMessage msg( mace::commit, msgId, event );

    self->forwardInternalMessage( dest, msg );
  }
  void ContextService::send__event_snapshot( MaceAddr const& dest, mace::Event const& event, mace::string const& targetContextID, mace::string const& snapshotContextID, mace::string const& snapshot ){
    mace::InternalMessage msg( mace::snapshot, event, targetContextID, snapshotContextID, snapshot );
    forwardInternalMessage( dest, msg );
  }
  void ContextService::send__event_create_response( MaceAddr const& dest, mace::Event const& event, uint32_t const& counter, MaceAddr const& targetAddress){
    mace::InternalMessage msg( mace::create_response, event, counter, targetAddress );
    forwardInternalMessage( dest, msg );
  }
  void ContextService::const_send__event_create( MaceAddr const& dest, __asyncExtraField const& extra, uint64_t const& counter, uint32_t const& ctxId ) const {
    ContextService *self = const_cast<ContextService *>( this );
    
    mace::InternalMessage msg( mace::create, extra, counter, ctxId);
    self->forwardInternalMessage( dest, msg );
  }
  void ContextService::send__event_downgrade_context( MaceAddr const& dest, uint32_t const contextID, mace::OrderID const& eventID, bool const isresponse ){
    mace::InternalMessage msg( mace::downgrade_context, contextID, eventID, isresponse );
    forwardInternalMessage( dest, msg );
  }
  void ContextService::send__event_TransferContext( MaceAddr const& dest, const mace::ContextBaseClassParams* ctxParams, mace::string const& checkpoint, mace::OrderID const eventId ){
    mace::InternalMessage msg( mace::TransferContext, ctxParams, checkpoint, eventId );
    forwardInternalMessage( dest, msg );
  }
  void ContextService::send__event_AllocateContextObjectMsg( mace::OrderID const& eventID, mace::ContextMapping const& ctxmapCopy, MaceAddr const newHead, 
      mace::map< uint32_t, mace::string > const& contextSet, int8_t const eventType, const uint64_t version ){

    mace::InternalMessage msg( mace::AllocateContextObject, newHead, contextSet, eventID, ctxmapCopy, eventType, version );

    for( mace::map<uint32_t, mace::string>::const_iterator iter = contextSet.begin(); iter!=contextSet.end(); iter++ ) {
      const MaceAddr& dest = mace::ContextMapping::getNodeByContext(ctxmapCopy, iter->first);
      forwardInternalMessage( dest, msg );
    }
  }

  //bsang message sending
  void ContextService::send__event_AllocateContextObjReqMsg(mace::string const& ctx_name, mace::OrderID const& eventId, 
      mace::string const& parent_ctx_name, mace::ContextPolicyEntry const& policyEntry ) {

    ADD_SELECTORS("send__event_AllocateContextObjReqMsg");
    macedbg(1) << "Try to create context: " << ctx_name << Log::endl;
    mace::InternalMessage msg( mace::AllocateContextObjReq, ctx_name, eventId, parent_ctx_name, policyEntry );
    forwardInternalMessage( contextMapping.getHead(), msg);
  }

  void ContextService::send__event_contextMappingUpdateReqMsg(const uint64_t expectVer) {
    ADD_SELECTORS("ContextService::send__event_contextMappingUpdateReqMsg");
    macedbg(1) << "Request ContextMapping of version " << expectVer << Log::endl;
    mace::InternalMessage msg( mace::ContextMappingUpdateReq, expectVer );
    forwardInternalMessage( contextMapping.getHead(), msg);
  }

   void ContextService::send__event_AllocateContextObjectResponseMsg(mace::string const& ctx_name, mace::OrderID const& eventId, bool const& isCreateContextEvent) {
    mace::InternalMessage msg( mace::AllocateContextObjectResponse, ctx_name, eventId, isCreateContextEvent);
    forwardInternalMessage( contextMapping.getHead(), msg);
  }

  void ContextService::send__event_contextMappingUpdateSuggest( const mace::MaceAddr& dest, const uint64_t ver ) const {
    mace::InternalMessage msg( mace::ContextMappingUpdateSuggest, ver);
    forwardInternalMessage(dest, msg);
  }

  void ContextService::send__event_migrate_context(mace::MaceAddr const& newNode, mace::string const& contextName, uint64_t const delay ){
    mace::InternalMessage msg( mace::migrate_context, newNode, contextName, delay );
    forwardInternalMessage( contextMapping.getHead(), msg );
  }
  void ContextService::send__event_migrate_param(mace::string const& paramid ){
    mace::InternalMessage msg( mace::migrate_param, paramid );
    forwardInternalMessage( contextMapping.getHead(), msg );
  }
  void ContextService::send__event_routine_return( mace::MaceAddr const& src, mace::string const& returnValueStr ) const{
    ADD_SELECTORS("ContextService::send__event_routine_return");
    macedbg(1) << "Send event(" << ThreadStructure::myEventID() << ") back!" << Log::endl;
    mace::InternalMessage msg( mace::routine_return, returnValueStr, ThreadStructure::myEvent() );

    forwardInternalMessage(src, msg);
  }
  void ContextService::send__event_RemoveContextObject( mace::OrderID const& eventID, mace::ContextMapping const& ctxmapCopy, MaceAddr const& dest, uint32_t contextID ){
    mace::InternalMessage msg( mace::RemoveContextObject, eventID, ctxmapCopy, dest, contextID );

    const mace::map < MaceAddr,uint32_t >& physicalNodes = mace::ContextMapping::getAllNodes( ctxmapCopy);
    for( mace::map<MaceAddr, uint32_t>::const_iterator nodeIt = physicalNodes.begin(); nodeIt != physicalNodes.end(); nodeIt ++ ){
      sender->sendInternalMessage( nodeIt->first ,  msg );
    }
    //std::for_each( physicalNodes.begin(), physicalNodes.end(), std::bind2nd( sendInternalMessage, msg) );
  }
  void ContextService::send__event_delete_context( mace::string const& contextName ){
    mace::InternalMessage msg( mace::delete_context, contextName );
    sender->sendInternalMessage( contextMapping.getHead() ,  msg );
  }

  void ContextService::send__event_asyncEvent( mace::MaceAddr const& dest, mace::AsyncEvent_Message* const eventObject, mace::string const& ctxName ) {
    ADD_SELECTORS("ContextService::send__event_asyncEvent");
    mace::InternalMessageID msgId( Util::getMaceAddr(), ctxName, 0);
    mace::InternalMessage msg( eventObject, msgId, instanceUniqueID );
    forwardInternalMessage(dest, msg);
  }

  void ContextService::send__event_externalCommControlMsg( mace::MaceAddr const& dest, const uint8_t& control_type, const uint32_t& externalCommId, 
      const uint32_t& externalCommContextId ) {
    ADD_SELECTORS("ContextService::send__event_externalCommControlMsg");
    mace::InternalMessage msg( mace::ExternalCommControl, control_type, externalCommId, externalCommContextId );
    forwardInternalMessage( dest, msg );
  }

void ContextService::send__event_commitContextsMsg( MaceAddr const& destNode, mace::vector< mace::string > const& cctxNames, 
    mace::string const& src_contextName, mace::OrderID const& eventId ) const {
  mace::InternalMessageID msgId( Util::getMaceAddr(), "", 0);

  mace::string dest_contextName;
  mace::vector<mace::EventOperationInfo> opInfos;
  uint32_t newContextId = 0;
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::COMMIT_CONTEXTS,  
    src_contextName, dest_contextName, eventId, cctxNames, opInfos, newContextId);
  forwardInternalMessage(destNode, msg);
}

void ContextService::send__event_releaseContexts( mace::string const& dominator, mace::OrderID const& eventId, mace::string const& src_contextName,
    mace::vector< mace::string > const& lockedContextNames ) const {
  
  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext(snapshot, dominator);
  mace::InternalMessageID msgId( Util::getMaceAddr(), dominator, 0);

  mace::string dest_contextName;
  mace::vector<mace::EventOperationInfo> opInfos; 
  uint32_t newContextId;
  
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::RELEASE_CONTEXTS, 
    src_contextName, dest_contextName, eventId, lockedContextNames, opInfos, newContextId);

  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_unlockContext( mace::string const& dominator, mace::EventOperationInfo const& eop, 
    mace::string const& srcContextName, mace::set<mace::string> const& toContextNames ){
  
  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext(snapshot, dominator);
  
  mace::InternalMessageID msgId( Util::getMaceAddr(), dominator, 0);

  uint32_t newContextId = 1;
  mace::vector<mace::EventOperationInfo> eops;
  eops.push_back(eop);

  mace::vector<mace::string> contextNames;
  for( mace::set<mace::string>::const_iterator iter=toContextNames.begin(); iter!= toContextNames.end(); iter++ ){
    contextNames.push_back( *iter );
  }
  
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::UNLOCK_CONTEXT,  
    srcContextName, dominator, eop.eventId, contextNames, eops, newContextId);

  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_requireEventExecutePermission( mace::string const& dominator, mace::string const& requireContextName,
    mace::EventOperationInfo const& eventOpInfo ) {

  uint32_t contextId;
  mace::OrderID eId = eventOpInfo.eventId;
  const mace::MaceAddr& destAddr = this->asyncHead( eId, dominator, mace::Event::ALLOCATE_CTX_OBJECT, contextId);
        
  mace::InternalMessageID msgId( Util::getMaceAddr(), dominator, 0);

  uint32_t newContextId = 0;
  mace::vector<mace::string> contextNames;
  mace::vector<mace::EventOperationInfo> eops;
  eops.push_back(eventOpInfo);
  
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::TO_LOCK_CONTEXT,  
    requireContextName, dominator, eId, contextNames, eops, newContextId );

  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_enqueueLockRequests( mace::string const& dominator, mace::string const& requireContextName, 
    mace::vector<mace::EventOperationInfo> const& eops) {
  if( eops.size() == 0 ){
    return;
  }

  mace::OrderID eId = eops[0].eventId;
  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext(snapshot, dominator);
        
  mace::InternalMessageID msgId( Util::getMaceAddr(), dominator, 0);

  uint32_t newContextId = 0;
  mace::vector<mace::string> contextNames;
    
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::ENQUEUE_LOCK_CONTEXTS,  
    requireContextName, dominator, eId, contextNames, eops, newContextId );

  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_replyEventExecutePermission( mace::string const& dest_contextName, mace::string const& src_contextName, mace::OrderID const& eventId,
    mace::vector<mace::string> const& permittedContextNames, mace::vector<mace::EventOperationInfo> const& eventOpInfos ) const {
  
  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext(snapshot, dest_contextName);

  mace::InternalMessageID msgId( Util::getMaceAddr(), dest_contextName, 0);
  uint32_t newContextId;
  
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::LOCK_CONTEXT_PERMISSION,  
    src_contextName, dest_contextName, eventId, permittedContextNames, eventOpInfos, newContextId);

  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_getReadyToCommit( mace::OrderID const& eventId, mace::string const& notifyContext, mace::string const& src_contextName ) const {
  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext(snapshot, notifyContext);
  mace::InternalMessageID msgId( Util::getMaceAddr(), notifyContext, 0);

  uint32_t newContextId;
  mace::vector<mace::EventOperationInfo> eops;
  mace::vector<mace::string> contextNames;
  
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::CHECK_COMMIT,  
    src_contextName, notifyContext, eventId, contextNames, eops, newContextId);
  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_notifyReadyToCommit( const MaceAddr& destAddr, const mace::OrderID& eventId, const mace::string& src_contextName,
    mace::vector<mace::string> const& notifyContexts, mace::vector<mace::string> const& executedContexts) const {

  mace::vector<mace::string> contextNames;
  for( uint32_t i=0; i<notifyContexts.size(); i++ ){
    contextNames.push_back( notifyContexts[i] );
  }
  contextNames.push_back("#");
  for( uint32_t i=0; i<executedContexts.size(); i++ ){
    contextNames.push_back( executedContexts[i] );
  }

  mace::string dest_contextName = "";
  mace::InternalMessageID msgId( Util::getMaceAddr(), dest_contextName, 0);

  uint32_t newContextId;
  mace::vector<mace::EventOperationInfo> eops;
    
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::READY_TO_COMMIT,  
    src_contextName, dest_contextName, eventId, contextNames, eops, newContextId);
  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_EventOperationInfo( const uint8_t type, mace::string const& dest_contextName, mace::string const& src_contextName, 
    mace::EventOperationInfo const& opInfo, mace::OrderID const& eventId ) const {

  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext(snapshot, dest_contextName);
  mace::InternalMessageID msgId( Util::getMaceAddr(), dest_contextName, 0);

  mace::vector<mace::string> contextNames; 
  uint32_t newContextId;
  mace::vector<mace::EventOperationInfo> eops;
  
  eops.push_back( opInfo );
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, type, src_contextName, dest_contextName, eventId, contextNames, 
    eops, newContextId );
  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_releaseLockOnContext( mace::string const& dest_contextName, mace::string const& src_contextName, 
    mace::OrderID const& eventId) const {

  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext(snapshot, dest_contextName);
  mace::InternalMessageID msgId( Util::getMaceAddr(), dest_contextName, 0);

  mace::vector<mace::string> contextNames; 
  uint32_t newContextId;
  mace::vector<mace::EventOperationInfo> eops;
  
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::RELEASE_LOCK_ON_CONTEXT, 
    src_contextName, dest_contextName, eventId, contextNames, eops, newContextId );

  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_enqueueOwnershipOps( mace::EventOperationInfo const& eventOpInfo, 
    mace::string const& dest_contextName, mace::string const& src_contextName, 
    mace::vector<mace::EventOperationInfo> const& ownershipOpInfos) const {

  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext(snapshot, dest_contextName);
  mace::InternalMessageID msgId( Util::getMaceAddr(), dest_contextName, 0);

  mace::vector<mace::string> contextNames; 
  uint32_t newContextId;

  mace::vector<mace::EventOperationInfo> eops;
  eops.push_back( eventOpInfo);
  for( uint32_t i=0; i<ownershipOpInfos.size(); i++ ){
    eops.push_back(ownershipOpInfos[i]);
  }
    
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::ENQUEUE_OWNERSHIP_OPS, 
    src_contextName, dest_contextName, eventOpInfo.eventId, contextNames, eops, newContextId );

  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_enqueueOwnershipOpsReply(mace::EventOperationInfo const& eventOpInfo, mace::string const& dest_contextName, 
    mace::string const& src_contextName) const {

  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext(snapshot, dest_contextName);
  mace::InternalMessageID msgId( Util::getMaceAddr(), dest_contextName, 0);

  mace::vector<mace::string> contextNames; 
  uint32_t newContextId;

  mace::vector<mace::EventOperationInfo> eops;
  eops.push_back(eventOpInfo);
  
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::ENQUEUE_OWNERSHIP_OPS_REPLY, 
    src_contextName, dest_contextName, eventOpInfo.eventId, contextNames, eops, newContextId );

  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_enqueueSubEvent( mace::EventOperationInfo const& eventOpInfo, mace::string const& dest_contextName, 
    mace::string const& src_contextName, mace::EventRequestWrapper const& eventRequest) const {
  ADD_SELECTORS("ContextService::send__event_enqueueSubEvent");
  macedbg(1) << "Send a subevent of "<< eventOpInfo.eventId << " to " << dest_contextName << " from " << src_contextName << Log::endl;
  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext( snapshot, dest_contextName );
  mace::InternalMessageID msgId( Util::getMaceAddr(), dest_contextName, 0 );
  mace::InternalMessage msg( mace::EnqueueEventRequest, msgId, eventOpInfo, dest_contextName, src_contextName, eventRequest);
  forwardInternalMessage( destAddr, msg );
}

void ContextService::send__event_enqueueSubEventReply( mace::EventOperationInfo const& eventOpInfo, mace::string const& dest_contextName, 
    mace::string const& src_contextName) const {
  ADD_SELECTORS("ContextService::send__event_enqueueSubEventReply");
  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext( snapshot, dest_contextName );
  mace::InternalMessageID msgId( Util::getMaceAddr(), dest_contextName, 0 );
  mace::InternalMessage msg( mace::EnqueueEventReply, msgId, eventOpInfo, dest_contextName, src_contextName);
  forwardInternalMessage( destAddr, msg );
}

void ContextService::send__event_enqueueExternalMessage( mace::EventOperationInfo const& eventOpInfo, mace::string const& dest_contextName, 
    mace::string const& src_contextName, mace::EventMessageRecord const& msgRecord) const {
  ADD_SELECTORS("ContextService::send__event_enqueueExternalMessage");
  macedbg(1) << "Send a externalmessage of "<< eventOpInfo.eventId << " to " << dest_contextName << " from " << src_contextName << Log::endl;
  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext( snapshot, dest_contextName );
  mace::InternalMessageID msgId( Util::getMaceAddr(), dest_contextName, 0 );
  mace::InternalMessage msg( mace::EnqueueMessageRequest, msgId, eventOpInfo, dest_contextName, src_contextName, msgRecord);
  forwardInternalMessage( destAddr, msg );
}

void ContextService::send__event_enqueueExternalMessageReply( mace::EventOperationInfo const& eventOpInfo, mace::string const& dest_contextName, 
    mace::string const& src_contextName) const {
  ADD_SELECTORS("ContextService::send__event_enqueueExternalMessageReply");
  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& destAddr = ContextMapping::getNodeByContext( snapshot, dest_contextName );
  mace::InternalMessageID msgId( Util::getMaceAddr(), dest_contextName, 0 );
  mace::InternalMessage msg( mace::EnqueueMessageReply, msgId, eventOpInfo, dest_contextName, src_contextName);
  forwardInternalMessage( destAddr, msg );
}

void ContextService::send__event_ownershipOperations(mace::EventOperationInfo const& eop, mace::string const& contextName, 
    mace::vector<mace::EventOperationInfo> const& ownershipOpInfos) const {

  ADD_SELECTORS("ContextService::send__event_ownershipOperations");
  macedbg(1) << "contextName=" << contextName << Log::endl;

  mace::vector<mace::EventOperationInfo> eops;
  eops.push_back(eop);
  for( uint32_t i=0; i<ownershipOpInfos.size(); i++ ){
    eops.push_back(ownershipOpInfos[i]);
  }


  const ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const MaceAddr& headAddr = ContextMapping::getHead(snapshot);

  mace::string dest_contextName = "globalContext";
  mace::vector< mace::pair<mace::string, mace::string> > ownerships;
  uint64_t ver = 0; 
  mace::set<mace::string> contextNames;
  mace::ContextEventDominator::EventLockQueue eventLockQueues;
  mace::map<mace::string, mace::string> prePDominators;
  mace::map<mace::string, mace::string> preDominators;

  mace::InternalMessageID msgId(Util::getMaceAddr(), dest_contextName, 0);

  mace::InternalMessage msg( mace::ContextOwnershipControl, msgId, mace::ContextOwnershipControl_Message::OWNERSHIP_MODIFY,
    eops, dest_contextName, contextName, eop.eventId, ownerships, ver, contextNames, eventLockQueues, prePDominators, preDominators);
  forwardInternalMessage(headAddr, msg);
}

void ContextService::send__event_updateOwnership(const mace::MaceAddr& destAddr, mace::set<mace::string> const& ctxNames, 
    mace::vector< mace::pair<mace::string, mace::string> > const& ownerships, const uint64_t ver ) const {

  mace::vector<mace::EventOperationInfo> ownershipOpInfos; 
  mace::string dest_contextName;
  mace::string src_contextName;
  mace::OrderID eventId; 
  mace::ContextEventDominator::EventLockQueue eventLockQueues;
  mace::map<mace::string, mace::string> prePDominators;
  mace::map<mace::string, mace::string> preDominators; 

  mace::InternalMessageID msgId(Util::getMaceAddr(), "", 0);
  
  mace::InternalMessage msg( mace::ContextOwnershipControl, msgId, mace::ContextOwnershipControl_Message::OWNERSHIP_UPDATE,
    ownershipOpInfos, dest_contextName, src_contextName, eventId, ownerships, ver, ctxNames, eventLockQueues, prePDominators, preDominators);
  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_updateOwnershipReply( mace::set<mace::string> const& ctxNames ) const {
  const mace::ContextMapping& snapshot = getLatestContextMapping();
  const mace::MaceAddr& headAddr = mace::ContextMapping::getHead(snapshot);

  mace::InternalMessageID msgId(Util::getMaceAddr(), "", 0);

  mace::vector<mace::EventOperationInfo> ownershipOpInfos; 
  mace::string dest_contextName;
  mace::string src_contextName;
  mace::OrderID eventId;  
  mace::vector< mace::pair<mace::string, mace::string> > ownerships;
  uint64_t ver = 0; 
  mace::ContextEventDominator::EventLockQueue eventLockQueues;
  mace::map<mace::string, mace::string> prePDominators;
  mace::map<mace::string, mace::string> preDominators;

  mace::InternalMessage msg( mace::ContextOwnershipControl, msgId, mace::ContextOwnershipControl_Message::OWNERSHIP_UPDATE_DONE,
    ownershipOpInfos, dest_contextName, src_contextName, eventId, ownerships, ver, ctxNames, eventLockQueues, prePDominators, preDominators);
  forwardInternalMessage(headAddr, msg);
}

void ContextService::send__event_modifyOwnershipReply( mace::MaceAddr const& destAddr, mace::string const& ctxName, 
    mace::EventOperationInfo const& eop ) const {

  mace::InternalMessageID msgId( Util::getMaceAddr(), ctxName, 0 );

  mace::vector<mace::EventOperationInfo> ownershipOpInfos; 
  ownershipOpInfos.push_back(eop);
  
  mace::string src_contextName = "globalContext";
  mace::vector< mace::pair<mace::string, mace::string> > ownerships;
  uint64_t ver = 0; 
  mace::set<mace::string> contextNames;
  mace::ContextEventDominator::EventLockQueue eventLockQueues;
  mace::map<mace::string, mace::string> prePDominators;
  mace::map<mace::string, mace::string> preDominators;

  mace::InternalMessage msg( mace::ContextOwnershipControl, msgId, mace::ContextOwnershipControl_Message::OWNERSHIP_MODIFY_DONE,
    ownershipOpInfos, ctxName, src_contextName, eop.eventId, ownerships, ver, contextNames, eventLockQueues, prePDominators, preDominators);
  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_updateOwnershipAndDominators(const mace::MaceAddr& destAddr, mace::set<mace::string> const& ctxNames, 
    mace::vector< mace::pair<mace::string, mace::string> > const& ownerships, const uint64_t ver, mace::map<mace::string, mace::string> const& prePDominators,
    mace::map<mace::string, mace::string> const& preDominators ) const {

  mace::vector<mace::EventOperationInfo> ownershipOpInfos; 
  mace::string dest_contextName;
  mace::string src_contextName = mace::ContextMapping::GLOBAL_CONTEXT_NAME;
  mace::OrderID eventId;  
  mace::ContextEventDominator::EventLockQueue eventLockQueues;

  mace::InternalMessageID msgId(Util::getMaceAddr(), "", 0);
  
  mace::InternalMessage msg( mace::ContextOwnershipControl, msgId, mace::ContextOwnershipControl_Message::OWNERSHIP_AND_DOMINATOR_UPDATE,
    ownershipOpInfos, dest_contextName, src_contextName, eventId, ownerships, ver, ctxNames, eventLockQueues, prePDominators, preDominators);
  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_updateDominatorEventLockQueues( mace::string const& dest_contextName, mace::string const& src_contextName, 
    mace::ContextEventDominator::EventLockQueue const& lockQueues) const {
  ADD_SELECTORS("ContextService::send__event_updateDominatorEventLockQueues");
  const mace::ContextMapping& snapshot = contextMapping.getLatestContextMapping();
  const mace::MaceAddr& destAddr = mace::ContextMapping::getNodeByContext(snapshot, dest_contextName);

  mace::vector<mace::EventOperationInfo> ownershipOpInfos; 
  mace::OrderID eventId;  
  mace::set<mace::string> contextNames;
  uint64_t ver = 0;
  mace::vector< mace::pair<mace::string, mace::string> > ownerships;

  mace::map<mace::string, mace::string> prePDominators;
  mace::map<mace::string, mace::string> preDominators;
  
  mace::InternalMessageID msgId(Util::getMaceAddr(), dest_contextName, 0);
  
  mace::InternalMessage msg( mace::ContextOwnershipControl, msgId, mace::ContextOwnershipControl_Message::DOMINATOR_LOCK_QUEUE_UPDATE,
    ownershipOpInfos, dest_contextName, src_contextName, eventId, ownerships, ver, contextNames, lockQueues, prePDominators, preDominators);
  forwardInternalMessage(destAddr, msg);
}


void ContextService::createNewOwnership(mace::string const& pContextName, mace::string const& cContextName) {
  ADD_SELECTORS("ContextService::createNewOwnership");
  macedbg(1) << "Create new ownership("<< pContextName<<", " << cContextName<<")!" << Log::endl;
  modifyOwnership( mace::EventOperationInfo::ADD_OWNERSHIP_OP, pContextName, cContextName);
}

void ContextService::removeOwnership(mace::string const& pContextName, mace::string const& cContextName) {
  ADD_SELECTORS("ContextService::removeOwnership");
  macedbg(1) << "Remove ownership("<< pContextName<<", " << cContextName<<")!" << Log::endl;
  modifyOwnership( mace::EventOperationInfo::DELETE_OWNERSHIP_OP, pContextName, cContextName);
}

void ContextService::setNewPolicy( mace::string const& contextName, mace::string const& policyRule, mace::string const& coPlaceContextName ) {
  ADD_SELECTORS("ContextService::setNewPolicy");

  if( policyRule == "DISTRIBUTE") {
    mace::ContextPolicyEntry policyEntry;
    policyEntry.policyType = mace::ContextPolicyEntry::POLICY_DISTRIBUTE;

    mace::ContextMapping::createNewContextPolicy(contextName, policyEntry);
    send__event_NewContextPolicy( contextName, policyEntry );
  }
}

uint32_t ContextService::createNewContext(mace::string const& contextTypeName) {
  mace::ContextBaseClass* ctxObj = ThreadStructure::myContext();
  return ctxObj->createNewContext(this, contextTypeName);
}

void ContextService::send__event_createNewContext( mace::string const& src_contextName, mace::string const& contextTypeName, 
    mace::EventOperationInfo const& eventOpInfo) const {
  
  const mace::ContextMapping& snapshot = getLatestContextMapping();
  const mace::MaceAddr& headAddr = mace::ContextMapping::getHead(snapshot);
  mace::InternalMessageID msgId( Util::getMaceAddr(), mace::ContextMapping::GLOBAL_CONTEXT_NAME, 0);

  mace::vector<mace::string> contextNames; 
  contextNames.push_back( contextTypeName );

  mace::vector<mace::EventOperationInfo> opInfos;
  opInfos.push_back(eventOpInfo);

  uint32_t newContextId = 0;
  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::CREATE_NEW_CONTEXT, 
    src_contextName, mace::ContextMapping::GLOBAL_CONTEXT_NAME, eventOpInfo.eventId, contextNames, opInfos, newContextId);
  forwardInternalMessage(headAddr, msg);
}

void ContextService::send__event_createNewContextReply( mace::string const& dest_contextName, mace::EventOperationInfo const& eventOpInfo, const uint32_t& newContextId) const {
  const mace::ContextMapping& snapshot = getLatestContextMapping();
  const mace::MaceAddr& destAddr = mace::ContextMapping::getNodeByContext(snapshot, dest_contextName);
  mace::InternalMessageID msgId( Util::getMaceAddr(), dest_contextName, 0);

  mace::string src_contextName = mace::ContextMapping::GLOBAL_CONTEXT_NAME;
  mace::vector<mace::string> contextNames;

  mace::vector<mace::EventOperationInfo> opInfos;
  opInfos.push_back(eventOpInfo);

  mace::InternalMessage msg(mace::EventExecutionControl, msgId, mace::EventExecutionControl_Message::CREATE_NEW_CONTEXT_REPLY, 
    src_contextName, dest_contextName, eventOpInfo.eventId, contextNames, opInfos, newContextId);
  forwardInternalMessage(destAddr, msg);
}

void ContextService::send__event_contextStructureUpdateReqMsg(const uint64_t expectVer) {
  const mace::ContextMapping& snapshot = getLatestContextMapping();
  const mace::MaceAddr& headAddr = mace::ContextMapping::getHead(snapshot);

  mace::vector<mace::EventOperationInfo> ownershipOpInfos; 
  mace::string dest_contextName;
  mace::string src_contextName;
  mace::OrderID eventId;  
  mace::vector< mace::pair<mace::string, mace::string> > ownerships;
  mace::set<mace::string> contextNames;
  
  mace::ContextEventDominator::EventLockQueue eventLockQueues;
  mace::map<mace::string, mace::string> prePDominators;
  mace::map<mace::string, mace::string> preDominators;

  mace::InternalMessageID msgId( Util::getMaceAddr(), "", 0 );

  mace::InternalMessage msg( mace::ContextOwnershipControl, msgId, mace::ContextOwnershipControl_Message::OWNERSHIP_UPDATE_REQUEST,
    ownershipOpInfos, dest_contextName, src_contextName, eventId, ownerships, expectVer, contextNames, eventLockQueues, prePDominators, preDominators);
  forwardInternalMessage(headAddr, msg);
}

void ContextService::send__event_NewContextPolicy( mace::string const& contextName, mace::ContextPolicyEntry const& policyEntry ) const {
  const mace::ContextMapping& snapshot = getLatestContextMapping();
  const mace::MaceAddr& headAddr = mace::ContextMapping::getHead(snapshot);

  mace::InternalMessageID msgId( Util::getMaceAddr(), "", 0 );
  mace::InternalMessage msg( mace::ContextPolicyControl, msgId, mace::ContextPolicyControl_Message::ADD_NEW_POLICY, contextName, policyEntry);
  forwardInternalMessage( headAddr, msg );
}

void ContextService::addEventRequest( mace::AsyncEvent_Message* reqObject){
  ADD_SELECTORS("ContextService::addEventRequest");
  //mace::Event::EventSkipRecordType & preEventInfosStorage = reqObject->getEvent().getPreEventInfosStorage( instanceUniqueID );
  //ASSERT( &preEventInfosStorage != NULL );
  //ThreadStructure::myEvent().deferEventRequest( instanceUniqueID, reqObject );
  //macedbg(1) << "Add one async event to Event(" << ThreadStructure::myEventID() <<") and instanceUniqueID=" << (uint32_t)instanceUniqueID << Log::endl;
  mace::ContextBaseClass* ctxObj = ThreadStructure::myContext();
  mace::Event& event = ThreadStructure::myEvent();
  mace::EventRequestWrapper request(instanceUniqueID, reqObject);
  ctxObj->enqueueSubEvent(this, event.eventOpInfo, event.target_ctx_name, request);
}



bool ContextStructure::addChildParentRelation(mace::string const& child_ctx_name, ContextStructureNode* parent_node) {
  ScopedLock sl(contextStructureMutex);
  ContextStructureNode* child_node = this->findContextNodeNoLock(child_ctx_name);
  if(child_node == NULL) {
    return false;
  }

  parent_node->addChild(child_node);
  child_node->addParent(parent_node);
  return true;
}

mace::set<mace::string> ContextStructure::getAllDecendantContexts(mace::string const& ctx_name) const{
  ADD_SELECTORS("ContextStructure::getAllDecendantContexts");
  ScopedLock sl(contextStructureMutex);
  const ContextStructureNode* node = this->const_findContextNodeNoLock(ctx_name);

  if( node == NULL ) {
    mace::set<mace::string> null_set;
    return null_set;
  }

  mace::set<mace::string> decendants;

  const ContextStructureNode::ContextStructureNodesType& child_contexts = node->child_contexts;

  for(uint32_t i=0; i<child_contexts.size(); i++) {
    mace::set<mace::string> ds = child_contexts[i]->getDecendantNames();

    for(mace::set<mace::string>::iterator iter = ds.begin(); iter != ds.end(); iter ++ ) {
      if( decendants.count(*iter) == 0 ) {
        decendants.insert( *iter );
      }
    }
    //macedbg(1) << decendants << Log::endl;
  }

  decendants.insert( node->getCtxName() );
  return decendants;
}

mace::set<mace::string> ContextStructure::getOrderingDecendantContexts(mace::string const& ctx_name) const{
  ADD_SELECTORS("ContextStructure::getOrderingDecendantContexts");
  ScopedLock sl(contextStructureMutex);
  const ContextStructureNode* node = this->const_findContextNodeNoLock(ctx_name);

  if( node == NULL ) {
    mace::set<mace::string> null_set;
    return null_set;
  }

  mace::set<mace::string> decendants;

  const ContextStructureNode::ContextStructureNodesType& child_contexts = node->child_contexts;

  for(uint32_t i=0; i<child_contexts.size(); i++) {
    mace::set<mace::string> ds;
    if( !child_contexts[i]->isUpperBoundContext() ){
      ds = getOrderingDecendantContexts2(child_contexts[i]->getCtxName());
    }
    if( ds.count(child_contexts[i]->getCtxName()) == 0 ){
      ds.insert(child_contexts[i]->getCtxName());
    }

    for(mace::set<mace::string>::iterator iter = ds.begin(); iter != ds.end(); iter ++ ) {
      if( decendants.count(*iter) == 0 ) {
        decendants.insert( *iter );
      }
    }
    //macedbg(1) << decendants << Log::endl;
  }

  decendants.insert( node->getCtxName() );
  return decendants;
}

mace::set<mace::string> ContextStructure::getOrderingDecendantContexts2(mace::string const& ctx_name) const{
  ADD_SELECTORS("ContextStructure::getOrderingDecendantContexts2");
  const ContextStructureNode* node = this->const_findContextNodeNoLock(ctx_name);

  if( node == NULL ) {
    mace::set<mace::string> null_set;
    return null_set;
  }

  mace::set<mace::string> decendants;

  const ContextStructureNode::ContextStructureNodesType& child_contexts = node->child_contexts;

  for(uint32_t i=0; i<child_contexts.size(); i++) {
    mace::set<mace::string> ds;
    if( !child_contexts[i]->isUpperBoundContext() ){
      ds = getOrderingDecendantContexts2(child_contexts[i]->getCtxName());
    }
    if( ds.count(child_contexts[i]->getCtxName()) == 0 ){
      ds.insert(child_contexts[i]->getCtxName());
    }

    for(mace::set<mace::string>::iterator iter = ds.begin(); iter != ds.end(); iter ++ ) {
      if( decendants.count(*iter) == 0 ) {
        decendants.insert( *iter );
      }
    }
    //macedbg(1) << decendants << Log::endl;
  }

  decendants.insert( node->getCtxName() );
  return decendants;
}

mace::vector<mace::string> ContextStructure::getAllChildContexts(mace::string const& ctx_name) const {
  ScopedLock sl(contextStructureMutex);
  const ContextStructureNode* node = this->const_findContextNodeNoLock(ctx_name);

  if( node == NULL ) {
    mace::vector<mace::string> null_vector;
    return null_vector;
  }

  return node->getChildrenNames();
}

mace::vector<mace::string> ContextStructure::getAllChildContextsNoLock(mace::string const& ctx_name) const {
  const ContextStructureNode* node = this->const_findContextNodeNoLock(ctx_name);

  if( node == NULL ) {
    mace::vector<mace::string> null_vector;
    return null_vector;
  }

  return node->getChildrenNames();
}

mace::vector<mace::string> ContextStructure::getAllParentContexts(mace::string const& ctx_name) const {
  ScopedLock sl(contextStructureMutex);
  const ContextStructureNode* node = this->const_findContextNodeNoLock(ctx_name);

  if( node == NULL ) {
    mace::vector<mace::string> null_vector;
    return null_vector;
  }

  return node->getParentNames();
}

mace::vector<mace::string> ContextStructure::getDominateContexts( mace::string const& ctxName ) const {
  ADD_SELECTORS("ContextStructure::getDominateContexts");
  mace::vector<mace::string> v_dominateContexts;
  ScopedLock sl(contextStructureMutex);
  const ContextStructureNode* node = this->const_findContextNodeNoLock(ctxName);

  if( node == NULL ){
    maceerr << "Fail to find context("<< ctxName <<") in DAG!" << Log::endl;
    return v_dominateContexts;
  }

  if( !node->isUpperBoundContext() ) {
    macedbg(1) << "context("<< ctxName <<") is not an UB!" << Log::endl;
    return v_dominateContexts;
  }
  mace::set<mace::string> s_dominateContexts;
  s_dominateContexts.insert(ctxName);

  std::vector< ContextStructureNode* > cnodes = node->getChildren();
  for( uint32_t i=0; i<cnodes.size(); i++ ) {
    cnodes[i]->getDominateContexts(s_dominateContexts);
  }

  /*
  node->getDominateContexts( s_dominateContexts );
  mace::vector<mace::string> children_names = node->getChildrenNames();
  for( uint32_t i=0; i<children_names.size(); i++ ) {
    if( s_dominateContexts.count(children_names[i]) == 0 ) {
      s_dominateContexts.insert( children_names[i] );
    }
  }
  */

  for( mace::set<mace::string>::iterator sIter=s_dominateContexts.begin(); sIter!=s_dominateContexts.end(); sIter++ ){
    const mace::string& sDominateContext = *sIter;
    bool insert_flag = false;
    for( mace::vector<mace::string>::iterator vIter=v_dominateContexts.begin(); vIter!=v_dominateContexts.end(); vIter++ ){
      const mace::string& vDominateContext = *vIter;
      if( this->isElderContextNoLock(vDominateContext, sDominateContext) ){
        insert_flag = true;
        v_dominateContexts.insert( vIter, sDominateContext );
        break;
      }
    }

    if( !insert_flag ){
      v_dominateContexts.push_back(sDominateContext);
    }
  }

  return v_dominateContexts;
}


bool ContextStructure::isParentContext(mace::string const& child_ctx_name, mace::string const& parent_ctx_name) const{
  const ContextStructureNode* parent_node = this->const_findContextNodeNoLock(parent_ctx_name);

  if( parent_node == NULL ) {
    return false;
  } 

  mace::vector<mace::string> children = parent_node->getChildrenNames();
  for(uint32_t i=0; i<children.size(); i++) {
    if(children[i] == child_ctx_name) {
      return true;
    }
  }

  return false;
}

bool ContextStructure::isElderContext(mace::string const& d_ctx_name, mace::string const& elder_ctx_name) const {
  ScopedLock sl(contextStructureMutex);

  const ContextStructureNode* elder_node = this->const_findContextNodeNoLock(elder_ctx_name);

  if( elder_node == NULL ) {
    return false;
  } 

  if(d_ctx_name == elder_ctx_name) {
    return true;
  }

  mace::vector<mace::string> children = elder_node->getChildrenNames();
  for(uint32_t i=0; i<children.size(); i++) {
    if( this->isElderContextNoLock(d_ctx_name, children[i]) ) {
      return true;
    }    
  }
  return false;
}

bool ContextStructure::isElderContextNoLock(mace::string const& d_ctx_name, mace::string const& elder_ctx_name) const {
  const ContextStructureNode* elder_node = this->const_findContextNodeNoLock(elder_ctx_name);

  if( elder_node == NULL ) {
    return false;
  } 

  if(d_ctx_name == elder_ctx_name) {
    return true;
  }

  mace::vector<mace::string> children = elder_node->getChildrenNames();
  for(uint32_t i=0; i<children.size(); i++) {
    if( this->isElderContextNoLock(d_ctx_name, children[i]) ) {
      return true;
    }    
  }
  return false;
}

bool ContextStructure::isUpperBoundContext(mace::string const& ctx_name) const{
  ScopedLock sl(contextStructureMutex);
  const ContextStructureNode* node = this->const_findContextNodeNoLock(ctx_name);

  if( node == NULL ) {
    return false;
  } else {
    return node->isUpperBoundContext();
  }
}

bool ContextStructure::isUpperBoundContextNoLock(mace::string const& ctx_name) const{
  const ContextStructureNode* node = this->const_findContextNodeNoLock(ctx_name);

  if( node == NULL ) {
    return false;
  } else {
    return node->isUpperBoundContext();
  }
}

mace::string ContextStructure::getUpperBoundContextName(mace::string const& ctx_name) {
  ADD_SELECTORS("ContextStructure::getUpperBoundContextName");
  //ScopedLock sl(contextStructureMutex);
  const ContextStructureNode* node = this->const_findContextNodeNoLock(ctx_name);

  if( node == NULL ) {
    // std::map<mace::string, ContextStructureNode*>::const_iterator citer = nameNodeMap.begin();
    maceerr << "Fail to find context(" << ctx_name <<") in ownership DAG!" << Log::endl;
    mace::string ctxName = ctx_name;
    return ctxName;
  } else {
    mace::string ctxName = node->getUpperBoundContextName();
    return ctxName;
  }
}

mace::string ContextStructure::getDominatorContext(mace::string const& ctxName) {
  ADD_SELECTORS("ContextStructure::getDominatorContext");
  ScopedLock sl(contextStructureMutex);

  const ContextStructureNode* node = this->const_findContextNodeNoLock(ctxName);

  if( node == NULL ) {
    std::map<mace::string, ContextStructureNode*>::const_iterator citer = nameNodeMap.begin();
    maceerr << "Fail to find context(" << ctxName <<")'s dominator!" << Log::endl;
    return "NULL";
  } else {
    return node->getUpperBoundContextName();
  }
}

mace::string ContextStructure::getParentDominatorContext(mace::string const& ctxName) {
  ADD_SELECTORS("ContextStructure::getParentDominatorContext");
  ScopedLock sl(contextStructureMutex);

  const ContextStructureNode* node = this->const_findContextNodeNoLock(ctxName);

  if( node == NULL ) {
    std::map<mace::string, ContextStructureNode*>::const_iterator citer = nameNodeMap.begin();
    maceerr << "Fail to find context(" << ctxName <<")'s parent LUB!" << Log::endl;
    return "NULL";
  } else {
    const mace::vector<mace::string> parentContextNames = node->getParentNames();
    if( parentContextNames.size() == 0 ){
      return node->getUpperBoundContextName();
    } else {
      sl.unlock();
      return this->getDominatorContext( parentContextNames[0] );
    }
  }
}

mace::set<mace::string> ContextStructure::findUpperBoundContexts() {
  ADD_SELECTORS("ContextStructure::findUpperBoundContexts#1");
  macedbg(1) << "Start to find upper bound contexts!" << Log::endl;

  mace::set<mace::string> allChildren;
  mace::set<mace::string> allParents;
  mace::set<mace::string> relatedContexts;

  findUpperBoundContexts(rootNode, relatedContexts, allChildren, allParents);
  this->hasCheckUpperBoundContexts = true;
  macedbg(1) << "Finish upper bound contexts search!" << Log::endl;
  return relatedContexts;
}

void ContextStructure::findUpperBoundContexts(ContextStructureNode * node, mace::set<mace::string>& relatedContexts, 
    mace::set<mace::string>& allChildren, mace::set<mace::string>& allParents) {
  ADD_SELECTORS("ContextStructure::findUpperBoundContexts#2");
  if( node == NULL ) {
    return;
  }

  //macedbg(1) << "search context: " << node->getCtxName() << Log::endl;
  mace::set<mace::string> myAllChildren;
  mace::set<mace::string> myAllParents;

  const mace::string ctxName = node->getCtxName();
  myAllChildren.insert(ctxName);
  myAllParents.insert(ctxName);

  if( allChildren.count(ctxName) == 0 ) allChildren.insert(ctxName);
  if( allParents.count(ctxName) == 0 ) allParents.insert(ctxName);

  ContextStructureNode::ContextStructureNodesType children = node->getChildren();
  if( children.size() == 0 ) {
    node->setIsUpperBoundContext(true);
    if( node->getUpperBoundContextName() != ctxName ){
      if( relatedContexts.count(ctxName) == 0 ){
        relatedContexts.insert(ctxName);
      }
    }
    node->setUpperBoundContextName( ctxName );
    macedbg(1) << "UBC relationship: " << node->getCtxName() << "->" << node->getCtxName() << Log::endl;
    mace::vector<mace::string> parentNames = node->getParentNames();
    for( uint32_t i=0; i < parentNames.size(); i++ ) {
      if( allParents.count(parentNames[i]) == 0 ){
        allParents.insert(parentNames[i]);
      }
    }
    return;
  }


  for(uint32_t i = 0; i < children.size(); i++) {
    ContextStructureNode* cnode = children[i];
    findUpperBoundContexts(cnode, relatedContexts, myAllChildren, myAllParents);
  }

  bool root_flag = true;
  mace::set<mace::string>::iterator iter = myAllParents.begin();
  for( ; iter != myAllParents.end(); iter++ ) {
    if( myAllChildren.count(*iter) == 0 ) {
      root_flag = false;
      break;
    } 
  }

  
  if( root_flag ) {
    for(uint32_t i = 0; i < children.size(); i++) {
      ContextStructureNode* cnode = children[i];
      broadcastUpperBoundContext(cnode, relatedContexts, ctxName);
    }
    macedbg(1) << "UBC relationship: " << node->getCtxName() << "->" << node->getCtxName() << Log::endl;
    if( node->getUpperBoundContextName() != ctxName ){
      if( relatedContexts.count(ctxName) == 0 ){
        relatedContexts.insert(ctxName);
      }
    }
    node->setUpperBoundContextName(ctxName);
  } else {
    for( iter = myAllParents.begin(); iter != myAllParents.end(); iter++ ) {
      if( allParents.count(*iter) == 0 ) allParents.insert(*iter);
    }

    for( iter = myAllChildren.begin(); iter != myAllChildren.end(); iter++ ) {
      if( allChildren.count(*iter) == 0 ) allChildren.insert(*iter);
    }

  } 


  mace::vector<mace::string> parentNames = node->getParentNames();
  for( uint32_t i=0; i < parentNames.size(); i++ ) {
    if( allParents.count( parentNames[i] ) == 0 ) allParents.insert( parentNames[i] );
  }

  node->setIsUpperBoundContext(root_flag);
}

void ContextStructure::broadcastUpperBoundContext(ContextStructureNode* node, mace::set<mace::string>& relatedContexts, mace::string const& ctx_name) {
  ADD_SELECTORS("ContextStructure::broadcastUpperBoundContext");
  if(node == NULL || node->isUpperBoundContext()) {
    return;
  }
  
  if( node->getUpperBoundContextName() != ctx_name ){
    if( relatedContexts.count(ctx_name) == 0 ){
      relatedContexts.insert(ctx_name);
    }
  }

  node->setUpperBoundContextName(ctx_name);
  
  macedbg(1) << "UBC relationship: " << ctx_name << "->" << node->getCtxName() << Log::endl;
  ContextStructureNode::ContextStructureNodesType children = node->getChildren();
  for(uint32_t i = 0; i < children.size(); i++) {
    ContextStructureNode* cnode = children[i];
    broadcastUpperBoundContext(cnode, relatedContexts, ctx_name);
  }
}

ContextStructureNode* ContextStructure::findContextNodeNoLock(mace::string const& ctx_name) {
  std::map<mace::string, ContextStructureNode*>::iterator iter = nameNodeMap.find(ctx_name);
  if( iter == nameNodeMap.end() ) {
    return NULL;
  } else {
    return iter->second;
  }
}

const ContextStructureNode* ContextStructure::const_findContextNodeNoLock(mace::string const& ctx_name) const {
  std::map<mace::string, ContextStructureNode*>::const_iterator c_iter = nameNodeMap.find(ctx_name);
  if( c_iter == nameNodeMap.end() ) {
    return NULL;
  } else {
    return c_iter->second;
  }
}

mace::vector<mace::string> ContextStructureNode::getParentNames() const {
  mace::vector<mace::string> parentNames;

  for(uint32_t i=0; i<parent_contexts.size(); i++) {
    ContextStructureNode* pnode = parent_contexts[i];
    parentNames.push_back( pnode->getCtxName() );
  }

  return parentNames;
}

mace::vector<mace::string> ContextStructureNode::getChildrenNames() const {
  mace::vector<mace::string> childrenNames;

  for(uint32_t i=0; i<child_contexts.size(); i++) {
    ContextStructureNode* cnode = child_contexts[i];
    childrenNames.push_back( cnode->getCtxName() );
  }

  return childrenNames;
}

mace::set<mace::string> ContextStructureNode::getDecendantNames() {
  mace::set<mace::string> dNames;

  dNames.insert(context_name);

  if( !isUpperBoundContextFlag ) {
    for(uint32_t i=0; i<child_contexts.size(); i++) {
      ContextStructureNode* cnode = child_contexts[i];
      mace::set<mace::string> cdnames = cnode->getDecendantNames();

      for( mace::set<mace::string>::iterator iter = cdnames.begin(); iter != cdnames.end(); iter++ ) {
        if( dNames.count(*iter) == 0 ) {
          dNames.insert(*iter);
        }
      }
    }
  }

  return dNames;
}

void ContextStructureNode::getDominateContexts( mace::set<mace::string>& dominateContexts ) const {
  ADD_SELECTORS("ContextStructureNode::getDominateContexts");
  if( dominateContexts.count(context_name) == 0 ) {
    dominateContexts.insert( context_name );
    macedbg(1) << "Adding dominated context " << context_name << Log::endl;
  }

  if( isUpperBoundContextFlag ){
    macedbg(1) << "context("<< context_name <<") is an UB. Return!" << Log::endl;
    return;
  }

  for(uint32_t i=0; i<child_contexts.size(); i++) {
    ContextStructureNode* cnode = child_contexts[i];
    cnode->getDominateContexts( dominateContexts );
  }
}

void ContextStructureNode::getAllContextDominators( mace::map<mace::string, mace::string>& dominators ) const {
  dominators[this->context_name] = this->upper_bound_ctx_name;

  for(uint32_t i=0; i<child_contexts.size(); i++) {
    ContextStructureNode* cnode = child_contexts[i];
    cnode->getAllContextDominators( dominators );
  }
}

void ContextStructureNode::getAllParentContextDominators( mace::string const& pDominator, mace::map<mace::string, mace::string>& dominators ) const {
  dominators[this->context_name] = pDominator;

  for(uint32_t i=0; i<child_contexts.size(); i++) {
    ContextStructureNode* cnode = child_contexts[i];
    cnode->getAllParentContextDominators( this->upper_bound_ctx_name, dominators );
  }
}

void ContextStructureNode::getAllDominateContexts(mace::map<mace::string, mace::set<mace::string> >& dominateContexts ) const {
  if( dominateContexts[this->upper_bound_ctx_name].count(this->context_name) == 0 ){
    dominateContexts[this->upper_bound_ctx_name].insert(this->context_name);
  }

  for(uint32_t i=0; i<child_contexts.size(); i++) {
    ContextStructureNode* cnode = child_contexts[i];
    cnode->getAllDominateContexts(dominateContexts);
  }
}

void ContextStructure::constructContextStructure() {
  ADD_SELECTORS("ContextStructure::constructContextStructure");
  macedbg(1) << "Start to construct ContextStructure " << Log::endl;

  ScopedLock sl(contextStructureMutex);

  rootNode = new ContextStructureNode(mace::ContextMapping::GLOBAL_CONTEXT_NAME, "", mace::ContextMapping::HEAD_CONTEXT_ID, true);
  nameNodeMap[mace::ContextMapping::GLOBAL_CONTEXT_NAME] = rootNode;


  std::map<mace::string, ContextStructureNode*> tempNodeMap;
  mace::vector< mace::pair<mace::string, mace::string> > ownerships = ContextStructure::getInitialContextOwnerships();
  
  for(uint32_t i = 0;  i<ownerships.size(); i++) {
    mace::pair<mace::string, mace::string>& ownership = ownerships[i];
    contextOwnerships.insert(ownership);

    mace::string parent_ctx_name = ownership.first;
    mace::string child_ctx_name = ownership.second;



    ContextStructureNode* pNode = findContextNodeNoLock(parent_ctx_name);
    ContextStructureNode* cNode = findContextNodeNoLock(child_ctx_name);
    if( pNode != NULL && cNode != NULL ) {
      ContextStructureNode::setParentChildRelation(pNode, cNode);
      macedbg(1) << "Set ownership #1: " << pNode->getCtxName() << "->" << cNode->getCtxName() << Log::endl;
    } else if (pNode != NULL ) {
      std::map<mace::string, ContextStructureNode*>::iterator tempIter = tempNodeMap.find(child_ctx_name);
      if(tempIter != tempNodeMap.end() ) {
        cNode = tempIter->second;
        tempNodeMap.erase(tempIter);
      } else {
        cNode = new ContextStructureNode(child_ctx_name, "", -1);
      }
      this->addParentChildRelationNoLock(parent_ctx_name, cNode);
      nameNodeMap[child_ctx_name] = cNode;
      macedbg(1) << "Set ownership #2: " << parent_ctx_name << "->" << cNode->getCtxName() << Log::endl;
    } else if (cNode != NULL) {
      std::map<mace::string, ContextStructureNode*>::iterator tempIter = tempNodeMap.find(parent_ctx_name);
      if(tempIter != tempNodeMap.end() ) {
        pNode = tempIter->second;
        tempNodeMap.erase(tempIter);
      } else {
        pNode = new ContextStructureNode(parent_ctx_name, "", -1);
      }
      this->addChildParentRelation(child_ctx_name, pNode);
      nameNodeMap[parent_ctx_name] = pNode;
      macedbg(1) << "Set ownership #3: " << pNode->getCtxName() << "->" << child_ctx_name << Log::endl;
    } else {
      std::map<mace::string, ContextStructureNode*>::iterator tempIter = tempNodeMap.find(child_ctx_name);
      if(tempIter != tempNodeMap.end() ) {
        cNode = tempIter->second;
      } else {
        cNode = new ContextStructureNode(child_ctx_name, "", -1);
        tempNodeMap[child_ctx_name] = cNode;
      }

      tempIter = tempNodeMap.find(parent_ctx_name);
      if(tempIter != tempNodeMap.end() ) {
        pNode = tempIter->second;
      } else {
        pNode = new ContextStructureNode(parent_ctx_name, "", -1);
        tempNodeMap[parent_ctx_name] = pNode;
      }

      ContextStructureNode::setParentChildRelation(pNode, cNode);
      macedbg(1) << "Set ownership #4: " << pNode->getCtxName() << "->" << cNode->getCtxName() << Log::endl;
    }

  }
  mace::vector<mace::string> children = this->getAllChildContextsNoLock(mace::ContextMapping::GLOBAL_CONTEXT_NAME);
  macedbg(1) << "Global context's children: " << children << Log::endl;

  this->findUpperBoundContexts();  
}

void ContextStructure::printAllOwnerships() const {
  ADD_SELECTORS("ContextStructure::printAllOwnerships");
  for(mace::set< mace::pair<mace::string, mace::string> >::const_iterator cIter = contextOwnerships.begin(); 
      cIter != contextOwnerships.end(); cIter++ ) {
    macedbg(1) << *cIter << Log::endl;
  }
}

void ContextStructure::clearUnusedContextStructureNodes() {
  ADD_SELECTORS("ContextStructure::clearUnusedContextStructureNodes");
  bool continue_flag = true;

  while( continue_flag ) {
    continue_flag = false;

    mace::set<mace::string> toDelete;
    std::map<mace::string, ContextStructureNode*>::iterator iter = nameNodeMap.begin();
    for(; iter != nameNodeMap.end(); iter ++ ) {
      ContextStructureNode* _node = iter->second;
      if( _node->parent_contexts.size() == 0 && _node->getCtxName() != mace::ContextMapping::GLOBAL_CONTEXT_NAME ) {
        macedbg(1) << "To delete context: " << _node->getCtxName() << Log::endl;
        toDelete.insert(iter->first);
        _node->clearOwnership();
        delete _node;
        iter->second = NULL;
      }
    }

    if( toDelete.size() > 0 ) {
      continue_flag = true;
    }

    for( mace::set<mace::string>::iterator iter = toDelete.begin(); iter != toDelete.end(); iter ++ ) {
      nameNodeMap.erase(*iter);
    }
  }
}

bool ContextStructure::checkParentChildRelation(mace::string const& p, mace::string const& c) const {
  mace::pair<mace::string, mace::string> ownership(p, c);
  if( contextOwnerships.count(ownership) ) {
    return true;
  } else {
    return false;
  }
}


mace::set<mace::string> ContextStructure::modifyOwnerships(const mace::vector< mace::EventOperationInfo >& ownershipOpInfos) {
  ADD_SELECTORS("ContextStructure::modifyOwnerships");
  mace::map< mace::string, mace::set<mace::string> > oldDominateContexts = this->getAllDominateContexts();


  bool modified_flag = false;
  ScopedLock sl(contextStructureMutex);
  for(uint64_t i=0; i<ownershipOpInfos.size(); i++ ){
    const mace::EventOperationInfo& opInfo = ownershipOpInfos[i];
    macedbg(1) << "Try to apply ownership operation: " << opInfo << Log::endl;
    if( opInfo.opType == mace::EventOperationInfo::ADD_OWNERSHIP_OP && !checkParentChildRelation(opInfo.fromContextName, opInfo.toContextName) ) {
      modified_flag = true;
      macedbg(1) << "To add new ownership from "<< opInfo.fromContextName << " to " << opInfo.toContextName << Log::endl;
      ContextStructureNode* pNode = findContextNodeNoLock(opInfo.fromContextName);
      ASSERT( pNode != NULL );
      ContextStructureNode* cNode = findContextNodeNoLock(opInfo.toContextName);
      if( cNode == NULL ){
        cNode = new ContextStructureNode(opInfo.toContextName, "", -1);
        nameNodeMap[opInfo.toContextName] = cNode;
      } else {
        if( isElderContextNoLock(opInfo.fromContextName, opInfo.toContextName) ) {
          macedbg(1) << "ERROR: "<< opInfo.fromContextName << " is the child of " << opInfo.toContextName << ". This ownership operation is invalid!" << Log::endl;
          continue;
        }
      }
      ContextStructureNode::setParentChildRelation(pNode, cNode);
      mace::pair<mace::string, mace::string> nOwnership( opInfo.fromContextName, opInfo.toContextName );
      contextOwnerships.insert(nOwnership);
    } else if ( opInfo.opType == mace::EventOperationInfo::DELETE_OWNERSHIP_OP && checkParentChildRelation(opInfo.fromContextName, opInfo.toContextName) ) {
      modified_flag = true;
      macedbg(1) << "To delete ownership from "<< opInfo.fromContextName << " to " << opInfo.toContextName << Log::endl;
      ContextStructureNode* pNode = findContextNodeNoLock(opInfo.fromContextName);
      ContextStructureNode* cNode = findContextNodeNoLock(opInfo.toContextName);
      mace::pair<mace::string, mace::string> toDeleteOwnership(opInfo.fromContextName, opInfo.toContextName);
      contextOwnerships.erase(toDeleteOwnership);
      ASSERT( pNode != NULL && cNode != NULL );
      ContextStructureNode::deleteParentChildRelation( pNode, cNode );
    }
  }

  if( !modified_flag ){
    mace::set<mace::string> empty_set;
    return empty_set;
  }

  current_version ++;
  
  clearUnusedContextStructureNodes();

  clearUpperBoundContextFlag();
  mace::set<mace::string> relatedContextNames = findUpperBoundContexts();

  for(uint64_t i=0; i<ownershipOpInfos.size(); i++ ){
    const mace::EventOperationInfo& opInfo = ownershipOpInfos[i];
    if( relatedContextNames.count(opInfo.fromContextName) == 0 ) {
      relatedContextNames.insert(opInfo.fromContextName);
    }
  }

  sl.unlock();

  mace::map< mace::string, mace::set<mace::string> > newDominateContexts = this->getAllDominateContexts();

  for( mace::map< mace::string, mace::set<mace::string> >::iterator iter=oldDominateContexts.begin(); iter!=oldDominateContexts.end(); iter++ ){
    if( relatedContextNames.count( iter->first)>0 ){
      continue;
    }

    if( newDominateContexts.find(iter->first) == newDominateContexts.end() ){
      relatedContextNames.insert(iter->first);
    } else {
      const mace::set<mace::string>& oldSet = iter->second;
      const mace::set<mace::string>& newSet = newDominateContexts[ iter->first ];
      if( oldSet.size() != newSet.size() ){
        relatedContextNames.insert( iter->first );
      } else {
        for( mace::set<mace::string>::const_iterator sIter=oldSet.begin(); sIter!=oldSet.end(); sIter++ ){
          if( newSet.count(*sIter)==0 ){
            relatedContextNames.insert( iter->first );
            break;
          }
        }
      }
    }
  }

  // to make sure related contexts are within ownership DAG
  mace::set< mace::string > candidateRelatedContextNames = relatedContextNames;
  relatedContextNames.clear();

  for( mace::set<mace::string>::const_iterator iter = candidateRelatedContextNames.begin(); iter != candidateRelatedContextNames.end(); iter++ ) {
    if( this->hasContextNode(*iter) ) {
      relatedContextNames.insert( *iter );
    } else {
      macedbg(1) << "context("<< *iter <<") has been removed from ownership DAG!" << Log::endl;
    }
  }

  return relatedContextNames;
}

mace::string ContextStructure::getParentContextName( mace::string const& ctxName ) const {
  ScopedLock sl(contextStructureMutex);
  mace::string parentContextName = "";
  std::map<mace::string, ContextStructureNode*>::const_iterator c_iter = nameNodeMap.find(ctxName);
  if( c_iter != nameNodeMap.end() ) {
    const ContextStructureNode* node = c_iter->second;
    mace::vector<mace::string> parentContextNames = node->getParentNames();
    if( parentContextNames.size() > 0 ) {
      parentContextName = parentContextNames[0];
    }
  }
  return parentContextName;
}

void ContextStructure::updateOwnerships(const mace::vector< mace::pair<mace::string, mace::string> >& ownershipPairs, const uint64_t currentVer) {
  ADD_SELECTORS("ContextStructure::updateOwnership");
  ScopedLock sl(contextStructureMutex);
  if( current_version >= currentVer ) {
    return;
  }
  macedbg(1) << "Try to update ownership from "<< current_version <<" to "<< currentVer << Log::endl;
  mace::set< mace::pair<mace::string, mace::string> > newContextOwnerships;
  // add new ownership
  for(uint64_t i=0; i<ownershipPairs.size(); i++ ){
    const mace::pair<mace::string, mace::string>& ownershipPair = ownershipPairs[i];
    if( !checkParentChildRelation(ownershipPair.first, ownershipPair.second) ) {
      ContextStructureNode* pNode = findContextNodeNoLock(ownershipPair.first);
      ASSERT( pNode != NULL );
      ContextStructureNode* cNode = findContextNodeNoLock(ownershipPair.second);
      if( cNode == NULL ){
        cNode = new ContextStructureNode(ownershipPair.second, "", -1);
        nameNodeMap[ownershipPair.second] = cNode;
      } 
      ContextStructureNode::setParentChildRelation(pNode, cNode);
    }
    newContextOwnerships.insert(ownershipPair); 
  }

  current_version = currentVer;

  for( mace::set< mace::pair<mace::string, mace::string> >::iterator iter = contextOwnerships.begin(); iter != contextOwnerships.end(); iter ++ ) {
    if( newContextOwnerships.count(*iter) == 0 ) {
      const mace::pair<mace::string, mace::string>& ownershipPair = *iter;
      ContextStructureNode* pNode = findContextNodeNoLock(ownershipPair.first);
      ContextStructureNode* cNode = findContextNodeNoLock(ownershipPair.second);
      ASSERT(pNode != NULL && cNode != NULL );
      ContextStructureNode::deleteParentChildRelation(pNode, cNode);
    }
  }
  contextOwnerships = newContextOwnerships;
  
  clearUnusedContextStructureNodes();
  clearUpperBoundContextFlag();
  findUpperBoundContexts();
}

mace::vector< mace::pair<mace::string, mace::string> > ContextStructure::getAllOwnerships() const {
  mace::vector< mace::pair<mace::string, mace::string> > ownerships;
  ScopedLock sl(contextStructureMutex);
  getAllOwnerships(rootNode, ownerships);
  return ownerships;
}

void ContextStructure::getAllOwnerships( const ContextStructureNode* node, mace::vector< mace::pair<mace::string, mace::string> >& ownerships) const {
  if( node == NULL ) {
    return;
  }

  const ContextStructureNode::ContextStructureNodesType& children = node->getChildren();
  for( ContextStructureNode::ContextStructureNodesType::const_iterator c_iter = children.begin(); c_iter != children.end(); c_iter ++ ) {
    mace::pair<mace::string, mace::string> ownership( node->getCtxName(), (*c_iter)->getCtxName() );
    ownerships.push_back(ownership);
    getAllOwnerships( (*c_iter), ownerships );
  }
}

void ContextStructure::clearUpperBoundContextFlag( ContextStructureNode* root ) {
  if(root == NULL) {
    return;
  }
  
  ContextStructureNode::ContextStructureNodesType children = root->getChildren();
  for(uint64_t i = 0; i < children.size(); i ++) {
    ContextStructureNode* node = children[i];
    clearUpperBoundContextFlag(node);
  }
  root->setIsUpperBoundContext(false);
  
}
/*
void ContextStructure::frozenContextStructure() {
  ADD_SELECTORS("ContextStructure::frozenContextStructure");
  ScopedLock sl( contextStructureMutex );
  if( frozenFlag ){
    return;
  }
  waitingConds.clear();
  frozenFlag = true;
  macedbg(1) << "To frozen ContextStructure until Dominator modification is done!" << Log::endl;
}

void ContextStructure::deFrozenContextStructure() {
  ScopedLock sl( contextStructureMutex );
  if( !frozenFlag ){
    return;
  }
  frozenFlag = false;

  for( uint32_t i=0; i<waitingConds.size(); i++ ){
    if( waitingConds[i] != NULL ){
      pthread_cond_signal( waitingConds[i] );
    }
  }
}
*/
void ContextStructure::getLock( const uint8_t lock_type ) {
  ADD_SELECTORS("ContextStructure::getLock");
  
  macedbg(1) << "Try to get lock=" << (uint16_t)lock_type << " waitingConds.size="<< waitingConds.size() << " nreader="<< nreader << " nwriter=" << nwriter << Log::endl;
  ScopedLock sl( contextStructureMutex );
  if( lock_type == ContextStructure::READER ) {
    if( waitingConds.size() == 0 && nwriter == 0 ){
      nreader ++;
      macedbg(1) << "Get lock=" << (uint16_t)lock_type << Log::end;
    } else {
      pthread_cond_t cond;
      pthread_cond_init(&cond, NULL);

      std::pair<uint8_t, pthread_cond_t*> p(lock_type, &cond);
      waitingConds.push_back(p);
      macedbg(1) << "Waiting... waitingConds.size="<< waitingConds.size() << " nreader="<< nreader << " nwriter=" << nwriter << Log::endl;
      pthread_cond_wait( &cond, &contextStructureMutex );
      pthread_cond_destroy(&cond);
      macedbg(1) << "Wakeup!!! nreader=" << nreader << " nwriter=" << nwriter << Log::end;
      ASSERT( nwriter == 0 );
      //nreader ++;
    }
  } else if( lock_type == ContextStructure::WRITER ) {
    if( waitingConds.size() == 0 && nwriter == 0 && nreader == 0 ) {
      nwriter ++;
      macedbg(1) << "Get lock=" << (uint16_t)lock_type << Log::end;
    } else {
      pthread_cond_t cond;
      pthread_cond_init(&cond, NULL);

      std::pair<uint8_t, pthread_cond_t*> p(lock_type, &cond);
      waitingConds.push_back(p);
      macedbg(1) << "Waiting... waitingConds.size="<< waitingConds.size() << " nreader="<< nreader << " nwriter=" << nwriter << Log::endl;
      pthread_cond_wait( &cond, &contextStructureMutex );
      pthread_cond_destroy(&cond);
      macedbg(1) << "Wakeup!!! nreader=" << nreader << " nwriter=" << nwriter << Log::end;
      ASSERT( nwriter == 1 && nreader == 0 );
      //nwriter ++;
    }
  }
  
}

void ContextStructure::releaseLock( const uint8_t lock_type ) {
  ADD_SELECTORS("ContextStructure::releaseLock");
  
  ScopedLock sl( contextStructureMutex );
  macedbg(1) << "To release lock_type=" << (uint16_t)lock_type << " nreader=" << nreader << " nwriter="<< nwriter << Log::endl;
  if( lock_type == ContextStructure::READER ) {
    nreader --;
  } else if( lock_type == ContextStructure::WRITER ) {
    nwriter --;
  } else {
    ASSERT(false);
  }

  if( nreader == 0 && nwriter == 0 ){
    bool first_locker = true;
    while( waitingConds.size() > 0 ) {
      std::pair<uint8_t, pthread_cond_t*>& p = waitingConds.front();

      if( p.first == ContextStructure::READER ) {
        macedbg(1) << "Release lock=" << (uint16_t)p.first << Log::endl;
        pthread_cond_t* cond = p.second;
        p.second = NULL;
        pthread_cond_signal( cond ); nreader ++;
        waitingConds.pop_front();
      } else if( p.first == ContextStructure::WRITER ) {
        if( first_locker ) {
          macedbg(1) << "Release lock=" << (uint16_t)p.first << Log::endl;
          pthread_cond_t* cond = p.second;
          p.second = NULL;
          pthread_cond_signal( cond ); nwriter ++;
          waitingConds.pop_front();
        }
        break;
      }
      first_locker = false;
    }
  }
  
}

mace::map<mace::string, mace::string> ContextStructure::getAllContextDominators() const {
  ScopedLock sl(contextStructureMutex);

  mace::map<mace::string, mace::string> dominators;
  if( rootNode!=NULL ){
    rootNode->getAllContextDominators( dominators );
  }  

  return dominators;
}

mace::map<mace::string, mace::string> ContextStructure::getAllParentContextDominators() const {
  ScopedLock sl(contextStructureMutex);

  mace::map<mace::string, mace::string> dominators;
  if( rootNode!=NULL ){
    rootNode->getAllParentContextDominators( rootNode->getCtxName(), dominators );
  }  

  return dominators;
}

mace::map<mace::string, mace::set<mace::string> > ContextStructure::getAllDominateContexts() const {
  ScopedLock sl(contextStructureMutex);
  mace::map<mace::string, mace::set<mace::string> > dominateContexts;
  if( rootNode!=NULL ){
    rootNode->getAllDominateContexts( dominateContexts);
  } 

  return dominateContexts;
}


